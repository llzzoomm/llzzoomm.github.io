<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"llzzoomm.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false,"scrollpercent":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="java基础">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础原理">
<meta property="og:url" content="https://llzzoomm.github.io/2023/04/16/java-ji-chu-yuan-li/index.html">
<meta property="og:site_name" content="llzzoomm">
<meta property="og:description" content="java基础">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-04-16T07:16:15.775Z">
<meta property="article:modified_time" content="2023-04-16T07:18:56.743Z">
<meta property="article:author" content="lz">
<meta property="article:tag" content="原理">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://llzzoomm.github.io/2023/04/16/java-ji-chu-yuan-li/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java基础原理 | llzzoomm</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="llzzoomm" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">llzzoomm</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">德玛西亚</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">16</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">71</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://llzzoomm.github.io/2023/04/16/java-ji-chu-yuan-li/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="lz">
      <meta itemprop="description" content="德玛西亚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="llzzoomm">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java基础原理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-16 15:16:15 / 修改时间：15:18:56" itemprop="dateCreated datePublished" datetime="2023-04-16T15:16:15+08:00">2023-04-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">原理</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>71k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><span id="more"></span>

<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><h3 id="对比面向过程，是两种不同的处理问题的角度"><a href="#对比面向过程，是两种不同的处理问题的角度" class="headerlink" title="对比面向过程，是两种不同的处理问题的角度"></a>对比面向过程，是两种不同的处理问题的角度</h3><h3 id="面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、及各自需要做"><a href="#面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、及各自需要做" class="headerlink" title="面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、及各自需要做"></a>面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、及各自需要做</h3><h3 id="什么"><a href="#什么" class="headerlink" title="什么"></a>什么</h3><h3 id="比如：洗衣机洗衣服"><a href="#比如：洗衣机洗衣服" class="headerlink" title="比如：洗衣机洗衣服"></a>比如：洗衣机洗衣服</h3><h3 id="面向过程会将任务拆解成一系列的步骤（函数），-1-、打开洗衣机—–-gt-2、放衣服—–-gt-3、放洗衣粉—–"><a href="#面向过程会将任务拆解成一系列的步骤（函数），-1-、打开洗衣机—–-gt-2、放衣服—–-gt-3、放洗衣粉—–" class="headerlink" title="面向过程会将任务拆解成一系列的步骤（函数）， 1 、打开洗衣机—–>2、放衣服—–>3、放洗衣粉—–"></a>面向过程会将任务拆解成一系列的步骤（函数）， 1 、打开洗衣机—–&gt;2、放衣服—–&gt;3、放洗衣粉—–</h3><h3 id="gt-4、清洗—–-gt-5、烘干"><a href="#gt-4、清洗—–-gt-5、烘干" class="headerlink" title=">4、清洗—–>5、烘干"></a>&gt;4、清洗—–&gt;5、烘干</h3><h3 id="面向对象会拆出人和洗衣机两个对象："><a href="#面向对象会拆出人和洗衣机两个对象：" class="headerlink" title="面向对象会拆出人和洗衣机两个对象："></a>面向对象会拆出人和洗衣机两个对象：</h3><h3 id="人：打开洗衣机-放衣服-放洗衣粉"><a href="#人：打开洗衣机-放衣服-放洗衣粉" class="headerlink" title="人：打开洗衣机 放衣服 放洗衣粉"></a>人：打开洗衣机 放衣服 放洗衣粉</h3><h3 id="洗衣机：清洗-烘干"><a href="#洗衣机：清洗-烘干" class="headerlink" title="洗衣机：清洗 烘干"></a>洗衣机：清洗 烘干</h3><h3 id="从以上例子能看出，面向过程比较直接高效，而面向对象更易于复用、扩展和维护"><a href="#从以上例子能看出，面向过程比较直接高效，而面向对象更易于复用、扩展和维护" class="headerlink" title="从以上例子能看出，面向过程比较直接高效，而面向对象更易于复用、扩展和维护"></a>从以上例子能看出，面向过程比较直接高效，而面向对象更易于复用、扩展和维护</h3><h3 id="面向对象-1"><a href="#面向对象-1" class="headerlink" title="面向对象"></a>面向对象</h3><h3 id="封装-：封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项"><a href="#封装-：封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项" class="headerlink" title="封装 ：封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项"></a>封装 ：封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项</h3><h3 id="内部细节对外部调用透明，外部调用无需修改或者关心内部实现"><a href="#内部细节对外部调用透明，外部调用无需修改或者关心内部实现" class="headerlink" title="内部细节对外部调用透明，外部调用无需修改或者关心内部实现"></a>内部细节对外部调用透明，外部调用无需修改或者关心内部实现</h3><p>1 、javabean的属性私有，提供getset对外访问，因为属性的赋值或者获取逻辑只能由javabean本身决<br>定。而不能由外部胡乱修改</p>
<p>2 、orm框架</p>
<p>操作数据库，我们不需要关心链接是如何建立的、sql是如何执行的，只需要引入mybatis，调方法即可</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setName</span>(<span class="params"><span class="built_in">String</span> name</span>){</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">"tuling_"</span>+name;</span><br><span class="line">}</span><br><span class="line">该name有自己的命名规则，明显不能由外部直接赋值</span><br></pre></td></tr></tbody></table></figure>

<h3 id="继承-：继承基类的方法，并做出自己的改变和-或扩展"><a href="#继承-：继承基类的方法，并做出自己的改变和-或扩展" class="headerlink" title="继承 ：继承基类的方法，并做出自己的改变和/或扩展"></a>继承 ：继承基类的方法，并做出自己的改变和/或扩展</h3><h3 id="子类共性的方法或者属性直接使用父类的，而不需要自己再定义，只需扩展自己个性化的"><a href="#子类共性的方法或者属性直接使用父类的，而不需要自己再定义，只需扩展自己个性化的" class="headerlink" title="子类共性的方法或者属性直接使用父类的，而不需要自己再定义，只需扩展自己个性化的"></a>子类共性的方法或者属性直接使用父类的，而不需要自己再定义，只需扩展自己个性化的</h3><h3 id="多态-：基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。"><a href="#多态-：基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。" class="headerlink" title="多态 ：基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。"></a>多态 ：基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。</h3><h3 id="继承，方法重写，父类引用指向子类对象"><a href="#继承，方法重写，父类引用指向子类对象" class="headerlink" title="继承，方法重写，父类引用指向子类对象"></a>继承，方法重写，父类引用指向子类对象</h3><h3 id="无法调用子类特有的功能"><a href="#无法调用子类特有的功能" class="headerlink" title="无法调用子类特有的功能"></a>无法调用子类特有的功能</h3><h2 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK JRE JVM"></a>JDK JRE JVM</h2><h3 id="JDK："><a href="#JDK：" class="headerlink" title="JDK："></a>JDK：</h3><p>Java Develpment Kit java 开发工具</p>
<p>JRE：</p>
<p>Java Runtime Environment java运行时环境</p>
<p>JVM：</p>
<p>java Virtual Machine java 虚拟机</p>
<h2 id="和equals比较"><a href="#和equals比较" class="headerlink" title="==和equals比较"></a>==和equals比较</h2><h3 id="对比的是栈中的值，基本数据类型是变量值，引用类型是堆中内存对象的地址"><a href="#对比的是栈中的值，基本数据类型是变量值，引用类型是堆中内存对象的地址" class="headerlink" title="==对比的是栈中的值，基本数据类型是变量值，引用类型是堆中内存对象的地址"></a>==对比的是栈中的值，基本数据类型是变量值，引用类型是堆中内存对象的地址</h3><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型 变量名 <span class="operator">=</span> new 子类对象 <span class="comment">;</span></span><br><span class="line">变量名.方法名()<span class="comment">;</span></span><br></pre></td></tr></tbody></table></figure>

<p>equals：object中默认也是采用==比较，通常会重写</p>
<p>Object</p>
<p>String</p>
<p>上述代码可以看出，String类中被复写的equals()方法其实是比较两个字符串的内容。</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">equals</span>(<span class="params"><span class="built_in">Object</span> obj</span>) {</span><br><span class="line"><span class="keyword">return</span> (<span class="variable language_">this</span> == obj);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight processing"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span>(<span class="built_in">Object</span> anObject) {</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">this</span> == anObject) {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> <span class="built_in">String</span>) {</span><br><span class="line"><span class="built_in">String</span> anotherString = (<span class="built_in">String</span>)anObject;</span><br><span class="line"><span class="type">int</span> n = value.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">if</span> (n == anotherString.<span class="property">value</span>.<span class="property">length</span>) {</span><br><span class="line"><span class="type">char</span> v1[] = value;</span><br><span class="line"><span class="type">char</span> v2[] = anotherString.<span class="property">value</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span> (n-- != <span class="number">0</span> ) {</span><br><span class="line"><span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StringDemo</span> {</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span> {</span><br><span class="line">String str1 = <span class="string">"Hello"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br><span class="line">String str3 = str2; <span class="comment">// 引用传递</span></span><br><span class="line">System.<span class="keyword">out</span>.println(str1 == str2); <span class="comment">// false</span></span><br><span class="line">System.<span class="keyword">out</span>.println(str1 == str3); <span class="comment">// false</span></span><br><span class="line">System.<span class="keyword">out</span>.println(str2 == str3); <span class="comment">// true</span></span><br><span class="line">System.<span class="keyword">out</span>.println(str1.<span class="keyword">equals</span>(str2)); <span class="comment">// true</span></span><br><span class="line">System.<span class="keyword">out</span>.println(str1.<span class="keyword">equals</span>(str3)); <span class="comment">// true</span></span><br><span class="line">System.<span class="keyword">out</span>.println(str2.<span class="keyword">equals</span>(str3)); <span class="comment">// true</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="hashCode与equals"><a href="#hashCode与equals" class="headerlink" title="hashCode与equals"></a>hashCode与equals</h2><p>hashCode介绍：</p>
<p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是<br>确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有<br>hashCode() 函数。<br>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用<br>到了散列码！（可以快速找到所需要的对象）</p>
<p>为什么要有hashCode：</p>
<p><strong>以“HashSet如何检查重复”为例子来说明为什么要有hashCode：</strong><br>对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，看该位置是否有<br>值，如果没有、HashSet会假设对象没有重复出现。但是如果发现有值，这时会调用equals（）方法来<br>检查两个对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会<br>重新散列到其他位置。这样就大大减少了equals的次数，相应就大大提高了执行速度。</p>
<figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果两个对象相等，则hashcode一定也是相同的</span><br><span class="line">两个对象相等,对两个对象分别调用<span class="keyword">equals</span>方法都返回<span class="literal">true</span></span><br><span class="line">两个对象有相同的hashcode值，它们也不一定是相等的</span><br><span class="line">因此，<span class="keyword">equals</span>方法被覆盖过，则hashCode方法也必须被覆盖</span><br><span class="line">hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该<span class="built_in">class</span>的两个</span><br><span class="line">对象无论如何都不会相等（即使这两个对象指向相同的数据）</span><br></pre></td></tr></tbody></table></figure>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><h3 id="最终的"><a href="#最终的" class="headerlink" title="最终的"></a>最终的</h3><h3 id="修饰类：表示类不可被继承"><a href="#修饰类：表示类不可被继承" class="headerlink" title="修饰类：表示类不可被继承"></a>修饰类：表示类不可被继承</h3><h3 id="修饰方法：表示方法不可被子类覆盖，但是可以重载"><a href="#修饰方法：表示方法不可被子类覆盖，但是可以重载" class="headerlink" title="修饰方法：表示方法不可被子类覆盖，但是可以重载"></a>修饰方法：表示方法不可被子类覆盖，但是可以重载</h3><h3 id="修饰变量：表示变量一旦被赋值就不可以更改它的值。"><a href="#修饰变量：表示变量一旦被赋值就不可以更改它的值。" class="headerlink" title="修饰变量：表示变量一旦被赋值就不可以更改它的值。"></a>修饰变量：表示变量一旦被赋值就不可以更改它的值。</h3><h3 id="（-1-）修饰成员变量"><a href="#（-1-）修饰成员变量" class="headerlink" title="（ 1 ）修饰成员变量"></a>（ 1 ）修饰成员变量</h3><figure class="highlight actionscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果<span class="keyword">final</span>修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。</span><br><span class="line">如果<span class="keyword">final</span>修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。</span><br></pre></td></tr></tbody></table></figure>
<p>（ 2 ）修饰局部变量</p>
<p>系统不会为局部变量进行初始化，局部变量必须由程序员显示初始化。因此使用final修饰局部变量时，<br>即可以在定义时指定默认值（后面的代码不能对变量再赋值），也可以不指定默认值，而在后面的代码<br>中对final变量赋初值（仅一次）</p>
<figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalVar</span> {</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="built_in">int</span> a = <span class="number">0</span> ;<span class="comment">//再声明的时候就需要赋值 或者静态代码块赋值</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">static{</span></span><br><span class="line"><span class="comment">a = 0;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">int</span> b = <span class="number">0</span> ;<span class="comment">//再声明的时候就需要赋值 或者代码块中赋值 或者构造器赋值</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="（-3-）修饰基本类型数据和引用类型数据"><a href="#（-3-）修饰基本类型数据和引用类型数据" class="headerlink" title="（ 3 ）修饰基本类型数据和引用类型数据"></a>（ 3 ）修饰基本类型数据和引用类型数据</h3><h3 id="如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；"><a href="#如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；" class="headerlink" title="如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；"></a>如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；</h3><h3 id="如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。-但是引用的值是可变"><a href="#如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。-但是引用的值是可变" class="headerlink" title="如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 但是引用的值是可变"></a>如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 但是引用的值是可变</h3><h3 id="的-。"><a href="#的-。" class="headerlink" title="的 。"></a>的 。</h3><p><strong>为什么局部内部类和匿名内部类只能访问局部final变量？</strong></p>
<p>编译之后会生成两个class文件，Test.class Test1.class</p>
<figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*{</span></span><br><span class="line"><span class="comment">b = 0;</span></span><br><span class="line"><span class="comment">}*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>{</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> localA; <span class="comment">//局部变量只声明没有初始化，不会报错,与final无关。</span></span><br><span class="line">localA = <span class="number">0</span> ;<span class="comment">//在使用之前一定要赋值</span></span><br><span class="line"><span class="comment">//localA = 1; 但是不允许第二次赋值</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceTest</span></span>{</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] iArr={ <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> };</span><br><span class="line">iArr[ <span class="number">2</span> ]=- <span class="number">3</span> ;<span class="comment">//合法</span></span><br><span class="line">iArr=<span class="keyword">null</span>;<span class="comment">//非法，对iArr不能重新赋值</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final Person p <span class="operator">=</span> new Person( <span class="number">25</span> )<span class="comment">;</span></span><br><span class="line">p.setAge( <span class="number">24</span> )<span class="comment">;//合法</span></span><br><span class="line"><span class="attribute">p</span><span class="operator">=</span>null<span class="comment">;//非法</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> {</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> {</span><br><span class="line">}</span><br><span class="line"><span class="comment">//局部final变量a,b</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="params">final <span class="built_in">int</span> b</span>)</span> {<span class="comment">//jdk8在这里做了优化, 不用写,语法糖，但实际上也是有</span></span><br><span class="line">的，也不能修改</span><br><span class="line">final <span class="built_in">int</span> a = <span class="number">10</span> ;</span><br><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line"><span class="keyword">new</span> Thread(){</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span> {</span><br><span class="line">System.<span class="keyword">out</span>.println(a);</span><br><span class="line">System.<span class="keyword">out</span>.println(b);</span><br><span class="line">};</span><br><span class="line">}.start();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">OutClass</span> {</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> age = <span class="number">12</span> ;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outPrint</span>(<span class="params">final <span class="built_in">int</span> x</span>)</span> {</span><br><span class="line"><span class="keyword">class</span> <span class="title">InClass</span> {</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InPrint</span>()</span> {</span><br><span class="line">System.<span class="keyword">out</span>.println(x);</span><br><span class="line">System.<span class="keyword">out</span>.println(age);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="首先需要知道的一点是-内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着"><a href="#首先需要知道的一点是-内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着" class="headerlink" title="首先需要知道的一点是: 内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着"></a>首先需要知道的一点是: 内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着</h3><h3 id="方法的执行完毕就被销毁。"><a href="#方法的执行完毕就被销毁。" class="headerlink" title="方法的执行完毕就被销毁。"></a>方法的执行完毕就被销毁。</h3><h3 id="这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在-只有"><a href="#这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在-只有" class="headerlink" title="这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有"></a>这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有</h3><h3 id="没有人再引用它时，才会死亡-。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解"><a href="#没有人再引用它时，才会死亡-。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解" class="headerlink" title="没有人再引用它时，才会死亡)。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解"></a>没有人再引用它时，才会死亡)。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解</h3><h3 id="决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以"><a href="#决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以" class="headerlink" title="决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以"></a>决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以</h3><p>访问它，实际访问的是局部变量的”copy”。这样就好像延长了局部变量的生命周期</p>
<h3 id="将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修"><a href="#将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修" class="headerlink" title="将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修"></a>将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修</h3><h3 id="改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢？"><a href="#改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢？" class="headerlink" title="改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢？"></a>改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢？</h3><p>就将局部变量设置为final，对它初始化后，我就不让你再去修改这个变量，就保证了内部类的成员变量<br>和方法的局部变量的一致性。这实际上也是一种妥协。使得局部变量与内部类内建立的拷贝保持一致。</p>
<h2 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h2><p>String是final修饰的，不可变，每次操作都会产生新的String对象</p>
<p>StringBuffer和StringBuilder都是在原对象上操作</p>
<p>StringBuffer是线程安全的，StringBuilder线程不安全的</p>
<p>StringBuffer方法都是synchronized修饰的</p>
<p>性能：StringBuilder &gt; StringBuffer &gt; String</p>
<h3 id="场景：经常需要改变字符串内容时使用后面两个"><a href="#场景：经常需要改变字符串内容时使用后面两个" class="headerlink" title="场景：经常需要改变字符串内容时使用后面两个"></a>场景：经常需要改变字符串内容时使用后面两个</h3><p>优先使用StringBuilder，多线程使用共享变量时使用StringBuffer</p>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><h3 id="重载：-发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问"><a href="#重载：-发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问" class="headerlink" title="重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问"></a>重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问</h3><h3 id="修饰符可以不同，发生在编译时。"><a href="#修饰符可以不同，发生在编译时。" class="headerlink" title="修饰符可以不同，发生在编译时。"></a>修饰符可以不同，发生在编译时。</h3><h3 id="重写：-发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于"><a href="#重写：-发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于" class="headerlink" title="重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于"></a>重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于</h3><p>等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方<br>法。</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">new</span> <span class="constructor">InClass()</span>.<span class="constructor">InPrint()</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">抽象类可以存在普通成员函数，而接口中只能存在<span class="keyword">public</span> <span class="keyword">abstract</span> 方法。</span><br><span class="line">抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>类型的。</span><br><span class="line">抽象类只能继承一个，接口可以实现多个。</span><br></pre></td></tr></tbody></table></figure>
<p>接口的设计目的，是对类的行为进行约束（更准确的说是一种“有”约束，因为接口不能规定类不可以有<br>什么行为），也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，<br>但不对如何实现行为进行限制。</p>
<p>而抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为(记为行为集合A)，且其中一部分行<br>为的实现方式一致时（A的非真子集，记为B），可以让这些类都派生于一个抽象类。在这个抽象类中实<br>现了B，避免让所有的子类来实现B，这就达到了代码复用的目的。而A减B的部分，留给各个子类自己<br>实现。正是因为A-B在这里没有实现，所以抽象类不允许实例化出来（否则当调用到A-B时，无法执<br>行）。</p>
<p>抽象类是对类本质的抽象，表达的是 is a 的关系，比如：BMW is a Car。抽象类包含并实现子类的通<br>用特性，将子类存在差异化的特性进行抽象，交由子类去实现。</p>
<p>而接口是对行为的抽象，表达的是 like a 的关系。比如：Bird like a Aircraft（像飞行器一样可以<br>飞），但其本质上 is a Bird。接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、<br>是如何实现的，接口并不关心。</p>
<p>使用场景：当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。</p>
<p>抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也<br>是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功<br>能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计<br>阶段会降低难度</p>
<h2 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a>List和Set的区别</h2><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>：有序，按对象进入的顺序保存对象，可重复，允许多个<span class="built_in">Null</span>元素对象，可以使用<span class="built_in">Iterator</span>取出</span><br><span class="line">所有元素，在逐一遍历，还可以使用<span class="keyword">get</span>(<span class="built_in">int</span> index)获取指定下标的元素</span><br><span class="line"><span class="built_in">Set</span>：无序，不可重复，最多允许有一个<span class="built_in">Null</span>元素对象，取元素时只能用<span class="built_in">Iterator</span>接口取得所有元</span><br><span class="line">素，在逐一遍历各个元素</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight processing"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="built_in">add</span>(<span class="type">int</span> a,<span class="built_in">String</span> b)</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">String</span> <span class="built_in">add</span>(<span class="type">int</span> a,<span class="built_in">String</span> b)</span><br><span class="line"><span class="comment">//编译报错</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h2><p>ArrayList：基于动态数组，连续内存存储，适合下标访问（随机访问），扩容机制：因为数组长度固<br>定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会<br>涉及到元素的移动（往后复制一份，插入新元素），使用尾插法并指定初始容量可以极大提升性能、甚<br>至超过linkedList（需要创建大量的node对象）</p>
<p>LinkedList：基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询：需要逐<br>一遍历</p>
<p>遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通过get(i)取得某一元素时都需<br>要对list重新进行遍历，性能消耗极大。<br>另外不要试图使用indexOf等返回元素索引，并利用其进行遍历，使用indexlOf对list进行了遍历，当结<br>果为空时会遍历整个列表。</p>
<h2 id="HashMap和HashTable有什么区别？其底层实现是什"><a href="#HashMap和HashTable有什么区别？其底层实现是什" class="headerlink" title="HashMap和HashTable有什么区别？其底层实现是什"></a>HashMap和HashTable有什么区别？其底层实现是什</h2><h2 id="么？"><a href="#么？" class="headerlink" title="么？"></a>么？</h2><h3 id="区别-："><a href="#区别-：" class="headerlink" title="区别 ："></a>区别 ：</h3><p>（ 1 ）HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全；</p>
<p>（ 2 ）HashMap允许key和value为null，而HashTable不允许</p>
<p>2.底层实现：数组+链表实现</p>
<p>jdk8开始链表高度到 8 、数组长度超过 64 ，链表转变为红黑树，元素以内部类Node节点存在</p>
<figure class="highlight arcade"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">计算key的<span class="built_in">hash</span>值，二次<span class="built_in">hash</span>然后对数组长度取模，对应到数组下标，</span><br><span class="line">如果没有产生<span class="built_in">hash</span>冲突(下标位置没有元素)，则直接创建Node存入数组，</span><br><span class="line">如果产生<span class="built_in">hash</span>冲突，先进行equal比较，相同则取代该元素，不同，则判断链表高度插入链表，链</span><br><span class="line">表高度达到 <span class="number">8</span> ，并且数组长度到 <span class="number">64</span> 则转变为红黑树，长度低于 <span class="number">6</span> 则将红黑树转回链表</span><br><span class="line">key为<span class="literal">null</span>，存在下标 <span class="number">0</span> 的位置</span><br></pre></td></tr></tbody></table></figure>
<p>数组扩容</p>
<h2 id="ConcurrentHashMap原理，jdk7和jdk8版本的区别"><a href="#ConcurrentHashMap原理，jdk7和jdk8版本的区别" class="headerlink" title="ConcurrentHashMap原理，jdk7和jdk8版本的区别"></a>ConcurrentHashMap原理，jdk7和jdk8版本的区别</h2><p>jdk7：</p>
<p>数据结构：ReentrantLock+Segment+HashEntry，一个Segment中包含一个HashEntry数组，每个<br>HashEntry又是一个链表结构</p>
<p>元素查询：二次hash，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部</p>
<p>锁：Segment分段锁 Segment继承了ReentrantLock，锁定操作的Segment，其他的Segment不受影<br>响，并发度为segment个数，可以通过构造函数指定，数组扩容不会影响其他的segment</p>
<p>get方法无需加锁，volatile保证</p>
<p>jdk8：</p>
<p>数据结构：synchronized+CAS+Node+红黑树，Node的val和next都用volatile修饰，保证可见性</p>
<p>查找，替换，赋值操作都使用CAS</p>
<p>锁：锁链表的head节点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时，阻塞所有的读写<br>操作、并发扩容</p>
<p>读操作无锁：<br>Node的val和next使用volatile修饰，读写线程对该变量互相可见<br>数组用volatile修饰，保证扩容时被读线程感知</p>
<h2 id="什么是字节码？采用字节码的好处是什么？"><a href="#什么是字节码？采用字节码的好处是什么？" class="headerlink" title="什么是字节码？采用字节码的好处是什么？"></a>什么是字节码？采用字节码的好处是什么？</h2><p><strong>java中的编译器和解释器：</strong></p>
<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器<br>在任何平台上都提供给编译程序一个的共同的接口。<br>编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系<br>统的机器码执行。在Java中，这种供虚拟机理解的代码叫做 字节码（即扩展名为 .class的文件），它不<br>面向任何特定的处理器，只面向虚拟机。<br>每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节<br>码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机<br>器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。<br>Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执<br>行的二进制机器码—-&gt;程序运行。<br><strong>采用字节码的好处：</strong></p>
<p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解<br>释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，<br>因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>
<h2 id="Java中的异常体系"><a href="#Java中的异常体系" class="headerlink" title="Java中的异常体系"></a>Java中的异常体系</h2><p>Java中的所有异常都来自顶级父类Throwable。<br>Throwable下有两个子类Exception和Error。<br>Error是程序无法处理的错误，一旦出现这个错误，则程序将被迫停止运行。<br>Exception不会导致程序停止，又分为两个部分RunTimeException运行时异常和CheckedException检<br>查异常。<br>RunTimeException常常发生在程序运行过程中，会导致程序当前线程执行失败。CheckedException常<br>常发生在程序编译过程中，会导致程序编译不通过。</p>
<h2 id="Java类加载器"><a href="#Java类加载器" class="headerlink" title="Java类加载器"></a>Java类加载器</h2><p>JDK自带有三个类加载器：bootstrap ClassLoader、ExtClassLoader、AppClassLoader。<br>BootStrapClassLoader是ExtClassLoader的父类加载器，默认负责加载%JAVA_HOME%lib下的jar包和<br>class文件。<br>ExtClassLoader是AppClassLoader的父类加载器，负责加载%JAVA_HOME%/lib/ext文件夹下的jar包和<br>class类。<br>AppClassLoader是自定义类加载器的父类，负责加载classpath下的类文件。系统类加载器，线程上下<br>文加载器</p>
<p>继承ClassLoader实现自定义类加载器</p>
<h2 id="双亲委托模型"><a href="#双亲委托模型" class="headerlink" title="双亲委托模型"></a>双亲委托模型</h2><h3 id="双亲委派模型的好处："><a href="#双亲委派模型的好处：" class="headerlink" title="双亲委派模型的好处："></a>双亲委派模型的好处：</h3><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主要是为了安全性，避免用户自己编写的类动态替换 Java的一些核心类，比如 String。</span><br><span class="line">同时也避免了类的重复加载，因为 JVM中区分不同类，不仅仅是根据类名，相同的 <span class="keyword">class</span>文件被不</span><br><span class="line">同的 <span class="symbol">ClassLoader</span>加载就是不同的两个类</span><br></pre></td></tr></tbody></table></figure>
<h2 id="GC如何判断对象可以被回收"><a href="#GC如何判断对象可以被回收" class="headerlink" title="GC如何判断对象可以被回收"></a>GC如何判断对象可以被回收</h2><h3 id="引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加-1-，引用释放时计数减-1-，计"><a href="#引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加-1-，引用释放时计数减-1-，计" class="headerlink" title="引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加 1 ，引用释放时计数减 1 ，计"></a>引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加 1 ，引用释放时计数减 1 ，计</h3><h3 id="数为-0-时可以回收，"><a href="#数为-0-时可以回收，" class="headerlink" title="数为 0 时可以回收，"></a>数为 0 时可以回收，</h3><figure class="highlight mathematica"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可达性分析法：从 <span class="variable">GC</span> <span class="built_in">Roots</span> 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 <span class="variable">GC</span></span><br><span class="line"><span class="built_in">Roots</span> 没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">引用计数法，可能会出现<span class="keyword">A</span> 引用了 B，B 又引用了 <span class="keyword">A</span>，这时候就算他们都不再使用了，但因为相互</span><br><span class="line">引用 计数器=<span class="number">1</span> 永远无法被回收。</span><br></pre></td></tr></tbody></table></figure>
<p>GC Roots的对象有：</p>
<figure class="highlight gcode"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">虚拟机栈<span class="comment">(栈帧中的本地变量表）中引用的对象</span></span><br><span class="line"><span class="comment">方法区中类静态属性引用的对象</span></span><br><span class="line"><span class="comment">方法区中常量引用的对象</span></span><br><span class="line"><span class="comment">本地方法栈中JNI(即一般说的Native方法)</span>引用的对象</span><br></pre></td></tr></tbody></table></figure>

<h3 id="可达性算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会。对象被系统宣告死亡至"><a href="#可达性算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会。对象被系统宣告死亡至" class="headerlink" title="可达性算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会。对象被系统宣告死亡至"></a>可达性算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会。对象被系统宣告死亡至</h3><p>少要经历两次标记过程：第一次是经过可达性分析发现没有与GC Roots相连接的引用链，第二次是在由<br>虚拟机自动建立的Finalizer队列中判断是否需要执行finalize()方法。</p>
<p>当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回<br>收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象<br>的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否<br>则，对象“复活”</p>
<p>每个对象只能触发一次finalize()方法</p>
<p>由于finalize()方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，不推荐大家使用，建议<br>遗忘它。</p>
<h1 id="线程、并发相关"><a href="#线程、并发相关" class="headerlink" title="线程、并发相关"></a>线程、并发相关</h1><h2 id="线程的生命周期？线程有几种状态"><a href="#线程的生命周期？线程有几种状态" class="headerlink" title="线程的生命周期？线程有几种状态"></a>线程的生命周期？线程有几种状态</h2><h3 id="1-线程通常有五种状态，创建，就绪，运行、阻塞和死亡状态。"><a href="#1-线程通常有五种状态，创建，就绪，运行、阻塞和死亡状态。" class="headerlink" title="1.线程通常有五种状态，创建，就绪，运行、阻塞和死亡状态。"></a>1.线程通常有五种状态，创建，就绪，运行、阻塞和死亡状态。</h3><h3 id="2-阻塞的情况又分为三种："><a href="#2-阻塞的情况又分为三种：" class="headerlink" title="2.阻塞的情况又分为三种："></a>2.阻塞的情况又分为三种：</h3><p>(1)、等待阻塞：运行的线程执行wait方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待<br>池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify或notifyAll方法才能被唤<br>醒，wait是object类的方法</p>
<p>(2)、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放<br>入“锁池”中。</p>
<p>(3)、其他阻塞：运行的线程执行sleep或join方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状<br>态。当sleep状态超时、join等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。<br>sleep是Thread类的方法</p>
<p>1.新建状态（New）：新创建了一个线程对象。</p>
<p>2.就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start方法。该状态的线程位于<br>可运行线程池中，变得可运行，等待获取CPU的使用权。</p>
<p>3.运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。</p>
<p>4.阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进<br>入就绪状态，才有机会转到运行状态。</p>
<p>5.死亡状态（Dead）：线程执行完了或者因异常退出了run方法，该线程结束生命周期。</p>
<h2 id="sleep-、wait-、join-、yield-的区别"><a href="#sleep-、wait-、join-、yield-的区别" class="headerlink" title="sleep()、wait()、join()、yield()的区别"></a>sleep()、wait()、join()、yield()的区别</h2><h3 id="1-锁池"><a href="#1-锁池" class="headerlink" title="1.锁池"></a>1.锁池</h3><h3 id="所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线"><a href="#所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线" class="headerlink" title="所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线"></a>所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线</h3><h3 id="程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到"><a href="#程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到" class="headerlink" title="程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到"></a>程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到</h3><p>后会进入就绪队列进行等待cpu资源分配。</p>
<p>2.等待池</p>
<p>当我们调用wait（）方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调用了<br>notify（）或notifyAll()后等待池的线程才会开始去竞争锁，notify（）是随机从等待池选出一个线程放<br>到锁池，而notifyAll()是将等待池的所有线程放到锁池当中</p>
<p>1 、sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。</p>
<p>2 、sleep方法不会释放lock，但是wait会释放，而且会加入到等待队列中。</p>
<p>3 、sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字。</p>
<p>4 、sleep不需要被唤醒（休眠之后推出阻塞），但是wait需要（不指定时间需要被别人中断）。</p>
<p>5 、sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。</p>
<p>6 、sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞<br>争到锁继续执行的。</p>
<p>yield（）执行后线程直接进入就绪状态，马上释放了cpu的执行权，但是依然保留了cpu的执行资格，<br>所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行</p>
<p>join（）执行后线程进入阻塞状态，例如在线程B中调用线程A的join（），那线程B会进入到阻塞队<br>列，直到线程A结束或中断线程</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sleep</span>就是把cpu的执行资格和执行权释放出去，不再运行此线程，当定时时间结束再取回cpu资源，参与cpu</span><br><span class="line">的调度，获取到cpu资源后就可以继续运行了。而如果<span class="built_in">sleep</span>时该线程有锁，那么<span class="built_in">sleep</span>不会释放这个锁，而</span><br><span class="line">是把锁带着进入了冻结状态，也就是说其他需要这个锁的线程根本不可能获取到这个锁。也就是说无法执行程</span><br><span class="line">序。如果在睡眠期间其他线程调用了这个线程的interrupt方法，那么这个线程也会抛出</span><br><span class="line">interruptexception异常返回，这点和<span class="built_in">wait</span>是一样的。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">Thread.sleep( <span class="number">3000</span> );</span><br><span class="line">} <span class="keyword">catch</span> (InterruptedException e) {</span><br></pre></td></tr></tbody></table></figure>

<h2 id="对线程安全的理解"><a href="#对线程安全的理解" class="headerlink" title="对线程安全的理解"></a>对线程安全的理解</h2><h3 id="不是线程安全、应该是内存安全，堆是共享内存，可以被所有线程访问"><a href="#不是线程安全、应该是内存安全，堆是共享内存，可以被所有线程访问" class="headerlink" title="不是线程安全、应该是内存安全，堆是共享内存，可以被所有线程访问"></a>不是线程安全、应该是内存安全，堆是共享内存，可以被所有线程访问</h3><h3 id="堆-是进程和线程共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分"><a href="#堆-是进程和线程共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分" class="headerlink" title="堆 是进程和线程共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分"></a>堆 是进程和线程共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分</h3><h3 id="配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是用完了"><a href="#配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是用完了" class="headerlink" title="配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是用完了"></a>配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是用完了</h3><h3 id="要还给操作系统，要不然就是内存泄漏。"><a href="#要还给操作系统，要不然就是内存泄漏。" class="headerlink" title="要还给操作系统，要不然就是内存泄漏。"></a>要还给操作系统，要不然就是内存泄漏。</h3><figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在<span class="keyword">Java中，堆是Java虚拟机所管理的内存中最大的一块，是所有线程共享的一块内存区域，在虚</span></span><br><span class="line"><span class="keyword"></span>拟机启动时创建。堆所存在的内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及</span><br><span class="line">数组都在这里分配内存。</span><br></pre></td></tr></tbody></table></figure>
<p><strong>栈</strong> 是每个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈<br>互相独立，因此，栈是线程安全的。操作系统在切换线程的时候会自动切换栈。栈空间不需要在高级语<br>言里面显式的分配和释放。</p>
<h3 id="目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己"><a href="#目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己" class="headerlink" title="目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己"></a>目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己</h3><h3 id="的内存空间，而不能访问别的进程的，这是由操作系统保障的。"><a href="#的内存空间，而不能访问别的进程的，这是由操作系统保障的。" class="headerlink" title="的内存空间，而不能访问别的进程的，这是由操作系统保障的。"></a>的内存空间，而不能访问别的进程的，这是由操作系统保障的。</h3><h3 id="在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以"><a href="#在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以" class="headerlink" title="在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以"></a>在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以</h3><h3 id="访问到该区域，这就是造成问题的潜在原因。"><a href="#访问到该区域，这就是造成问题的潜在原因。" class="headerlink" title="访问到该区域，这就是造成问题的潜在原因。"></a>访问到该区域，这就是造成问题的潜在原因。</h3><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">e.printStackTrace()<span class="comment">;</span></span><br><span class="line">}</span><br><span class="line">System.out.println(<span class="string">"22222222"</span>)<span class="comment">;</span></span><br><span class="line">}</span><br><span class="line">})<span class="comment">;</span></span><br><span class="line">t1.start()<span class="comment">;</span></span><br><span class="line">t1.join()<span class="comment">;</span></span><br><span class="line">// 这行代码必须要等t1全部执行完毕，才会执行</span><br><span class="line">System.out.println(<span class="string">"1111"</span>)<span class="comment">;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22222222</span></span><br><span class="line"><span class="number">1111</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当多个线程访问一个对象时，如果不用进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获</span><br><span class="line">得正确的结果，我们就说这个对象是线程安全的</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Thread、Runable的区别"><a href="#Thread、Runable的区别" class="headerlink" title="Thread、Runable的区别"></a>Thread、Runable的区别</h2><p>Thread和Runnable的实质是继承关系，没有可比性。无论使用Runnable还是Thread，都会new<br>Thread，然后执行run方法。用法上，如果有复杂的线程操作需求，那就选择继承Thread，如果只是简<br>单的执行一个任务，那就实现runnable。</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会卖出多一倍的票</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) {</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new <span class="built_in">MyThread</span>()<span class="selector-class">.start</span>();</span><br><span class="line">new <span class="built_in">MyThread</span>()<span class="selector-class">.start</span>();</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>{</span><br><span class="line"><span class="keyword">private</span> int ticket = <span class="number">5</span> ;</span><br><span class="line">public void run(){</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line"><span class="type">System</span>.out.println(<span class="string">"Thread ticket = "</span> + ticket--);</span><br><span class="line"><span class="keyword">if</span>(ticket &lt; <span class="number">0</span> ){</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常卖出</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>{</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) {</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">MyThread2 mt=<span class="keyword">new</span> <span class="type">MyThread2</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="type">Thread</span>(mt).start();</span><br><span class="line"><span class="keyword">new</span> <span class="type">Thread</span>(mt).start();</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">}</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MyThread2</span> <span class="title">implements</span> <span class="title">Runnable</span>{</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> ticket = <span class="number">5</span> ;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span>{</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"Runnable ticket = "</span> + ticket--);</span><br><span class="line"><span class="keyword">if</span>(ticket &lt; <span class="number">0</span> ){</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>原因是：MyThread创建了两个实例，自然会卖出两倍，属于用法错误</p>
<h2 id="对守护线程的理解"><a href="#对守护线程的理解" class="headerlink" title="对守护线程的理解"></a>对守护线程的理解</h2><h3 id="守护线程：为所有非守护线程提供服务的线程；任何一个守护线程都是整个JVM中所有非守护线程的保"><a href="#守护线程：为所有非守护线程提供服务的线程；任何一个守护线程都是整个JVM中所有非守护线程的保" class="headerlink" title="守护线程：为所有非守护线程提供服务的线程；任何一个守护线程都是整个JVM中所有非守护线程的保"></a>守护线程：为所有非守护线程提供服务的线程；任何一个守护线程都是整个JVM中所有非守护线程的保</h3><h3 id="姆；"><a href="#姆；" class="headerlink" title="姆；"></a>姆；</h3><h3 id="守护线程类似于整个进程的一个默默无闻的小喽喽；它的生死无关重要，它却依赖整个进程而运行；哪"><a href="#守护线程类似于整个进程的一个默默无闻的小喽喽；它的生死无关重要，它却依赖整个进程而运行；哪" class="headerlink" title="守护线程类似于整个进程的一个默默无闻的小喽喽；它的生死无关重要，它却依赖整个进程而运行；哪"></a>守护线程类似于整个进程的一个默默无闻的小喽喽；它的生死无关重要，它却依赖整个进程而运行；哪</h3><h3 id="天其他线程结束了，没有要执行的了，程序就结束了，理都没理守护线程，就把它中断了；"><a href="#天其他线程结束了，没有要执行的了，程序就结束了，理都没理守护线程，就把它中断了；" class="headerlink" title="天其他线程结束了，没有要执行的了，程序就结束了，理都没理守护线程，就把它中断了；"></a>天其他线程结束了，没有要执行的了，程序就结束了，理都没理守护线程，就把它中断了；</h3><p>注意： 由于守护线程的终止是自身无法控制的，因此千万不要把IO、File等重要操作逻辑分配给它；因<br>为它不靠谱；</p>
<p>守护线程的作用是什么？<br>举例， GC垃圾回收线程：就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就<br>不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线<br>程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。<br>应用场景：（ 1 ）来为其它线程提供服务支持的情况；（ 2 ） 或者在任何情况下，程序结束时，这个线<br>程必须正常且立刻关闭，就可以作为守护线程来使用；反之，如果一个正在执行某个操作的线程必须要<br>正确地关闭掉否则就会出现不好的后果的话，那么这个线程就不能是守护线程，而是用户线程。通常都<br>是些关键的事务，比方说，数据库录入或者更新，这些操作都是不能中断的。</p>
<p>thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个<br>IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。</p>
<p>在Daemon线程中产生的新线程也是Daemon的。</p>
<p>守护线程不能用于去访问固有资源，比如读写操作或者计算逻辑。因为它会在任何时候甚至在一个操作<br>的中间发生中断。</p>
<p>Java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以如果要使用后台线<br>程就不能用Java的线程池。</p>
<h2 id="ThreadLocal的原理和使用场景"><a href="#ThreadLocal的原理和使用场景" class="headerlink" title="ThreadLocal的原理和使用场景"></a>ThreadLocal的原理和使用场景</h2><p>每一个Thread对象均含有一个ThreadLocalMap类型的成员变量threadLocals，它存储本线程中所<br>有ThreadLocal对象及其对应的值</p>
<figure class="highlight ada"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap由一个个<span class="keyword">Entry</span>对象构成</span><br></pre></td></tr></tbody></table></figure>
<p>Entry继承自WeakReference&lt;ThreadLocal&lt;?&gt;&gt;，一个Entry由ThreadLocal对象和Object构<br>成。由此可见，Entry的key是ThreadLocal对象，并且是一个弱引用。当没指向key的强引用后，该<br>key就会被垃圾收集器回收</p>
<p>当执行set方法时，ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对<br>象。再以当前ThreadLocal对象为key，将值存储进ThreadLocalMap对象中。</p>
<p>get方法执行过程类似。ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap<br>对象。再以当前ThreadLocal对象为key，获取对应的value。</p>
<p>由于每一条线程均含有各自 <strong>私有的</strong> ThreadLocalMap容器，这些容器相互独立互不影响，因此不会存在<br>线程安全性问题，从而也无需使用同步机制来保证多条线程访问容器的互斥性。</p>
<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>1 、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</p>
<p>2 、线程间数据隔离</p>
<p>3 、进行事务操作，用于存储线程事务信息。</p>
<p>4 、数据库连接，Session会话管理。</p>
<h2 id="ThreadLocal内存泄露原因，如何避免"><a href="#ThreadLocal内存泄露原因，如何避免" class="headerlink" title="ThreadLocal内存泄露原因，如何避免"></a>ThreadLocal内存泄露原因，如何避免</h2><h3 id="内存泄露为程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露"><a href="#内存泄露为程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露" class="headerlink" title="内存泄露为程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露"></a>内存泄露为程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露</h3><h3 id="堆积后果很严重，无论多少内存-迟早会被占光，"><a href="#堆积后果很严重，无论多少内存-迟早会被占光，" class="headerlink" title="堆积后果很严重，无论多少内存,迟早会被占光，"></a>堆积后果很严重，无论多少内存,迟早会被占光，</h3><h3 id="不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。"><a href="#不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。" class="headerlink" title="不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。"></a>不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。</h3><p>强引用：使用最普遍的引用(new)，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，<br>Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</p>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spring框架在事务开始时会给当前线程绑定一个Jdbc <span class="keyword">Connection</span>,在整个事务过程都是使用该线程绑定的</span><br><span class="line"><span class="keyword">connection</span>来执行数据库操作，实现了事务的隔离性。Spring框架里面就是用的ThreadLocal来实现这种</span><br><span class="line">隔离</span><br></pre></td></tr></tbody></table></figure>

<p>如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样可以使JVM在合适的时<br>间就会回收该对象。</p>
<p>弱引用：JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用<br>java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用。</p>
<p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用 <strong>弱引用</strong> 的ThreadLocal<br>实例，value为线程变量的副本</p>
<p>hreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal不存在外部 <strong>强引用</strong> 时，<br>Key(ThreadLocal)势必会被GC回收，这样就会导致ThreadLocalMap中key为null， 而value还存在着强<br>引用，只有thead线程退出以后,value的强引用链条才会断掉，但如果当前线程再迟迟不结束的话，这<br>些key为null的Entry的value就会一直存在一条强引用链（红色链条）</p>
<p>key 使用强引用</p>
<p>当hreadLocalMap的key为强引用回收ThreadLocal时，因为ThreadLocalMap还持有ThreadLocal的强<br>引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</p>
<p>key 使用弱引用</p>
<p>当ThreadLocalMap的key为弱引用回收ThreadLocal时，由于ThreadLocalMap持有ThreadLocal的弱<br>引用，即使没有手动删除，ThreadLocal也会被回收。当key为null，在下一次ThreadLocalMap调用<br>set(),get()，remove()方法的时候会被清除value值。</p>
<p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有<br>手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p>
<p>ThreadLocal正确的使用方法</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每次使用完ThreadLocal都调用它的<span class="keyword">remove</span>()方法清除数据</span><br><span class="line">将ThreadLocal变量定义成<span class="keyword">private</span> <span class="keyword">static</span>，这样就一直存在ThreadLocal的强引用，也就能保证任</span><br><span class="line">何时候都能通过ThreadLocal的弱引用访问到Entry的<span class="keyword">value</span>值，进而清除掉 。</span><br></pre></td></tr></tbody></table></figure>

<h2 id="并发、并行、串行的区别"><a href="#并发、并行、串行的区别" class="headerlink" title="并发、并行、串行的区别"></a>并发、并行、串行的区别</h2><h3 id="串行在时间上不可能发生重叠，前一个任务没搞定，下一个任务就只能等着"><a href="#串行在时间上不可能发生重叠，前一个任务没搞定，下一个任务就只能等着" class="headerlink" title="串行在时间上不可能发生重叠，前一个任务没搞定，下一个任务就只能等着"></a>串行在时间上不可能发生重叠，前一个任务没搞定，下一个任务就只能等着</h3><h3 id="并行在时间上是重叠的，两个任务在-同一时刻互不干扰-的同时执行。"><a href="#并行在时间上是重叠的，两个任务在-同一时刻互不干扰-的同时执行。" class="headerlink" title="并行在时间上是重叠的，两个任务在 同一时刻互不干扰 的同时执行。"></a>并行在时间上是重叠的，两个任务在 同一时刻互不干扰 的同时执行。</h3><h3 id="并发允许两个任务彼此干扰。统一时间点、只有一个任务运行，交替执行"><a href="#并发允许两个任务彼此干扰。统一时间点、只有一个任务运行，交替执行" class="headerlink" title="并发允许两个任务彼此干扰。统一时间点、只有一个任务运行，交替执行"></a>并发允许两个任务彼此干扰。统一时间点、只有一个任务运行，交替执行</h3><h2 id="并发的三大特性"><a href="#并发的三大特性" class="headerlink" title="并发的三大特性"></a>并发的三大特性</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性是指在一个操作中cpu不可以在中途暂停然后再调度，即不被中断操作，要不全部执行完成，要<br>不都不执行。就好比转账，从账户A向账户B转 1000 元，那么必然包括 2 个操作：从账户A减去 1000 元，<br>往账户B加上 1000 元。 2 个操作必须全部完成。</p>
<figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>：将 count 从主存读到工作内存中的副本中</span><br><span class="line"><span class="symbol">2 </span>：+<span class="number">1</span>的运算</span><br><span class="line"><span class="symbol">3 </span>：将结果写入工作内存</span><br><span class="line"><span class="symbol">4 </span>：将工作内存的值刷回主存(什么时候刷入由操作系统决定，不确定的)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="那程序中原子性指的是最小的操作单元，比如自增操作，它本身其实并不是原子性操作，分了-3-步的，"><a href="#那程序中原子性指的是最小的操作单元，比如自增操作，它本身其实并不是原子性操作，分了-3-步的，" class="headerlink" title="那程序中原子性指的是最小的操作单元，比如自增操作，它本身其实并不是原子性操作，分了 3 步的，"></a>那程序中原子性指的是最小的操作单元，比如自增操作，它本身其实并不是原子性操作，分了 3 步的，</h3><h3 id="包括读取变量的原始值、进行加-1-操作、写入工作内存。所以在多线程中，有可能一个线程还没自增"><a href="#包括读取变量的原始值、进行加-1-操作、写入工作内存。所以在多线程中，有可能一个线程还没自增" class="headerlink" title="包括读取变量的原始值、进行加 1 操作、写入工作内存。所以在多线程中，有可能一个线程还没自增"></a>包括读取变量的原始值、进行加 1 操作、写入工作内存。所以在多线程中，有可能一个线程还没自增</h3><h3 id="完，可能才执行到第二部，另一个线程就已经读取了值，导致结果错误。那如果我们能保证自增操作是"><a href="#完，可能才执行到第二部，另一个线程就已经读取了值，导致结果错误。那如果我们能保证自增操作是" class="headerlink" title="完，可能才执行到第二部，另一个线程就已经读取了值，导致结果错误。那如果我们能保证自增操作是"></a>完，可能才执行到第二部，另一个线程就已经读取了值，导致结果错误。那如果我们能保证自增操作是</h3><h3 id="一个原子性的操作，那么就能保证其他线程读取到的一定是自增后的数据。"><a href="#一个原子性的操作，那么就能保证其他线程读取到的一定是自增后的数据。" class="headerlink" title="一个原子性的操作，那么就能保证其他线程读取到的一定是自增后的数据。"></a>一个原子性的操作，那么就能保证其他线程读取到的一定是自增后的数据。</h3><p><strong>关键字：</strong> synchronized</p>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可见性</span><br></pre></td></tr></tbody></table></figure>
<p>当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>若两个线程在不同的cpu，那么线程 1 改变了i的值还没刷新到主存，线程 2 又使用了i，那么这个i值肯定<br>还是之前的，线程 1 对变量的修改线程没看到这就是可见性问题。</p>
<figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">long</span> <span class="keyword">count</span> = <span class="number">0</span> ;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calc</span>()</span> {</span><br><span class="line">count++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果线程 2 改变了stop的值，线程 1 一定会停止吗？不一定。当线程 2 更改了stop变量的值之后，但是还<br>没来得及写入主存当中，线程 2 转去做其他事情了，那么线程 1 由于不知道线程 2 对stop变量的更改，因<br>此还会一直循环下去。</p>
<p><strong>关键字：</strong> volatile、synchronized、final</p>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有序性</span><br></pre></td></tr></tbody></table></figure>
<p>虚拟机在进行代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，虚拟机不一定会按<br>照我们写的代码的顺序来执行，有可能将他们重排序。实际上，对于有些代码进行重排序之后，虽然对<br>变量的值没有造成影响，但有可能会出现线程安全问题。</p>
<p>write方法里的 1 和 2 做了重排序，线程 1 先对flag赋值为true，随后执行到线程 2 ，ret直接计算出结果，<br>再到线程 1 ，这时候a才赋值为2,很明显迟了一步</p>
<p><strong>关键字：</strong> volatile、synchronized</p>
<p>volatile本身就包含了禁止指令重排序的语义，而synchronized关键字是由“一个变量在同一时刻只允许<br>一条线程对其进行lock操作”这条规则明确的。</p>
<p>synchronized关键字同时满足以上三种特性，但是volatile关键字不满足原子性。</p>
<p>在某些情况下，volatile的同步机制的性能确实要优于锁(使用synchronized关键字或<br>java.util.concurrent包里面的锁)，因为volatile的总开销要比锁低。</p>
<p>我们判断使用volatile还是加锁的唯一依据就是volatile的语义能否满足使用的场景(原子性)</p>
<figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程 1</span></span><br><span class="line"><span class="type">boolean</span> stop = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!stop){</span><br><span class="line"><span class="built_in">doSomething</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//线程 <span class="number">2</span></span><br><span class="line"><span class="attribute">stop</span> <span class="operator">=</span> true<span class="comment">;</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a <span class="operator">=</span> <span class="number">0</span> <span class="comment">;</span></span><br><span class="line">bool flag <span class="operator">=</span> false<span class="comment">;</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span>()</span> {</span><br><span class="line">a = <span class="number">2</span> ; &nbsp;<span class="comment">//</span></span><br><span class="line">flag = <span class="literal">true</span>; &nbsp;<span class="comment">//</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiply</span>()</span> {</span><br><span class="line"><span class="keyword">if</span> (flag) { <span class="comment">//</span></span><br><span class="line"><span class="built_in">int</span> ret = a * a;<span class="comment">//</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 保证被<span class="keyword">volatile</span>修饰的共享变量对所有线程总是可见的，也就是当一个线程修改了一个被<span class="keyword">volatile</span>修</span><br><span class="line">饰共享变量的值，新值总是可以被其他线程立即得知。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果线程<span class="number"> 2 </span>改变了stop的值，线程<span class="number"> 1 </span>一定会停止吗？不一定。当线程<span class="number"> 2 </span>更改了stop变量的值之后，但</span><br><span class="line">是还没来得及写入主存当中，线程<span class="number"> 2 </span>转去做其他事情了，那么线程<span class="number"> 1 </span>由于不知道线程<span class="number"> 2 </span>对stop变量的</span><br><span class="line">更改，因此还会一直循环下去。</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-禁止指令重排序优化。"><a href="#2-禁止指令重排序优化。" class="headerlink" title="2. 禁止指令重排序优化。"></a>2. 禁止指令重排序优化。</h3><p>write方法里的 1 和 2 做了重排序，线程 1 先对flag赋值为true，随后执行到线程 2 ，ret直接计算出结果，<br>再到线程 1 ，这时候a才赋值为2,很明显迟了一步。</p>
<p>但是用volatile修饰之后就变得不一样了</p>
<p>第一：使用volatile关键字会强制将修改的值立即写入主存；</p>
<p>第二：使用volatile关键字的话，当线程 2 进行修改时，会导致线程 1 的工作内存中缓存变量stop的缓存<br>行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>
<p>第三：由于线程 1 的工作内存中缓存变量stop的缓存行无效，所以线程 1 再次读取变量stop的值时会去主<br>存读取。</p>
<figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc++; 其实是两个步骤，先加加，然后再赋值。不是原子性操作，所以<span class="keyword">volatile</span>不能保证线程安全。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程 1</span></span><br><span class="line"><span class="type">boolean</span> stop = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!stop){</span><br><span class="line"><span class="built_in">doSomething</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//线程 <span class="number">2</span></span><br><span class="line"><span class="attribute">stop</span> <span class="operator">=</span> true<span class="comment">;</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a <span class="operator">=</span> <span class="number">0</span> <span class="comment">;</span></span><br><span class="line">bool flag <span class="operator">=</span> false<span class="comment">;</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span>()</span> {</span><br><span class="line">a = <span class="number">2</span> ; &nbsp;<span class="comment">//1</span></span><br><span class="line">flag = <span class="literal">true</span>; &nbsp;<span class="comment">//2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiply</span>()</span> {</span><br><span class="line"><span class="keyword">if</span> (flag) { <span class="comment">//3</span></span><br><span class="line"><span class="built_in">int</span> ret = a * a;<span class="comment">//4</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="为什么用线程池？解释下线程池参数？"><a href="#为什么用线程池？解释下线程池参数？" class="headerlink" title="为什么用线程池？解释下线程池参数？"></a>为什么用线程池？解释下线程池参数？</h2><h3 id="1-、降低资源消耗；提高线程利用率，降低创建和销毁线程的消耗。"><a href="#1-、降低资源消耗；提高线程利用率，降低创建和销毁线程的消耗。" class="headerlink" title="1 、降低资源消耗；提高线程利用率，降低创建和销毁线程的消耗。"></a>1 、降低资源消耗；提高线程利用率，降低创建和销毁线程的消耗。</h3><h3 id="2-、提高响应速度；任务来了，直接有线程可用可执行，而不是先创建线程，再执行。"><a href="#2-、提高响应速度；任务来了，直接有线程可用可执行，而不是先创建线程，再执行。" class="headerlink" title="2 、提高响应速度；任务来了，直接有线程可用可执行，而不是先创建线程，再执行。"></a>2 、提高响应速度；任务来了，直接有线程可用可执行，而不是先创建线程，再执行。</h3><h3 id="3-、提高线程的可管理性；线程是稀缺资源，使用线程池可以统一分配调优监控。"><a href="#3-、提高线程的可管理性；线程是稀缺资源，使用线程池可以统一分配调优监控。" class="headerlink" title="3 、提高线程的可管理性；线程是稀缺资源，使用线程池可以统一分配调优监控。"></a>3 、提高线程的可管理性；线程是稀缺资源，使用线程池可以统一分配调优监控。</h3><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">corePoolSize</span> 代表核心线程数，也就是正常情况下创建工作的线程数，这些线程创建后并不会</span><br><span class="line">消除，而是一种常驻线程</span><br><span class="line">maxinumPoolSize 代表的是最大线程数，它与核心线程数相对应，表示最大允许被创建的线程</span><br><span class="line">数，比如当前任务较多，将核心线程数都用完了，还无法满足需求时，此时就会创建新的线程，但</span><br><span class="line">是线程池内线程总数不会超过最大线程数</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight jboss-cli"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">keepAliveTime、unit 表示超出核心线程数之外的线程的空闲存活时间，也就是核心线程不会</span><br><span class="line">消除，但是超出核心线程数的部分线程如果空闲一定的时间则会被消除,我们可以通过</span><br><span class="line"><span class="keyword">set</span>KeepAliveTime 来设置空闲时间</span><br><span class="line">workQueue 用来存放待执行的任务，假设我们现在核心线程都已被使用，还有任务进来则全部放</span><br><span class="line">入队列，直到整个队列被放满但任务还再持续进入则会开始创建新的线程</span><br><span class="line">ThreadFactory 实际上是一个线程工厂，用来生产线程执行任务。我们可以选择使用默认的创建</span><br><span class="line">工厂，产生的线程都在同一个组内，拥有相同的优先级，且都不是守护线程。当然我们也可以选择</span><br><span class="line">自定义线程工厂，一般我们会根据业务来制定不同的线程工厂</span><br><span class="line">Handler 任务拒绝策略，有两种情况，第一种是当我们调用<span class="keyword">shutdown</span> 等方法关闭线程池后，这</span><br><span class="line">时候即使线程池内部还有没执行完的任务正在执行，但是由于线程池已经关闭，我们再继续想线程</span><br><span class="line">池提交任务就会遭到拒绝。另一种情况就是当达到最大线程数，线程池已经没有能力继续处理新提</span><br><span class="line">交的任务时，这是也就拒绝</span><br></pre></td></tr></tbody></table></figure>
<h2 id="简述线程池处理流程"><a href="#简述线程池处理流程" class="headerlink" title="简述线程池处理流程"></a>简述线程池处理流程</h2><h2 id="线程池中阻塞队列的作用？为什么是先添加列队而不是先"><a href="#线程池中阻塞队列的作用？为什么是先添加列队而不是先" class="headerlink" title="线程池中阻塞队列的作用？为什么是先添加列队而不是先"></a>线程池中阻塞队列的作用？为什么是先添加列队而不是先</h2><h2 id="创建最大线程？"><a href="#创建最大线程？" class="headerlink" title="创建最大线程？"></a>创建最大线程？</h2><h3 id="1-、一般的队列只能保证作为一个有限长度的缓冲区，如果超出了缓冲长度，就无法保留当前的任务"><a href="#1-、一般的队列只能保证作为一个有限长度的缓冲区，如果超出了缓冲长度，就无法保留当前的任务" class="headerlink" title="1 、一般的队列只能保证作为一个有限长度的缓冲区，如果超出了缓冲长度，就无法保留当前的任务"></a>1 、一般的队列只能保证作为一个有限长度的缓冲区，如果超出了缓冲长度，就无法保留当前的任务</h3><h3 id="了，阻塞队列通过阻塞可以保留住当前想要继续入队的任务。"><a href="#了，阻塞队列通过阻塞可以保留住当前想要继续入队的任务。" class="headerlink" title="了，阻塞队列通过阻塞可以保留住当前想要继续入队的任务。"></a>了，阻塞队列通过阻塞可以保留住当前想要继续入队的任务。</h3><p>阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资<br>源。</p>
<p>阻塞队列自带阻塞和唤醒的功能，不需要额外处理，无任务执行时,线程池利用阻塞队列的take方法挂<br>起，从而维持核心线程的存活、不至于一直占用cpu资源</p>
<h3 id="2-、在创建新线程的时候，是要获取全局锁的，这个时候其它的就得阻塞，影响了整体效率。"><a href="#2-、在创建新线程的时候，是要获取全局锁的，这个时候其它的就得阻塞，影响了整体效率。" class="headerlink" title="2 、在创建新线程的时候，是要获取全局锁的，这个时候其它的就得阻塞，影响了整体效率。"></a>2 、在创建新线程的时候，是要获取全局锁的，这个时候其它的就得阻塞，影响了整体效率。</h3><p>就好比一个企业里面有 10 个（core）正式工的名额，最多招 10 个正式工，要是任务超过正式工人数<br>（task &gt; core）的情况下，工厂领导（线程池）不是首先扩招工人，还是这 10 人，但是任务可以稍微积<br>压一下，即先放到队列去（代价低）。 10 个正式工慢慢干，迟早会干完的，要是任务还在继续增加，超<br>过正式工的加班忍耐极限了（队列满了），就的招外包帮忙了（注意是临时工）要是正式工加上外包还<br>是不能完成任务，那新来的任务就会被领导拒绝了（线程池的拒绝策略）。</p>
<h2 id="线程池中线程复用原理"><a href="#线程池中线程复用原理" class="headerlink" title="线程池中线程复用原理"></a>线程池中线程复用原理</h2><p>线程池将线程和任务进行解耦，线程是线程，任务是任务，摆脱了之前通过 Thread 创建线程时的<br>一个线程必须对应一个任务的限制。</p>
<p>在线程池中，同一个线程可以从阻塞队列中不断获取新任务来执行，其核心原理在于线程池对<br>Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去<br>执行一个“循环任务”，在这个“循环任务”中不停检查是否有任务需要被执行，如果有则直接执行，也就<br>是调用任务中的 run 方法，将 run 方法当成一个普通的方法执行，通过这种方式只使用固定的线程就<br>将所有任务的 run 方法串联起来。</p>
<h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><h2 id="如何实现一个IOC容器"><a href="#如何实现一个IOC容器" class="headerlink" title="如何实现一个IOC容器"></a>如何实现一个IOC容器</h2><h3 id="1-、配置文件配置包扫描路径"><a href="#1-、配置文件配置包扫描路径" class="headerlink" title="1 、配置文件配置包扫描路径"></a>1 、配置文件配置包扫描路径</h3><p>2 、递归包扫描获取.class文件</p>
<p>3 、反射、确定需要交给IOC管理的类</p>
<p>4 、对需要注入的类进行依赖注入</p>
<h3 id="配置文件中指定需要扫描的包路径"><a href="#配置文件中指定需要扫描的包路径" class="headerlink" title="配置文件中指定需要扫描的包路径"></a>配置文件中指定需要扫描的包路径</h3><h3 id="定义一些注解，分别表示访问控制层、业务服务层、数据持久层、依赖注入注解、获取配置文件注"><a href="#定义一些注解，分别表示访问控制层、业务服务层、数据持久层、依赖注入注解、获取配置文件注" class="headerlink" title="定义一些注解，分别表示访问控制层、业务服务层、数据持久层、依赖注入注解、获取配置文件注"></a>定义一些注解，分别表示访问控制层、业务服务层、数据持久层、依赖注入注解、获取配置文件注</h3><h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><h3 id="从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息及文件夹信息，我们将当前路"><a href="#从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息及文件夹信息，我们将当前路" class="headerlink" title="从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息及文件夹信息，我们将当前路"></a>从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息及文件夹信息，我们将当前路</h3><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">径下所有以.<span class="keyword">class</span>结尾的文件添加到一个<span class="built_in">Set</span>集合中进行存储</span><br><span class="line">遍历这个<span class="keyword">set</span>集合，获取在类上有指定注解的类，并将其交给IOC容器，定义一个安全的<span class="built_in">Map</span>用来</span><br><span class="line">存储这些对象</span><br><span class="line">遍历这个IOC容器，获取到每一个类的实例，判断里面是有有依赖其他的类的实例，然后进行递归</span><br><span class="line">注入</span><br></pre></td></tr></tbody></table></figure>

<h2 id="spring是什么？"><a href="#spring是什么？" class="headerlink" title="spring是什么？"></a>spring是什么？</h2><p>轻量级的开源的J2EE框架。它是一个容器框架，用来装javabean（java对象），中间层框架（万能胶）<br>可以起一个连接作用，比如说把Struts和hibernate粘合在一起运用，可以让我们的企业开发更快、更简<br>洁</p>
<p>Spring是一个轻量级的控制反转（IoC)和面向切面（AOP）的容器框架</p>
<p>–从大小与开销两方面而言Spring都是轻量级的。</p>
<p>–通过控制反转(IoC)的技术达到松耦合的目的</p>
<p>–提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的<br>开发</p>
<p>–包含并管理应用对象(Bean)的配置和生命周期，这个意义上是一个容器。</p>
<p>–将简单的组件配置、组合成为复杂的应用，这个意义上是一个框架。</p>
<h2 id="谈谈你对AOP的理解"><a href="#谈谈你对AOP的理解" class="headerlink" title="谈谈你对AOP的理解"></a>谈谈你对AOP的理解</h2><h3 id="系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这"><a href="#系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这" class="headerlink" title="系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这"></a>系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这</h3><h3 id="些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心"><a href="#些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心" class="headerlink" title="些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心"></a>些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心</h3><h3 id="业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。"><a href="#业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。" class="headerlink" title="业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。"></a>业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。</h3><h3 id="当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从"><a href="#当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从" class="headerlink" title="当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从"></a>当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从</h3><h3 id="上到下的关系，但并不适合定义从左到右的关系。例如日志功能。"><a href="#上到下的关系，但并不适合定义从左到右的关系。例如日志功能。" class="headerlink" title="上到下的关系，但并不适合定义从左到右的关系。例如日志功能。"></a>上到下的关系，但并不适合定义从左到右的关系。例如日志功能。</h3><h3 id="日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。"><a href="#日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。" class="headerlink" title="日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。"></a>日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。</h3><h3 id="在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。"><a href="#在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。" class="headerlink" title="在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。"></a>在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</h3><h3 id="AOP：将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象"><a href="#AOP：将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象" class="headerlink" title="AOP：将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象"></a>AOP：将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象</h3><h3 id="（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增"><a href="#（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增" class="headerlink" title="（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增"></a>（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增</h3><h3 id="强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情"><a href="#强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情" class="headerlink" title="强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情"></a>强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情</h3><h2 id="谈谈你对IOC的理解"><a href="#谈谈你对IOC的理解" class="headerlink" title="谈谈你对IOC的理解"></a>谈谈你对IOC的理解</h2><h3 id="容器概念、控制反转、依赖注入"><a href="#容器概念、控制反转、依赖注入" class="headerlink" title="容器概念、控制反转、依赖注入"></a>容器概念、控制反转、依赖注入</h3><p>ioc容器：实际上就是个map（key，value），里面存的是各种对象（在xml里配置的bean节点、<br>@repository、@service、@controller、@component），在项目启动的时候会读取配置文件里面的<br>bean节点，根据全限定类名使用反射创建对象放到map里、扫描到打上上述注解的类还是通过反射创<br>建对象放到map里。</p>
<p>这个时候map里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过DI注入<br>（autowired、resource等注解，xml里bean节点内的ref属性，项目启动的时候会读取xml节点ref属性<br>根据id注入，也会扫描这些注解，根据类型或id注入；id就是对象名）。</p>
<h3 id="控制反转："><a href="#控制反转：" class="headerlink" title="控制反转："></a>控制反转：</h3><h3 id="没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须"><a href="#没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须" class="headerlink" title="没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须"></a>没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须</h3><h3 id="主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。"><a href="#主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。" class="headerlink" title="主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。"></a>主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</h3><h3 id="引入IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运行到需要对象B的时候，IOC容器会"><a href="#引入IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运行到需要对象B的时候，IOC容器会" class="headerlink" title="引入IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运行到需要对象B的时候，IOC容器会"></a>引入IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运行到需要对象B的时候，IOC容器会</h3><h3 id="主动创建一个对象B注入到对象A需要的地方。"><a href="#主动创建一个对象B注入到对象A需要的地方。" class="headerlink" title="主动创建一个对象B注入到对象A需要的地方。"></a>主动创建一个对象B注入到对象A需要的地方。</h3><h3 id="通过前后的对比，不难看出来：对象A获得依赖对象B的过程-由主动行为变为了被动行为，控制权颠倒"><a href="#通过前后的对比，不难看出来：对象A获得依赖对象B的过程-由主动行为变为了被动行为，控制权颠倒" class="headerlink" title="通过前后的对比，不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒"></a>通过前后的对比，不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒</h3><h3 id="过来了，这就是“控制反转”这个名称的由来。"><a href="#过来了，这就是“控制反转”这个名称的由来。" class="headerlink" title="过来了，这就是“控制反转”这个名称的由来。"></a>过来了，这就是“控制反转”这个名称的由来。</h3><h3 id="全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一"><a href="#全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一" class="headerlink" title="全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一"></a>全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一</h3><h3 id="种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对"><a href="#种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对" class="headerlink" title="种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对"></a>种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对</h3><h3 id="象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。"><a href="#象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。" class="headerlink" title="象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。"></a>象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</h3><h3 id="依赖注入："><a href="#依赖注入：" class="headerlink" title="依赖注入："></a>依赖注入：</h3><h3 id="“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器"><a href="#“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器" class="headerlink" title="“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器"></a>“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器</h3><h3 id="主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对"><a href="#主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对" class="headerlink" title="主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对"></a>主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对</h3><h3 id="象之中。"><a href="#象之中。" class="headerlink" title="象之中。"></a>象之中。</h3><h2 id="BeanFactory和ApplicationContext有什么区别？"><a href="#BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="BeanFactory和ApplicationContext有什么区别？"></a>BeanFactory和ApplicationContext有什么区别？</h2><p>ApplicationContext是BeanFactory的子接口</p>
<p>ApplicationContext提供了更完整的功能：</p>
<p>①继承MessageSource，因此支持国际化。</p>
<p>②统一的资源文件访问方式。</p>
<p>③提供在监听器中注册bean的事件。</p>
<p>④同时加载多个配置文件。</p>
<p>⑤载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p>
<figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用</span></span><br><span class="line"><span class="keyword"></span>getBean())，才对该<span class="keyword">Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问</span></span><br><span class="line"><span class="keyword"></span>题。如果<span class="keyword">Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法</span></span><br><span class="line"><span class="keyword"></span>才会抛出异常。</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext，它是在容器启动时，一次性创建了所有的<span class="keyword">Bean。这样，在容器启动时，我</span></span><br><span class="line"><span class="keyword"></span>们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。</span><br><span class="line">ApplicationContext启动后预载入所有的单实例<span class="keyword">Bean，通过预载入单实例bean </span>,确保当你需要的</span><br><span class="line">时候，你就不用等待，因为它们已经创建好了。</span><br><span class="line">相对于基本的<span class="keyword">BeanFactory，ApplicationContext </span>唯一的不足是占用内存空间。当应用程序配置</span><br><span class="line"><span class="keyword">Bean较多时，程序启动较慢。</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用</span></span><br><span class="line"><span class="keyword"></span>ContextLoader。</span><br><span class="line"><span class="keyword">BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的</span></span><br><span class="line"><span class="keyword"></span>使用，但两者之间的区别是：<span class="keyword">BeanFactory需要手动注册，而ApplicationContext则是自动注册。</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="描述一下Spring-Bean的生命周期？"><a href="#描述一下Spring-Bean的生命周期？" class="headerlink" title="描述一下Spring Bean的生命周期？"></a>描述一下Spring Bean的生命周期？</h2><p>1 、解析类得到BeanDefinition</p>
<p>2 、如果有多个构造方法，则要推断构造方法</p>
<p>3 、确定好构造方法后，进行实例化得到一个对象</p>
<p>4 、对对象中的加了@Autowired注解的属性进行属性填充</p>
<p>5 、回调Aware方法，比如BeanNameAware，BeanFactoryAware</p>
<p>6 、调用BeanPostProcessor的初始化前的方法</p>
<p>7 、调用初始化方法</p>
<p>8 、调用BeanPostProcessor的初始化后的方法，在这里会进行AOP</p>
<p>9 、如果当前创建的bean是单例的则会把bean放入单例池</p>
<p>10 、使用bean</p>
<p>11 、Spring容器关闭时调用DisposableBean中destory()方法</p>
<h2 id="解释下Spring支持的几种bean的作用域。"><a href="#解释下Spring支持的几种bean的作用域。" class="headerlink" title="解释下Spring支持的几种bean的作用域。"></a>解释下Spring支持的几种bean的作用域。</h2><figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">singleton：默认，每个容器中只有一个<span class="keyword">bean的实例，单例的模式由BeanFactory自身来维护。该</span></span><br><span class="line"><span class="keyword"></span>对象的生命周期是与Spring IOC容器一致的（但在第一次被注入时才会创建）。</span><br><span class="line">prototype：为每一个<span class="keyword">bean请求提供一个实例。在每次注入时都会创建一个新的对象</span></span><br><span class="line"><span class="keyword"></span>request：<span class="keyword">bean被定义为在每个HTTP请求中创建一个单例对象，也就是说在单个请求中都会复用</span></span><br><span class="line"><span class="keyword"></span>这一个单例对象。</span><br><span class="line">session：与request范围类似，确保每个session中有一个<span class="keyword">bean的实例，在session过期后，bean</span></span><br><span class="line"><span class="keyword"></span>会随之失效。</span><br><span class="line">application：<span class="keyword">bean被定义为在ServletContext的生命周期中复用一个单例对象。</span></span><br><span class="line"><span class="keyword"></span>websocket：<span class="keyword">bean被定义为在websocket的生命周期中复用一个单例对象。</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span>-<span class="keyword">session</span>：全局作用域，<span class="keyword">global</span>-<span class="keyword">session</span>和Portlet应用相关。当你的应用部署在Portlet容器</span><br><span class="line">中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么</span><br><span class="line">这全局变量需要存储在<span class="keyword">global</span>-<span class="keyword">session</span>中。全局作用域与Servlet中的<span class="keyword">session</span>作用域效果相同。</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Spring框架中的单例Bean是线程安全的么？"><a href="#Spring框架中的单例Bean是线程安全的么？" class="headerlink" title="Spring框架中的单例Bean是线程安全的么？"></a>Spring框架中的单例Bean是线程安全的么？</h2><p>Spring中的Bean默认是单例模式的，框架并没有对bean进行多线程的封装处理。</p>
<p>如果Bean是有状态的 那就需要开发人员自己来进行线程安全的保证，最简单的办法就是改变bean的作<br>用域 把 “singleton”改为’‘protopyte’ 这样每次请求Bean就相当于是 new Bean() 这样就可以保证线程的<br>安全了。</p>
<figure class="highlight thrift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">有状态就是有数据存储功能</span><br><span class="line">无状态就是不会保存数据 controller、<span class="class"><span class="keyword">service</span>和<span class="title">dao</span>层本身并不是线程安全的，只是如果只</span></span><br><span class="line"><span class="class">是调用里面的方法，而且多线程调用一个实例的方法，会在内存中复制变量，这是自己的线程的工</span></span><br><span class="line"><span class="class">作内存，是安全的。</span></span><br></pre></td></tr></tbody></table></figure>
<p>Dao会操作数据库Connection，Connection是带有状态的，比如说数据库事务，Spring的事务管理器<br>使用Threadlocal为不同线程维护了一套独立的connection副本，保证线程之间不会互相影响（Spring<br>是如何保证事务获取同一个Connection的）</p>
<p>不要在bean中声明任何有状态的实例变量或类变量，如果必须如此，那么就使用ThreadLocal把变量变<br>为线程私有的，如果bean的实例变量或类变量需要在多个线程之间共享，那么就只能使用<br>synchronized、lock、CAS等这些实现线程同步的方法了。</p>
<h2 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h2><h3 id="简单工厂：由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。"><a href="#简单工厂：由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。" class="headerlink" title="简单工厂：由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。"></a>简单工厂：由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。</h3><h3 id="工厂方法："><a href="#工厂方法：" class="headerlink" title="工厂方法："></a>工厂方法：</h3><h3 id="单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点"><a href="#单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点" class="headerlink" title="单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点"></a>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点</h3><figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spring中的<span class="keyword">BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是</span></span><br><span class="line"><span class="keyword"></span>在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用<span class="built_in">getBean</span>()调</span><br><span class="line">用获得该bean时，会自动调用该bean的<span class="built_in">getObject</span>()方法，所以返回的不是factory这个bean，而是这个</span><br><span class="line">bean<span class="selector-class">.getOjbect</span>()方法的返回值。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="适配器模式："><a href="#适配器模式：" class="headerlink" title="适配器模式："></a>适配器模式：</h3><p>装饰器模式：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类<br>更为灵活。</p>
<h3 id="动态代理："><a href="#动态代理：" class="headerlink" title="动态代理："></a>动态代理：</h3><h3 id="观察者模式："><a href="#观察者模式：" class="headerlink" title="观察者模式："></a>观察者模式：</h3><h3 id="策略模式："><a href="#策略模式：" class="headerlink" title="策略模式："></a>策略模式：</h3><h3 id="模板方法：父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现。"><a href="#模板方法：父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现。" class="headerlink" title="模板方法：父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现。"></a>模板方法：父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现。</h3><h3 id="最大的好处：代码复用，减少重复代码。除了子类要实现的特定方法，其他方法及方法调用顺序都在父"><a href="#最大的好处：代码复用，减少重复代码。除了子类要实现的特定方法，其他方法及方法调用顺序都在父" class="headerlink" title="最大的好处：代码复用，减少重复代码。除了子类要实现的特定方法，其他方法及方法调用顺序都在父"></a>最大的好处：代码复用，减少重复代码。除了子类要实现的特定方法，其他方法及方法调用顺序都在父</h3><h3 id="类中预先写好了。"><a href="#类中预先写好了。" class="headerlink" title="类中预先写好了。"></a>类中预先写好了。</h3><figure class="highlight mel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">spring</span>对单例的实现： <span class="keyword">spring</span>中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没</span><br><span class="line">有从构造器级别去控制单例，这是因为<span class="keyword">spring</span>管理的是任意的java对象。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类，让适配器代替</span><br><span class="line">controller执行相应的方法。这样在扩展Controller时，只需要增加一个适配器类就完成了SpringMVC</span><br><span class="line">的扩展了。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有<span class="keyword">Wrapper</span>，另一种是类名中含有</span><br><span class="line">Decorator。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">切面在应用运行的时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象创建动态的创建一个代理</span><br><span class="line">对象。SpringAOP就是以这种方式织入切面的。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">织入：把切面应用到目标对象并创建新的代理对象的过程。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight mel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">spring</span>的事件驱动模型使用的是 观察者模式 ，Spring中Observer模式常用的地方是listener的实现。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，Spring 框架本身大量使用了<span class="built_in"></span></span><br><span class="line"><span class="built_in">Resource </span>接口来访问底层资源。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ref</span>resh方法</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Spring事务的实现方式和原理以及隔离级别？"><a href="#Spring事务的实现方式和原理以及隔离级别？" class="headerlink" title="Spring事务的实现方式和原理以及隔离级别？"></a>Spring事务的实现方式和原理以及隔离级别？</h2><p>在使用Spring框架时，可以有两种使用事务的方式，一种是编程式的，一种是申明式的，<br>@Transactional注解就是申明式的。</p>
<p>首先，事务这个概念是数据库层面的，Spring只是基于数据库中的事务进行了扩展，以及提供了一些能<br>让程序员更加方便操作事务的方式。</p>
<p>比如我们可以通过在某个方法上增加@Transactional注解，就可以开启事务，这个方法中所有的sql都<br>会在一个事务中执行，统一成功或失败。</p>
<p>在一个方法上加了@Transactional注解后，Spring会基于这个类生成一个代理对象，会将这个代理对象<br>作为bean，当在使用这个代理对象的方法时，如果这个方法上存在@Transactional注解，那么代理逻<br>辑会先把事务的自动提交设置为false，然后再去执行原本的业务逻辑方法，如果执行业务逻辑方法没有<br>出现异常，那么代理逻辑中就会将事务进行提交，如果执行业务逻辑方法出现了异常，那么则会将事务<br>进行回滚。</p>
<p>当然，针对哪些异常回滚事务是可以配置的，可以利用@Transactional注解中的rollbackFor属性进行<br>配置，默认情况下会对RuntimeException和Error进行回滚。</p>
<p>spring事务隔离级别就是数据库的隔离级别：外加一个默认级别</p>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">read</span> <span class="keyword">uncommitted</span>（未提交读）</span><br><span class="line"><span class="keyword">read</span> <span class="keyword">committed</span>（提交读、不可重复读）</span><br><span class="line"><span class="keyword">repeatable</span> <span class="keyword">read</span>（可重复读）</span><br><span class="line"><span class="keyword">serializable</span>（可串行化）</span><br></pre></td></tr></tbody></table></figure>
<h2 id="spring事务传播机制"><a href="#spring事务传播机制" class="headerlink" title="spring事务传播机制"></a>spring事务传播机制</h2><h3 id="多个事务方法相互调用时-事务如何在这些方法间传播"><a href="#多个事务方法相互调用时-事务如何在这些方法间传播" class="headerlink" title="多个事务方法相互调用时,事务如何在这些方法间传播"></a>多个事务方法相互调用时,事务如何在这些方法间传播</h3><p>REQUIRED(Spring默认的事务传播类型)：如果当前没有事务，则自己新建一个事务，如果当前存在事<br>务，则加入这个事务</p>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据库的配置隔离级别是<span class="keyword">Read</span> Commited,而Spring配置的隔离级别是<span class="keyword">Repeatable</span> <span class="keyword">Read</span>，请问这时隔离</span><br><span class="line">级别是以哪一个为准？</span><br><span class="line">以Spring配置的为准，如果spring设置的隔离级别数据库不支持，效果取决于数据库</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="selector-tag">A</span>是一个事务的方法，方法<span class="selector-tag">A</span>执行过程中调用了方法<span class="selector-tag">B</span>，那么方法<span class="selector-tag">B</span>有无事务以及方法<span class="selector-tag">B</span>对事务的要求不同都</span><br><span class="line">会对方法<span class="selector-tag">A</span>的事务具体执行造成影响，同时方法<span class="selector-tag">A</span>的事务对方法<span class="selector-tag">B</span>的事务执行也有影响，这种影响具体是什么就</span><br><span class="line">由两个方法所定义的事务传播类型所决定。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行"><a href="#SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行" class="headerlink" title="SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行"></a>SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行</h3><h3 id="MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。"><a href="#MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。" class="headerlink" title="MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。"></a>MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</h3><h3 id="REQUIRES-NEW：创建一个新事务，如果存在当前事务，则挂起该事务。"><a href="#REQUIRES-NEW：创建一个新事务，如果存在当前事务，则挂起该事务。" class="headerlink" title="REQUIRES_NEW：创建一个新事务，如果存在当前事务，则挂起该事务。"></a>REQUIRES_NEW：创建一个新事务，如果存在当前事务，则挂起该事务。</h3><h3 id="NOT-SUPPORTED：以非事务方式执行-如果当前存在事务，则挂起当前事务"><a href="#NOT-SUPPORTED：以非事务方式执行-如果当前存在事务，则挂起当前事务" class="headerlink" title="NOT_SUPPORTED：以非事务方式执行,如果当前存在事务，则挂起当前事务"></a>NOT_SUPPORTED：以非事务方式执行,如果当前存在事务，则挂起当前事务</h3><h3 id="NEVER：不使用事务，如果当前事务存在，则抛出异常"><a href="#NEVER：不使用事务，如果当前事务存在，则抛出异常" class="headerlink" title="NEVER：不使用事务，如果当前事务存在，则抛出异常"></a>NEVER：不使用事务，如果当前事务存在，则抛出异常</h3><h3 id="NESTED：如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样（开启一个事务）"><a href="#NESTED：如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样（开启一个事务）" class="headerlink" title="NESTED：如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样（开启一个事务）"></a>NESTED：如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样（开启一个事务）</h3><h2 id="spring事务什么时候会失效"><a href="#spring事务什么时候会失效" class="headerlink" title="spring事务什么时候会失效?"></a>spring事务什么时候会失效?</h2><p>spring事务的原理是AOP，进行了切面增强，那么失效的根本原因是这个AOP不起作用了！常见情况有<br>如下几种</p>
<p>1 、发生自调用，类里面使用this调用本类的方法（this通常省略），此时这个this对象不是代理类，而<br>是UserService对象本身！<br>解决方法很简单，让那个this变成UserService的代理类即可！</p>
<p>2 、方法不是public的</p>
<h3 id="3-、数据库不支持事务"><a href="#3-、数据库不支持事务" class="headerlink" title="3 、数据库不支持事务"></a>3 、数据库不支持事务</h3><p>4 、没有被spring管理</p>
<p>5 、异常被吃掉，事务不会回滚(或者抛出的异常没有被定义，默认为RuntimeException)</p>
<figure class="highlight oxygene"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">和REQUIRES_NEW的区别</span><br><span class="line">REQUIRES_NEW是新建一个事务并且新开启的这个事务与原有事务无关，而<span class="keyword">NESTED</span>则是当前存在事务时（我</span><br><span class="line">们把当前事务称之为父事务）会开启一个嵌套事务（称之为一个子事务）。 在<span class="keyword">NESTED</span>情况下父事务回滚时，</span><br><span class="line">子事务也会回滚，而在REQUIRES_NEW情况下，原有事务回滚，不会影响新开启的事务。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight actionscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">和REQUIRED的区别</span><br><span class="line">REQUIRED情况下，调用方存在事务时，则被调用方和调用方使用同一事务，那么被调用方出现异常时，由于</span><br><span class="line">共用一个事务，所以无论调用方是否<span class="keyword">catch</span>其异常，事务都会回滚 而在NESTED情况下，被调用方发生异常</span><br><span class="line">时，调用方可以<span class="keyword">catch</span>其异常，这样只有子事务回滚，父事务不受影响</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span> 只能用于 <span class="keyword">public</span> 的方法上，否则事务不会失效，如果要用在非 <span class="keyword">public</span> 方法上，可</span><br><span class="line">以开启 AspectJ 代理模式。</span><br></pre></td></tr></tbody></table></figure>

<h2 id="什么是bean的自动装配，有哪些方式？"><a href="#什么是bean的自动装配，有哪些方式？" class="headerlink" title="什么是bean的自动装配，有哪些方式？"></a>什么是bean的自动装配，有哪些方式？</h2><p>开启自动装配，只需要在xml配置文件中定义“autowire”属性。</p>
<p>autowire属性有五种装配的方式：</p>
<figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">no</span> – 缺省情况下，自动配置是通过“<span class="keyword">ref</span>”属性手动设定 。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byName-根据bean的属性名称进行自动装配。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byType-根据bean的类型进行自动装配。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight delphi"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constructor</span>-类似<span class="title">byType</span>，不过是应用于构造器的参数。如果一个<span class="title">bean</span>与构造器参数的类型形</span></span><br><span class="line"><span class="function">同，则进行自动装配，否则导致异常。</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight delphi"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">autodetect-如果有默认的构造器，则通过<span class="function"><span class="keyword">constructor</span>方式进行自动装配，否则使用<span class="title">byType</span>方式</span></span><br><span class="line"><span class="function">进行自动装配。</span></span><br></pre></td></tr></tbody></table></figure>
<p>@Autowired自动装配bean，可以在字段、setter方法、构造函数上使用。</p>
<h1 id="springmvc、springBoot"><a href="#springmvc、springBoot" class="headerlink" title="springmvc、springBoot"></a>springmvc、springBoot</h1><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id<span class="operator">=</span><span class="string">"cutomer"</span> class<span class="operator">=</span><span class="string">"com.xxx.xxx.Customer"</span> autowire<span class="operator">=</span><span class="string">""</span> /&gt;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">手动装配：以value或<span class="built_in">ref</span>的方式明确指定属性值都是手动装配。</span><br><span class="line">需要通过‘<span class="built_in">ref</span>’属性来连接bean。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cutomer的属性名称是person，Spring会将bean id为person的bean通过setter方法进行自动装</span><br><span class="line">配。</span><br><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"cutomer"</span> <span class="attribute">class</span>=<span class="string">"com.xxx.xxx.Cutomer"</span> <span class="attribute">autowire</span>=<span class="string">"byName"</span>/&gt;</span><br><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"person"</span> <span class="attribute">class</span>=<span class="string">"com.xxx.xxx.Person"</span>/&gt;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cutomer的属性person的类型为Person，Spirng会将Person类型通过setter方法进行自动装配。</span><br><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"cutomer"</span> <span class="attribute">class</span>=<span class="string">"com.xxx.xxx.Cutomer"</span> <span class="attribute">autowire</span>=<span class="string">"byType"</span>/&gt;</span><br><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"person"</span> <span class="attribute">class</span>=<span class="string">"com.xxx.xxx.Person"</span>/&gt;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cutomer构造函数的参数person的类型为Person，Spirng会将Person类型通过构造方法进行自动装</span><br><span class="line">配。</span><br><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"cutomer"</span> <span class="attribute">class</span>=<span class="string">"com.xxx.xxx.Cutomer"</span> <span class="attribute">autowire</span>=<span class="string">"construtor"</span>/&gt;</span><br><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"person"</span> <span class="attribute">class</span>=<span class="string">"com.xxx.xxx.Person"</span>/&gt;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight delphi"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果有默认的构造器，则通过<span class="function"><span class="keyword">constructor</span>方式进行自动装配，否则使用<span class="title">byType</span>方式进行自动装配。</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Spring-Boot、Spring-MVC-和-Spring-有什么区别"><a href="#Spring-Boot、Spring-MVC-和-Spring-有什么区别" class="headerlink" title="Spring Boot、Spring MVC 和 Spring 有什么区别"></a>Spring Boot、Spring MVC 和 Spring 有什么区别</h2><p>spring是一个IOC容器，用来管理Bean，使用依赖注入实现控制反转，可以很方便的整合各种框架，提<br>供AOP机制弥补OOP的代码重复问题、更方便将不同类不同方法中的共同处理抽取成切面、自动注入给<br>方法执行，比如日志、异常等</p>
<p>springmvc是spring对web框架的一个解决方案，提供了一个总的前端控制器Servlet，用来接收请求，<br>然后定义了一套路由策略（url到handle的映射）及适配执行handle，将handle结果使用视图解析技术<br>生成视图展现给前端</p>
<p>springboot是spring提供的一个快速开发工具包，让程序员能更方便、更快速的开发spring+springmvc<br>应用，简化了配置（约定了默认配置），整合了一系列的解决方案（starter机制）、redis、<br>mongodb、es，可以开箱即用</p>
<h2 id="SpringMVC-工作流程"><a href="#SpringMVC-工作流程" class="headerlink" title="SpringMVC 工作流程"></a>SpringMVC 工作流程</h2><p>1 ）用户发送请求至前端控制器 DispatcherServlet。</p>
<p>2 ）DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。</p>
<p>3 ）处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器及处理器拦截器<br>(如果有则生成)一并返回给 DispatcherServlet。</p>
<p>4 ）DispatcherServlet 调用 HandlerAdapter 处理器适配器。</p>
<p>5 ）HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)</p>
<p>6 ）Controller 执行完成返回 ModelAndView。</p>
<p>7 ）HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。 8 ）<br>DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。</p>
<p>9 ）ViewReslover 解析后返回具体 View。</p>
<p>10 ）DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。</p>
<p>11 ）DispatcherServlet 响应用户。</p>
<h2 id="Spring-MVC的主要组件？"><a href="#Spring-MVC的主要组件？" class="headerlink" title="Spring MVC的主要组件？"></a>Spring MVC的主要组件？</h2><p>Handler：也就是处理器。它直接应对着MVC中的C也就是Controller层，它的具体表现形式有很多，可<br>以是类，也可以是方法。在Controller层中@RequestMapping标注的所有方法都可以看成是一个<br>Handler，只要可以实际处理请求就可以是Handler</p>
<p>1 、HandlerMapping<br>initHandlerMappings(context)，处理器映射器，根据用户请求的资源uri来查找Handler的。在<br>SpringMVC中会有很多请求，每个请求都需要一个Handler处理，具体接收到一个请求之后使用哪个<br>Handler进行，这就是HandlerMapping需要做的事。</p>
<p>2 、HandlerAdapter<br>initHandlerAdapters(context)，适配器。因为SpringMVC中的Handler可以是任意的形式，只要能处<br>理请求就ok，但是Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方<br>法。如何让固定的Servlet处理方法调用灵活的Handler来进行处理呢？这就是HandlerAdapter要做的<br>事情。<br>Handler是用来干活的工具；HandlerMapping用于根据需要干的活找到相应的工具；HandlerAdapter<br>是使用工具干活的人。</p>
<p>3 、HandlerExceptionResolver<br>initHandlerExceptionResolvers(context)， 其它组件都是用来干活的。在干活的过程中难免会出现问<br>题，出问题后怎么办呢？这就需要有一个专门的角色对异常情况进行处理，在SpringMVC中就是<br>HandlerExceptionResolver。具体来说，此组件的作用是根据异常设置ModelAndView，之后再交给<br>render方法进行渲染。</p>
<p>4 、ViewResolver<br>initViewResolvers(context)，ViewResolver用来将String类型的视图名和Locale解析为View类型的视<br>图。View是用来渲染页面的，也就是将程序返回的参数填入模板里，生成html（也可能是其它类型）<br>文件。这里就有两个关键问题：使用哪个模板？用什么技术（规则）填入参数？这其实是ViewResolver<br>主要要做的工作，ViewResolver需要找到渲染所用的模板和所用的技术（也就是视图的类型）进行渲<br>染，具体的渲染过程则交由不同的视图自己完成。</p>
<p>5 、RequestToViewNameTranslator<br>initRequestToViewNameTranslator(context)，ViewResolver是根据ViewName查找View，但有的<br>Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，<br>如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。<br>RequestToViewNameTranslator在Spring MVC容器里只可以配置一个，所以所有request到<br>ViewName的转换规则都要在一个Translator里面全部实现。</p>
<p>6 、LocaleResolver<br>initLocaleResolver(context)， 解析视图需要两个参数：一是视图名，另一个是Locale。视图名是处理<br>器返回的，Locale是从哪里来的？这就是LocaleResolver要做的事情。LocaleResolver用于从request<br>解析出Locale，Locale就是zh-cn之类，表示一个区域，有了这个就可以对不同区域的用户显示不同的<br>结果。SpringMVC主要有两个地方用到了Locale：一是ViewResolver视图解析的时候；二是用到国际化<br>资源或者主题的时候。</p>
<p>7 、ThemeResolver<br>initThemeResolver(context)，用于解析主题。SpringMVC中一个主题对应一个properties文件，里面<br>存放着跟当前主题相关的所有资源、如图片、css样式等。SpringMVC的主题也支持国际化，同一个主<br>题不同区域也可以显示不同的风格。SpringMVC中跟主题相关的类有 ThemeResolver、ThemeSource<br>和Theme。主题是通过一系列资源来具体体现的，要得到一个主题的资源，首先要得到资源的名称，这<br>是ThemeResolver的工作。然后通过主题名称找到对应的主题（可以理解为一个配置）文件，这是<br>ThemeSource的工作。最后从主题中获取资源就可以了。</p>
<p>8 、MultipartResolver<br>initMultipartResolver(context)，用于处理上传请求。处理方法是将普通的request包装成<br>MultipartHttpServletRequest，后者可以直接调用getFile方法获取File，如果上传多个文件，还可以调<br>用getFileMap得到FileName-&gt;File结构的Map。此组件中一共有三个方法，作用分别是判断是不是上传<br>请求，将request包装成MultipartHttpServletRequest、处理完后清理上传过程中产生的临时资源。</p>
<p>9 、FlashMapManager<br>initFlashMapManager(context)，用来管理FlashMap的，FlashMap主要用在redirect中传递参数。</p>
<h2 id="Spring-Boot-自动配置原理？"><a href="#Spring-Boot-自动配置原理？" class="headerlink" title="Spring Boot 自动配置原理？"></a>Spring Boot 自动配置原理？</h2><p>@Import + @Configuration + Spring spi</p>
<p>自动配置类由各个starter提供，使用@Configuration + @Bean定义配置类，放到META-<br>INF/spring.factories下</p>
<p>使用Spring spi扫描META-INF/spring.factories下的配置类</p>
<p>使用@Import导入自动配置类</p>
<h2 id="如何理解-Spring-Boot-中的-Starter"><a href="#如何理解-Spring-Boot-中的-Starter" class="headerlink" title="如何理解 Spring Boot 中的 Starter"></a>如何理解 Spring Boot 中的 Starter</h2><p>使用spring + springmvc使用，如果需要引入mybatis等框架，需要到xml中定义mybatis需要的bean</p>
<p>starter就是定义一个starter的jar包，写一个@Configuration配置类、将这些bean定义在里面，然后在<br>starter包的META-INF/spring.factories中写入该配置类，springboot会按照约定来加载该配置类</p>
<p>开发人员只需要将相应的starter包依赖进应用，进行相应的属性配置（使用默认配置时，不需要配<br>置），就可以直接进行代码开发，使用对应的功能了，比如mybatis-spring-boot–starter，spring-<br>boot-starter-redis</p>
<h2 id="什么是嵌入式服务器？为什么要使用嵌入式服务器"><a href="#什么是嵌入式服务器？为什么要使用嵌入式服务器" class="headerlink" title="什么是嵌入式服务器？为什么要使用嵌入式服务器?"></a>什么是嵌入式服务器？为什么要使用嵌入式服务器?</h2><p>节省了下载安装tomcat，应用也不需要再打war包，然后放到webapp目录下再运行</p>
<p>只需要一个安装了 Java 的虚拟机，就可以直接在上面部署应用程序了</p>
<p>springboot已经内置了tomcat.jar，运行main方法时会去启动tomcat，并利用tomcat的spi机制加载<br>springmvc</p>
<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="mybatis的优缺点"><a href="#mybatis的优缺点" class="headerlink" title="mybatis的优缺点"></a>mybatis的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><h3 id="1-、基于-SQL-语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL-写在"><a href="#1-、基于-SQL-语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL-写在" class="headerlink" title="1 、基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在"></a>1 、基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在</h3><p>XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签， 支持编写动态 SQL 语句， 并<br>可重用。</p>
<p>2 、与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；</p>
<p>3 、很好的与各种数据库兼容（ 因为 MyBatis 使用 JDBC 来连接数据库，所以只要JDBC 支持的数据库<br>MyBatis 都支持）。</p>
<p>4 、能够与 Spring 很好的集成；</p>
<p>5 、提供映射标签， 支持对象与数据库的 ORM 字段关系映射； 提供对象关系映射标签， 支持对象关<br>系组件维护。</p>
<p>缺点：</p>
<p>1 、SQL 语句的编写工作量较大， 尤其当字段多、关联表多时， 对开发人员编写SQL 语句的功底有一<br>定要求。</p>
<p>2 、SQL 语句依赖于数据库， 导致数据库移植性差， 不能随意更换数据库。</p>
<h2 id="MyBatis-与Hibernate-有哪些不同？"><a href="#MyBatis-与Hibernate-有哪些不同？" class="headerlink" title="MyBatis 与Hibernate 有哪些不同？"></a>MyBatis 与Hibernate 有哪些不同？</h2><h3 id="SQL-和-ORM-的争论，永远都不会终止"><a href="#SQL-和-ORM-的争论，永远都不会终止" class="headerlink" title="SQL 和 ORM 的争论，永远都不会终止"></a>SQL 和 ORM 的争论，永远都不会终止</h3><h3 id="开发速度的对比："><a href="#开发速度的对比：" class="headerlink" title="开发速度的对比："></a>开发速度的对比：</h3><p>Hibernate的真正掌握要比Mybatis难些。Mybatis框架相对简单很容易上手，但也相对简陋些。<br>比起两者的开发速度，不仅仅要考虑到两者的特性及性能，更要根据项目需求去考虑究竟哪一个更适合<br>项目开发，比如：一个项目中用到的复杂查询基本没有，就是简单的增删改查，这样选择hibernate效<br>率就很快了，因为基本的sql语句已经被封装好了，根本不需要你去写sql语句，这就节省了大量的时<br>间，但是对于一个大型项目，复杂语句较多，这样再去选择hibernate就不是一个太好的选择，选择<br>mybatis就会加快许多，而且语句的管理也比较方便。</p>
<p>开发工作量的对比：<br>Hibernate和MyBatis都有相应的代码生成工具。可以生成简单基本的DAO层方法。针对高级查询，<br>Mybatis需要手动编写SQL语句，以及ResultMap。而Hibernate有良好的映射机制，开发者无需关心<br>SQL的生成与结果映射，可以更专注于业务流程</p>
<p>sql优化方面：<br>Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。Hibernate也可以自己写SQL来<br>指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。而Mybatis的SQL是手动编写的，所以<br>可以按需求指定查询的字段。<br>Hibernate HQL语句的调优需要将SQL打印出来，而Hibernate的SQL被很多人嫌弃因为太丑了。<br>MyBatis的SQL是自己手动写的所以调整方便。但Hibernate具有自己的日志统计。Mybatis本身不带日<br>志统计，使用Log4j进行日志记录。</p>
<p>对象管理的对比：<br>Hibernate 是完整的对象/关系映射解决方案，它提供了对象状态管理（state management）的功能，<br>使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常见的 JDBC/SQL 持久层方案中需要<br>管理 SQL 语句，Hibernate采用了更自然的面向对象的视角来持久化 Java 应用中的数据。<br>换句话说，使用 Hibernate 的开发者应该总是关注对象的状态（state），不必考虑 SQL 语句的执行。<br>这部分细节已经由 Hibernate 掌管妥当，只有开发者在进行系统性能调优的时候才需要进行了解。而<br>MyBatis在这一块没有文档说明，用户需要对对象自己进行详细的管理。</p>
<p>缓存机制对比：</p>
<p>相同点：都可以实现自己的缓存或使用其他第三方缓存方案，创建适配器来完全覆盖缓存行为。</p>
<p>不同点：Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体<br>的表-对象映射中配置是哪种缓存。</p>
<p>MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义<br>不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</p>
<p>两者比较：因为Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存<br>时如果出现脏数据，系统会报出错误并提示。</p>
<p>而MyBatis在这一方面，使用二级缓存时需要特别小心。如果不能完全确定数据更新操作的波及范围，<br>避免Cache的盲目使用。否则，脏数据的出现会给系统的正常运行带来很大的隐患。</p>
<p>Hibernate功能强大，数据库无关性好，O/R映射能力强，如果你对Hibernate相当精通，而且对<br>Hibernate进行了适当的封装，那么你的项目整个持久层代码会相当简单，需要写的代码很少，开发速<br>度很快，非常爽。</p>
<p>Hibernate的缺点就是学习门槛不低，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之<br>间如何权衡取得平衡，以及怎样用好Hibernate方面需要你的经验和能力都很强才行。</p>
<p>iBATIS入门简单，即学即用，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经<br>验，对于没有那么高的对象模型要求的项目来说，相当完美。</p>
<p>iBATIS的缺点就是框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库<br>查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。</p>
<h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h2><h3 id="是预编译处理、是占位符，-是字符串替换、是拼接符。"><a href="#是预编译处理、是占位符，-是字符串替换、是拼接符。" class="headerlink" title="#{}是预编译处理、是占位符， ${}是字符串替换、是拼接符。"></a>#{}是预编译处理、是占位符， ${}是字符串替换、是拼接符。</h3><p>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 来赋值；</p>
<p>Mybatis 在处理${}时， 就是把${}替换成变量的值，调用 Statement 来赋值；</p>
<p>#{} 的变量替换是在DBMS 中、变量替换后，#{} 对应的变量自动加上单引号</p>
<p>${} 的变量替换是在 DBMS 外、变量替换后，${} 对应的变量不会加上单引号</p>
<p>使用#{}可以有效的防止 SQL 注入， 提高系统安全性。</p>
<h2 id="简述-Mybatis-的插件运行原理，如何编写一个插件。"><a href="#简述-Mybatis-的插件运行原理，如何编写一个插件。" class="headerlink" title="简述 Mybatis 的插件运行原理，如何编写一个插件。"></a>简述 Mybatis 的插件运行原理，如何编写一个插件。</h2><p>答： Mybatis 只支持针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这<br>4 种接口的插件， Mybatis 使用 JDK 的动态代理， 为需要拦截的接口生成代理对象以实现接口方法拦<br>截功能， 每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的<br>invoke() 方法， 拦截那些你指定需要拦截的方法。</p>
<p>编写插件： 实现 Mybatis 的 Interceptor 接口并复写 intercept()方法， 然后在给插件编写注解， 指定<br>要拦截哪一个接口的哪些方法即可， 在配置文件中配置编写的插件。</p>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Intercepts</span>({<span class="variable">@Signature</span>(type = StatementHandler.class, method = <span class="string">"query"</span>, args =</span><br><span class="line">{Statement.class, ResultHandler.class}),</span><br><span class="line"><span class="variable">@Signature</span>(type = StatementHandler.class, method = <span class="string">"update"</span>, args =</span><br><span class="line">{Statement.class}),</span><br><span class="line"><span class="variable">@Signature</span>(type = StatementHandler.class, method = <span class="string">"batch"</span>, args = {</span><br><span class="line">Statement.class })})</span><br><span class="line"><span class="variable">@Component</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invocation.<span class="keyword">proceed</span>()执行具体的业务逻辑</span><br></pre></td></tr></tbody></table></figure>

<h2 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h2><h3 id="索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。"><a href="#索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。" class="headerlink" title="索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。"></a>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</h3><h3 id="索引的原理：就是把无序的数据变成有序的查询"><a href="#索引的原理：就是把无序的数据变成有序的查询" class="headerlink" title="索引的原理：就是把无序的数据变成有序的查询"></a>索引的原理：就是把无序的数据变成有序的查询</h3><h3 id="1-把创建了索引的列的内容进行排序"><a href="#1-把创建了索引的列的内容进行排序" class="headerlink" title="1. 把创建了索引的列的内容进行排序"></a>1. 把创建了索引的列的内容进行排序</h3><h3 id="2-对排序结果生成倒排表"><a href="#2-对排序结果生成倒排表" class="headerlink" title="2. 对排序结果生成倒排表"></a>2. 对排序结果生成倒排表</h3><h3 id="3-在倒排表内容上拼上数据地址链"><a href="#3-在倒排表内容上拼上数据地址链" class="headerlink" title="3. 在倒排表内容上拼上数据地址链"></a>3. 在倒排表内容上拼上数据地址链</h3><h3 id="4-在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据"><a href="#4-在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据" class="headerlink" title="4. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据"></a>4. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</h3><h2 id="mysql聚簇和非聚簇索引的区别"><a href="#mysql聚簇和非聚簇索引的区别" class="headerlink" title="mysql聚簇和非聚簇索引的区别"></a>mysql聚簇和非聚簇索引的区别</h2><h3 id="都是B-树的数据结构"><a href="#都是B-树的数据结构" class="headerlink" title="都是B+树的数据结构"></a>都是B+树的数据结构</h3><h3 id="聚簇索引：将数据存储与索引放到了一块、并且是按照一定的顺序组织的，找到索引也就找到了数"><a href="#聚簇索引：将数据存储与索引放到了一块、并且是按照一定的顺序组织的，找到索引也就找到了数" class="headerlink" title="聚簇索引：将数据存储与索引放到了一块、并且是按照一定的顺序组织的，找到索引也就找到了数"></a>聚簇索引：将数据存储与索引放到了一块、并且是按照一定的顺序组织的，找到索引也就找到了数</h3><h3 id="据，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是"><a href="#据，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是" class="headerlink" title="据，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是"></a>据，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是</h3><h3 id="相邻地存放在磁盘上的"><a href="#相邻地存放在磁盘上的" class="headerlink" title="相邻地存放在磁盘上的"></a>相邻地存放在磁盘上的</h3><h3 id="非聚簇索引：叶子节点不存储数据、存储的是数据行地址，也就是说根据索引查找到数据行的位置"><a href="#非聚簇索引：叶子节点不存储数据、存储的是数据行地址，也就是说根据索引查找到数据行的位置" class="headerlink" title="非聚簇索引：叶子节点不存储数据、存储的是数据行地址，也就是说根据索引查找到数据行的位置"></a>非聚簇索引：叶子节点不存储数据、存储的是数据行地址，也就是说根据索引查找到数据行的位置</h3><h3 id="再取磁盘查找数据，这个就有点类似一本树的目录，比如我们要找第三章第一节，那我们先在这个"><a href="#再取磁盘查找数据，这个就有点类似一本树的目录，比如我们要找第三章第一节，那我们先在这个" class="headerlink" title="再取磁盘查找数据，这个就有点类似一本树的目录，比如我们要找第三章第一节，那我们先在这个"></a>再取磁盘查找数据，这个就有点类似一本树的目录，比如我们要找第三章第一节，那我们先在这个</h3><h3 id="目录里面找，找到对应的页码后再去对应的页码看文章。"><a href="#目录里面找，找到对应的页码后再去对应的页码看文章。" class="headerlink" title="目录里面找，找到对应的页码后再去对应的页码看文章。"></a>目录里面找，找到对应的页码后再去对应的页码看文章。</h3><p>InnoDB中一定有主键，主键一定是聚簇索引，不手动设置、则会使用unique索引，没有unique索引，<br>则会使用数据库内部的一个行的隐藏id来当作主键索引。在聚簇索引之上创建的索引称之为辅助索引，<br>辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，<br>辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p>
<p>MyISM使用的是非聚簇索引，没有聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构<br>完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助<br>键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据<br>来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p>
<p>如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所<br>占空间小，这些操作是需要在内存中完成的。</p>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优势：</span><br><span class="line">1 、查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询（非覆盖索引的情况下）效率</span><br><span class="line">要高</span><br><span class="line">2 、聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的</span><br><span class="line">3 、聚簇索引适合用在排序的场合，非聚簇索引不适合</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">劣势：</span><br><span class="line"><span class="number">1</span> 、维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候。建议在大量插</span><br><span class="line">入新行后，选在负载较低的时间段，通过OPTIMIZE <span class="keyword">TABLE</span>优化表，因为必须被移动的行数据可能造成</span><br><span class="line">碎片。使用独享表空间可以弱化碎片</span><br><span class="line"><span class="number">2</span> 、表因为使用<span class="type">UUId</span>（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面</span><br><span class="line">更慢，所以建议使用<span class="type">int</span>的auto_increment作为主键</span><br><span class="line"><span class="number">3</span> 、如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键</span><br><span class="line">值，会导致非叶子节点占用占用更多的物理空间</span><br></pre></td></tr></tbody></table></figure>

<h2 id="mysql索引的数据结构，各自优劣"><a href="#mysql索引的数据结构，各自优劣" class="headerlink" title="mysql索引的数据结构，各自优劣"></a>mysql索引的数据结构，各自优劣</h2><p>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，<br>InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因<br>此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议<br>选择BTree索引。</p>
<p>B+树：</p>
<p>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过 1 ，而且同层级的节点间有指针<br>相互链接。在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且<br>基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。因此，B+树索引被广泛应用<br>于数据库、文件系统等场景。</p>
<h3 id="哈希索引："><a href="#哈希索引：" class="headerlink" title="哈希索引："></a>哈希索引：</h3><h3 id="哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B-树那样从根节点到"><a href="#哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B-树那样从根节点到" class="headerlink" title="哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到"></a>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到</h3><h3 id="叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快"><a href="#叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快" class="headerlink" title="叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快"></a>叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快</h3><h3 id="如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；前提"><a href="#如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；前提" class="headerlink" title="如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；前提"></a>如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；前提</h3><h3 id="是键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直"><a href="#是键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直" class="headerlink" title="是键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直"></a>是键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直</h3><h3 id="到找到相应的数据；"><a href="#到找到相应的数据；" class="headerlink" title="到找到相应的数据；"></a>到找到相应的数据；</h3><h3 id="如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，"><a href="#如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，" class="headerlink" title="如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，"></a>如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，</h3><h3 id="有可能变成不连续的了，就没办法再利用索引完成范围查询检索；"><a href="#有可能变成不连续的了，就没办法再利用索引完成范围查询检索；" class="headerlink" title="有可能变成不连续的了，就没办法再利用索引完成范围查询检索；"></a>有可能变成不连续的了，就没办法再利用索引完成范围查询检索；</h3><p>哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实<br>本质上也是范围查询）；</p>
<p>哈希索引也不支持多列联合索引的最左匹配规则；</p>
<p>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引<br>的效率也是极低的，因为存在哈希碰撞问题。</p>
<h2 id="索引设计的原则？"><a href="#索引设计的原则？" class="headerlink" title="索引设计的原则？"></a>索引设计的原则？</h2><h3 id="查询更快、占用空间更小"><a href="#查询更快、占用空间更小" class="headerlink" title="查询更快、占用空间更小"></a>查询更快、占用空间更小</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 适合索引的列是出现在where子句中的列，或者连接子句中指定的列</span><br><span class="line"><span class="bullet">2.</span> 基数较小的表，索引效果较差，没有必要在此列建立索引</span><br><span class="line"><span class="bullet">3.</span> 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，</span><br><span class="line">如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配。</span><br><span class="line"><span class="bullet">4.</span> 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进</span><br><span class="line">行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</span><br><span class="line"><span class="bullet">5.</span> 定义有外键的数据列一定要建立索引。</span><br><span class="line"><span class="bullet">6.</span> 更新频繁字段不适合创建索引</span><br><span class="line"><span class="bullet">7.</span> 若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8.</span> 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修</span><br><span class="line">改原来的索引即可。</span><br><span class="line"><span class="number">9.</span> 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</span><br><span class="line"><span class="number">10.</span> 对于定义为text、image和bit的数据类型的列不要建立索引。</span><br></pre></td></tr></tbody></table></figure>
<h2 id="什么是最左前缀原则？什么是最左匹配原则"><a href="#什么是最左前缀原则？什么是最左匹配原则" class="headerlink" title="什么是最左前缀原则？什么是最左匹配原则"></a>什么是最左前缀原则？什么是最左匹配原则</h2><h2 id="锁的类型有哪些"><a href="#锁的类型有哪些" class="headerlink" title="锁的类型有哪些"></a>锁的类型有哪些</h2><h3 id="基于锁的属性分类：共享锁、排他锁。"><a href="#基于锁的属性分类：共享锁、排他锁。" class="headerlink" title="基于锁的属性分类：共享锁、排他锁。"></a>基于锁的属性分类：共享锁、排他锁。</h3><h3 id="基于锁的粒度分类：行级锁-INNODB-、表级锁-INNODB、MYISAM-、页级锁-BDB引擎-、记录锁、间"><a href="#基于锁的粒度分类：行级锁-INNODB-、表级锁-INNODB、MYISAM-、页级锁-BDB引擎-、记录锁、间" class="headerlink" title="基于锁的粒度分类：行级锁(INNODB)、表级锁(INNODB、MYISAM)、页级锁(BDB引擎 )、记录锁、间"></a>基于锁的粒度分类：行级锁(INNODB)、表级锁(INNODB、MYISAM)、页级锁(BDB引擎 )、记录锁、间</h3><h3 id="隙锁、临键锁。"><a href="#隙锁、临键锁。" class="headerlink" title="隙锁、临键锁。"></a>隙锁、临键锁。</h3><h3 id="基于锁的状态分类：意向共享锁、意向排它锁。"><a href="#基于锁的状态分类：意向共享锁、意向排它锁。" class="headerlink" title="基于锁的状态分类：意向共享锁、意向排它锁。"></a>基于锁的状态分类：意向共享锁、意向排它锁。</h3><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">共享锁(<span class="keyword">Share</span> <span class="keyword">Lock</span>)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">排他锁（<span class="keyword">eXclusive</span> <span class="keyword">Lock</span>）</span><br></pre></td></tr></tbody></table></figure>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">共享锁又称读锁，简称S锁；当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对</span><br><span class="line">数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持</span><br><span class="line">并发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight tp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">排他锁又称写锁，简称<span class="keyword">X</span>锁；当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该</span><br><span class="line">锁释放之后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改时候，不允许其他人同时修</span><br><span class="line">改，也不允许其他人读取。避免了出现脏数据和脏读的问题。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能</span><br><span class="line">进行对表进行访问；</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">特点： 粒度大，加锁简单，容易冲突；</span><br></pre></td></tr></tbody></table></figure>

<p>记录锁(Record Lock)</p>
<h3 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h3><p>间隙锁(Gap Lock)</p>
<p>临建锁(Next-Key Lock)</p>
<h3 id="如果当事务A加锁成功之后就设置一个状态告诉后面的人，已经有人对表里的行加了一个排他锁"><a href="#如果当事务A加锁成功之后就设置一个状态告诉后面的人，已经有人对表里的行加了一个排他锁" class="headerlink" title="如果当事务A加锁成功之后就设置一个状态告诉后面的人，已经有人对表里的行加了一个排他锁"></a>如果当事务A加锁成功之后就设置一个状态告诉后面的人，已经有人对表里的行加了一个排他锁</h3><h3 id="了，你们不能对整个表加共享锁或排它锁了，那么后面需要对整个表加锁的人只需要获取这个状态"><a href="#了，你们不能对整个表加共享锁或排它锁了，那么后面需要对整个表加锁的人只需要获取这个状态" class="headerlink" title="了，你们不能对整个表加共享锁或排它锁了，那么后面需要对整个表加锁的人只需要获取这个状态"></a>了，你们不能对整个表加共享锁或排它锁了，那么后面需要对整个表加锁的人只需要获取这个状态</h3><h3 id="就知道自己是不是可以对表加锁，避免了对整个索引树的每个节点扫描是否加锁，而这个状态就是"><a href="#就知道自己是不是可以对表加锁，避免了对整个索引树的每个节点扫描是否加锁，而这个状态就是" class="headerlink" title="就知道自己是不是可以对表加锁，避免了对整个索引树的每个节点扫描是否加锁，而这个状态就是"></a>就知道自己是不是可以对表加锁，避免了对整个索引树的每个节点扫描是否加锁，而这个状态就是</h3><h3 id="意向锁。"><a href="#意向锁。" class="headerlink" title="意向锁。"></a>意向锁。</h3><h3 id="意向共享锁"><a href="#意向共享锁" class="headerlink" title="意向共享锁"></a>意向共享锁</h3><h3 id="意向排他锁"><a href="#意向排他锁" class="headerlink" title="意向排他锁"></a>意向排他锁</h3><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不</span><br><span class="line">能访问，其他的记录可正常访问；</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高；</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁后锁</span><br><span class="line">住的只是表的某一条记录。</span><br><span class="line">精准条件命中，并且命中的条件字段是唯一索引</span><br><span class="line">加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前</span><br><span class="line">被其他事务读取的脏读问题。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突</span><br><span class="line">少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</span><br><span class="line">特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">属于行锁中的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空</span><br><span class="line">隙则会形成一个区间，遵循左开右闭原则。</span><br><span class="line">范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在REPEATABLE_READ（重复</span><br><span class="line">读)的事务级别中。</span><br><span class="line">触发条件：防止幻读问题，事务并发的时候，如果没有间隙锁，就会发生如下图的问题，在同一个事务</span><br><span class="line">里，<span class="selector-tag">A</span>事务的两次查询出的结果会不一样。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如表里面的数据ID 为 <span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">10</span> ,那么会形成以下几个间隙区间，-<span class="built_in">n</span>-<span class="number">1</span>区间，<span class="number">1</span>-<span class="number">4</span>区间，<span class="number">7</span>-<span class="number">10</span></span><br><span class="line">区间，<span class="number">10</span>-<span class="built_in">n</span>区间 （-<span class="built_in">n</span>代表负无穷大，<span class="built_in">n</span>代表正无穷大）</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是记录锁和间隙锁的组合，临键锁</span><br><span class="line">会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一</span><br><span class="line">个区间也会锁住</span><br><span class="line">触发条件：范围查询并命中，查询命中了索引。</span><br><span class="line">结合记录锁和间隙锁的特性，临键锁避免了在范围查询时出现脏读、重复读、幻读问题。加了临键锁之</span><br><span class="line">后，在范围区间内数据不允许被修改和插</span><br><span class="line">入。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当一个事务试图对整个表进行加共享锁之前，首先需要获得这个表的意向共享锁。</span><br></pre></td></tr></tbody></table></figure>

<h2 id="InnoDB存储引擎的锁的算法"><a href="#InnoDB存储引擎的锁的算法" class="headerlink" title="InnoDB存储引擎的锁的算法"></a>InnoDB存储引擎的锁的算法</h2><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Record</span> <span class="keyword">lock</span>：单个行记录上的锁</span><br><span class="line">Gap <span class="keyword">lock</span>：间隙锁，锁定一个范围，不包括记录本身</span><br><span class="line">Next-key <span class="keyword">lock</span>：<span class="type">record</span>+gap 锁定一个范围，包含记录本身</span><br></pre></td></tr></tbody></table></figure>
<p>相关知识点：</p>
<figure class="highlight vbnet"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. innodb对于行的查询使用<span class="keyword">next</span>-<span class="keyword">key</span> lock</span><br><span class="line"><span class="number">2</span>. <span class="keyword">Next</span>-locking keying为了解决Phantom Problem幻读问题</span><br><span class="line"><span class="number">3</span>. 当查询的索引含有唯一属性时，将<span class="keyword">next</span>-<span class="keyword">key</span> lock降级为record <span class="keyword">key</span></span><br><span class="line"><span class="number">4</span>. Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</span><br><span class="line"><span class="number">5</span>. 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A.</span><br><span class="line">将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为 <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢"><a href="#关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢" class="headerlink" title="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢"></a>关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢</h2><h2 id="查询都怎么优化过？"><a href="#查询都怎么优化过？" class="headerlink" title="查询都怎么优化过？"></a>查询都怎么优化过？</h2><h3 id="在业务系统中，除了使用主键进行的查询，其他的都会在测试库上测试其耗时，慢查询的统计主要由运"><a href="#在业务系统中，除了使用主键进行的查询，其他的都会在测试库上测试其耗时，慢查询的统计主要由运" class="headerlink" title="在业务系统中，除了使用主键进行的查询，其他的都会在测试库上测试其耗时，慢查询的统计主要由运"></a>在业务系统中，除了使用主键进行的查询，其他的都会在测试库上测试其耗时，慢查询的统计主要由运</h3><h3 id="维在做，会定期将业务中的慢查询反馈给我们。"><a href="#维在做，会定期将业务中的慢查询反馈给我们。" class="headerlink" title="维在做，会定期将业务中的慢查询反馈给我们。"></a>维在做，会定期将业务中的慢查询反馈给我们。</h3><p>慢查询的优化首先要搞明白慢的原因是什么？是查询条件没有命中索引？是load了不需要的数据列？还<br>是数据量太大？</p>
<p>所以优化也是针对这三个方向来的，</p>
<figure class="highlight gauss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">首先分析语句，看看是否<span class="keyword">load</span>了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载</span><br><span class="line">了许多结果中并不需要的列，对语句进行分析以及重写。</span><br><span class="line">分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽</span><br><span class="line">可能的命中索引。</span><br><span class="line">如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者</span><br><span class="line">纵向的分表。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当一个事务试图对整个表进行加排它锁之前，首先需要获得这个表的意向排它锁。</span><br></pre></td></tr></tbody></table></figure>

<h2 id="事务的基本特性和隔离级别"><a href="#事务的基本特性和隔离级别" class="headerlink" title="事务的基本特性和隔离级别"></a>事务的基本特性和隔离级别</h2><h3 id="事务基本特性ACID分别是："><a href="#事务基本特性ACID分别是：" class="headerlink" title="事务基本特性ACID分别是："></a>事务基本特性ACID分别是：</h3><h3 id="原子性-指的是一个事务中的操作要么全部成功，要么全部失败。"><a href="#原子性-指的是一个事务中的操作要么全部成功，要么全部失败。" class="headerlink" title="原子性 指的是一个事务中的操作要么全部成功，要么全部失败。"></a>原子性 指的是一个事务中的操作要么全部成功，要么全部失败。</h3><h3 id="一致性-指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，"><a href="#一致性-指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，" class="headerlink" title="一致性 指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，"></a>一致性 指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，</h3><h3 id="假设A只有-90-块，支付之前我们数据库里的数据都是符合约束的-但是如果事务执行成功了-我们的数据库"><a href="#假设A只有-90-块，支付之前我们数据库里的数据都是符合约束的-但是如果事务执行成功了-我们的数据库" class="headerlink" title="假设A只有 90 块，支付之前我们数据库里的数据都是符合约束的,但是如果事务执行成功了,我们的数据库"></a>假设A只有 90 块，支付之前我们数据库里的数据都是符合约束的,但是如果事务执行成功了,我们的数据库</h3><h3 id="数据就破坏约束了-因此事务不能成功-这里我们说事务提供了一致性的保证"><a href="#数据就破坏约束了-因此事务不能成功-这里我们说事务提供了一致性的保证" class="headerlink" title="数据就破坏约束了,因此事务不能成功,这里我们说事务提供了一致性的保证"></a>数据就破坏约束了,因此事务不能成功,这里我们说事务提供了一致性的保证</h3><h3 id="隔离性-指的是一个事务的修改在最终提交前，对其他事务是不可见的。"><a href="#隔离性-指的是一个事务的修改在最终提交前，对其他事务是不可见的。" class="headerlink" title="隔离性 指的是一个事务的修改在最终提交前，对其他事务是不可见的。"></a>隔离性 指的是一个事务的修改在最终提交前，对其他事务是不可见的。</h3><h3 id="持久性-指的是一旦事务提交，所做的修改就会永久保存到数据库中。"><a href="#持久性-指的是一旦事务提交，所做的修改就会永久保存到数据库中。" class="headerlink" title="持久性 指的是一旦事务提交，所做的修改就会永久保存到数据库中。"></a>持久性 指的是一旦事务提交，所做的修改就会永久保存到数据库中。</h3><h3 id="隔离性有-4-个隔离级别，分别是："><a href="#隔离性有-4-个隔离级别，分别是：" class="headerlink" title="隔离性有 4 个隔离级别，分别是："></a>隔离性有 4 个隔离级别，分别是：</h3><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">read</span> uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读。</span><br><span class="line">用户本来应该读取到id=<span class="number">1</span>的用户age应该是 <span class="number">10</span> ，结果读取到了其他事务还没有提交的事务，结果读</span><br><span class="line">取结果age=<span class="number">20</span>，这就是脏读。</span><br><span class="line"><span class="keyword">read</span> <span class="keyword">commit</span> 读已提交，两次读取结果不一致，叫做不可重复读。</span><br><span class="line">不可重复读解决了脏读的问题，他只会读取已经提交的事务。</span><br><span class="line">用户开启事务读取id=<span class="number">1</span>用户，查询到age=<span class="number">10</span>，再次读取发现结果=<span class="number">20</span>，在同一个事务里同一个查</span><br><span class="line">询读取到不同的结果叫做不可重复读。</span><br><span class="line"><span class="keyword">repeatable</span> <span class="keyword">read</span> 可重复复读，这是mysql的默认级别，就是每次读取结果都一样，但是有可能产</span><br><span class="line">生幻读。</span><br><span class="line"><span class="keyword">serializable</span> 串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争</span><br><span class="line">的问题。</span><br></pre></td></tr></tbody></table></figure>
<p>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，<br>前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p>
<p>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中<br>间插入了一个事务更新的原有的数据。</p>
<p>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数<br>据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据<br>是它先前所没有的。</p>
<h2 id="ACID靠什么保证的？"><a href="#ACID靠什么保证的？" class="headerlink" title="ACID靠什么保证的？"></a>ACID靠什么保证的？</h2><p>A原子性由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql</p>
<p>C一致性由其他三大特性保证、程序代码要保证业务上的一致性</p>
<h3 id="I隔离性由MVCC来保证"><a href="#I隔离性由MVCC来保证" class="headerlink" title="I隔离性由MVCC来保证"></a>I隔离性由MVCC来保证</h3><p>D持久性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可<br>以从redo log恢复</p>
<p>redolog的刷盘会在系统空闲时进行</p>
<h2 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h2><h3 id="多版本并发控制：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，"><a href="#多版本并发控制：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，" class="headerlink" title="多版本并发控制：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，"></a>多版本并发控制：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，</h3><p>不同的事务session会看到自己特定版本的数据，版本链</p>
<p>MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。其他两个隔离级别够和<br>MVCC不兼容, 因为 READ UNCOMMITTED 总是读取最新的数据行, 而不是符合当前事务版本的数据<br>行。而 SERIALIZABLE 则会对所有读取的行都加锁。</p>
<h3 id="聚簇索引记录中有两个必要的隐藏列："><a href="#聚簇索引记录中有两个必要的隐藏列：" class="headerlink" title="聚簇索引记录中有两个必要的隐藏列："></a>聚簇索引记录中有两个必要的隐藏列：</h3><p><strong>trx_id</strong> ：用来存储每次对某条聚簇索引记录进行修改的时候的事务id。</p>
<p><strong>roll_pointer</strong> ：每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个<br>roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个<br>版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)</p>
<p><strong>已提交读和可重复读的区别就在于它们生成ReadView的策略不同</strong> 。</p>
<p>开始事务时创建readview，readView维护当前活动的事务id，即未提交的事务id，排序生成一个数组</p>
<p>访问数据，获取数据中的事务id（获取的是事务id最大的记录），对比readview：</p>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InnoDB redo <span class="keyword">log</span> 写盘，InnoDB 事务进入 <span class="keyword">prepare</span> 状态。</span><br><span class="line">如果前面 <span class="keyword">prepare</span> 成功，binlog 写盘，再继续将事务日志持久化到 binlog，如果持久化成功，那么</span><br><span class="line">InnoDB 事务则进入 <span class="keyword">commit</span> 状态(在 redo <span class="keyword">log</span> 里面写一个 <span class="keyword">commit</span> 记录)</span><br></pre></td></tr></tbody></table></figure>

<p>如果在readview的左边（比readview都小），可以访问（在左边意味着该事务已经提交）</p>
<p>如果在readview的右边（比readview都大）或者就在readview中，不可以访问，获取roll_pointer，取<br>上一版本重新对比（在右边意味着，该事务在readview生成之后出现，在readview中意味着该事务还<br>未提交）</p>
<p>已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在<br>第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。</p>
<p>这就是Mysql的MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过ReadView生成策略的不同<br>实现不同的隔离级别。</p>
<h2 id="分表后非sharding-key的查询怎么处理，分表后的排序？"><a href="#分表后非sharding-key的查询怎么处理，分表后的排序？" class="headerlink" title="分表后非sharding_key的查询怎么处理，分表后的排序？"></a>分表后非sharding_key的查询怎么处理，分表后的排序？</h2><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 可以做一个mapping表，比如这时候商家要查询订单列表怎么办呢？不带user<span class="emphasis">_id查询的话你总不</span></span><br><span class="line"><span class="emphasis">能扫全表吧？所以我们可以做一个映射关系表，保存商家和用户的关系，查询的时候先通过商家查</span></span><br><span class="line"><span class="emphasis">询到用户列表，再通过user_</span>id去查询。</span><br><span class="line"><span class="bullet">2.</span> 宽表，对数据实时性要求不是很高的场景，比如查询订单列表，可以把订单表同步到离线（实时）</span><br><span class="line">数仓，再基于数仓去做成一张宽表，再基于其他如es提供查询服务。</span><br><span class="line"><span class="bullet">3.</span> 数据量不是很大的话，比如后台的一些查询之类的，也可以通过多线程扫表，然后再聚合结果的方</span><br><span class="line">式来做。或者异步的形式也是可以的。</span><br></pre></td></tr></tbody></table></figure>
<p>union</p>
<p>排序字段是唯一索引：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先第一页的查询：将各表的结果集进行合并，然后再次排序</span><br><span class="line">第二页及以后的查询，需要传入上一页排序字段的最后一个值，及排序方式。</span><br><span class="line">根据排序方式，及这个值进行查询。如排序字段<span class="type">date</span>，上一页最后值为 <span class="number">3</span> ，排序方式降序。查询的</span><br><span class="line">时候<span class="keyword">sql</span>为<span class="keyword">select</span> ... <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="type">date</span> <span class="operator">&lt;</span> <span class="number">3</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="type">date</span> <span class="keyword">desc</span> limit <span class="number">0</span>,<span class="number">10</span>。这样再将几个表的</span><br><span class="line">结果合并排序即可。</span><br></pre></td></tr></tbody></table></figure>
<h2 id="mysql主从同步原理"><a href="#mysql主从同步原理" class="headerlink" title="mysql主从同步原理"></a>mysql主从同步原理</h2><p>mysql主从同步的过程：</p>
<p>Mysql的主从复制中主要有三个线程：master（binlog dump thread）、slave（I/O thread 、SQL<br>thread），Master一条线程和Slave中的两条线程。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主节点 binlog，主从复制的基础是主库记录数据库的所有变更记录到 binlog。binlog 是数据库服</span><br><span class="line">务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件。</span><br><span class="line">主节点 <span class="built_in">log</span> <span class="built_in">dump</span> 线程，当 binlog 有变动时，<span class="built_in">log</span> <span class="built_in">dump</span> 线程读取其内容并发送给从节点。</span><br><span class="line">从节点 I/O线程接收 binlog 内容，并将其写入到 relay <span class="built_in">log</span> 文件中。</span><br><span class="line">从节点的SQL 线程读取 relay <span class="built_in">log</span> 文件内容对数据更新进行重放，最终保证主从数据库的一致性。</span><br></pre></td></tr></tbody></table></figure>
<p>注：主从节点使用 binglog 文件 + position 偏移量来定位主从同步的位置，从节点会保存其已接收到的<br>偏移量，如果从节点发生宕机重启，则会自动从 position 的位置发起同步。</p>
<p>由于mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生<br>一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个<br>概念。</p>
<p><strong>全同步复制</strong></p>
<p>主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方<br>式的话性能会受到严重影响。</p>
<p><strong>半同步复制</strong></p>
<p>和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至<br>少一个从库的确认就认为写操作完成。</p>
<h2 id="简述MyISAM和InnoDB的区别"><a href="#简述MyISAM和InnoDB的区别" class="headerlink" title="简述MyISAM和InnoDB的区别"></a>简述MyISAM和InnoDB的区别</h2><p><strong>MyISAM：</strong></p>
<p>不支持事务，但是每次查询都是原子的；</p>
<p>支持表级锁，即每次操作是对整个表加锁；</p>
<p>存储表的总行数；</p>
<p>一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；</p>
<p>采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引<br>不用保证唯一性。</p>
<p><strong>InnoDb：</strong></p>
<p>支持ACID的事务，支持事务的四种隔离级别；</p>
<p>支持行级锁及外键约束：因此可以支持写并发；</p>
<p>不存储总行数；</p>
<p>一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多<br>个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操<br>作系统文件大小的限制；</p>
<p>主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅<br>索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，<br>为维持B+树结构，文件的大调整。</p>
<h2 id="简述mysql中索引类型及对数据库的性能的影响"><a href="#简述mysql中索引类型及对数据库的性能的影响" class="headerlink" title="简述mysql中索引类型及对数据库的性能的影响"></a>简述mysql中索引类型及对数据库的性能的影响</h2><h3 id="普通索引：允许被索引的数据列包含重复的值。"><a href="#普通索引：允许被索引的数据列包含重复的值。" class="headerlink" title="普通索引：允许被索引的数据列包含重复的值。"></a>普通索引：允许被索引的数据列包含重复的值。</h3><h3 id="唯一索引：可以保证数据记录的唯一性。"><a href="#唯一索引：可以保证数据记录的唯一性。" class="headerlink" title="唯一索引：可以保证数据记录的唯一性。"></a>唯一索引：可以保证数据记录的唯一性。</h3><h3 id="主键：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用"><a href="#主键：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用" class="headerlink" title="主键：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用"></a>主键：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用</h3><h3 id="关键字-PRIMARY-KEY-来创建。"><a href="#关键字-PRIMARY-KEY-来创建。" class="headerlink" title="关键字 PRIMARY KEY 来创建。"></a>关键字 PRIMARY KEY 来创建。</h3><p>联合索引：索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引。</p>
<p>全文索引：通过建立倒排索引,可以极大的提升检索效率,解决判断字段是否包含的问题，是目前搜索引<br>擎使用的一种关键技术。可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引</p>
<h3 id="索引可以极大的提高数据的查询速度。"><a href="#索引可以极大的提高数据的查询速度。" class="headerlink" title="索引可以极大的提高数据的查询速度。"></a>索引可以极大的提高数据的查询速度。</h3><h3 id="通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。"><a href="#通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。" class="headerlink" title="通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。"></a>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</h3><h3 id="但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件"><a href="#但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件" class="headerlink" title="但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件"></a>但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件</h3><h3 id="索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚"><a href="#索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚" class="headerlink" title="索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚"></a>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚</h3><h3 id="簇索引，那么需要的空间就会更大，如果非聚集索引很多，一旦聚集索引改变，那么所有非聚集索引都"><a href="#簇索引，那么需要的空间就会更大，如果非聚集索引很多，一旦聚集索引改变，那么所有非聚集索引都" class="headerlink" title="簇索引，那么需要的空间就会更大，如果非聚集索引很多，一旦聚集索引改变，那么所有非聚集索引都"></a>簇索引，那么需要的空间就会更大，如果非聚集索引很多，一旦聚集索引改变，那么所有非聚集索引都</h3><h3 id="会跟着变。"><a href="#会跟着变。" class="headerlink" title="会跟着变。"></a>会跟着变。</h3><h2 id="mysql执行计划怎么看"><a href="#mysql执行计划怎么看" class="headerlink" title="mysql执行计划怎么看"></a>mysql执行计划怎么看</h2><p>执行计划就是sql的执行查询的顺序，以及如何使用索引查询，返回的结果集的行数</p>
<p>EXPLAIN SELECT * from A where X=? and Y=?</p>
<p>1 。id ：是一个有顺序的编号，是查询的顺序号，有几个 select 就显示几行。id的顺序是按 select 出现<br>的顺序增长的。id列的值越大执行优先级越高越先执行，id列的值相同则从上往下执行，id列的值为<br>NULL最后执行。</p>
<p>2 。selectType 表示查询中每个select子句的类型</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE： 表示此查询不包含 <span class="keyword">UNION</span> 查询或子查询</span><br><span class="line"><span class="keyword">PRIMARY</span>： 表示此查询是最外层的查询（包含子查询）</span><br><span class="line">SUBQUERY： 子查询中的第一个 <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">UNION</span>： 表示此查询是 <span class="keyword">UNION</span> 的第二或随后的查询</span><br><span class="line">DEPENDENT <span class="keyword">UNION</span>： <span class="keyword">UNION</span> 中的第二个或后面的查询语句, 取决于外面的查询</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">RESULT</span>, <span class="keyword">UNION</span> 的结果</span><br><span class="line">DEPENDENT SUBQUERY: 子查询中的第一个 <span class="keyword">SELECT</span>, 取决于外面的查询. 即子查询依赖于外层查</span><br><span class="line">询的结果.</span><br><span class="line">DERIVED：衍生，表示导出表的<span class="keyword">SELECT</span>（<span class="keyword">FROM</span>子句的子查询）</span><br></pre></td></tr></tbody></table></figure>
<p>3.table：表示该语句查询的表</p>
<p>4.type：优化sql的重要字段，也是我们判断sql性能和优化程度重要指标。他的取值类型范围：</p>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const：通过索引一次命中，匹配一行数据</span><br><span class="line"><span class="keyword">system</span>: 表中只有一行记录，相当于系统表；</span><br><span class="line">eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配</span><br><span class="line"><span class="keyword">ref</span>: 非唯一性索引扫描,返回匹配某个值的所有</span><br><span class="line">range: 只检索给定范围的行，使用一个索引来选择行，一般用于<span class="keyword">between</span>、&lt;、&gt;；</span><br><span class="line"><span class="keyword">index</span>: 只遍历索引树；</span><br><span class="line"><span class="keyword">ALL</span>: 表示全表扫描，这个类型的查询是性能最差的查询之一。 那么基本就是随着表的数量增多，</span><br><span class="line">执行效率越慢。</span><br></pre></td></tr></tbody></table></figure>
<p><strong>执行效率：</strong></p>
<p><strong>ALL &lt; index &lt; range&lt; ref &lt; eq_ref &lt; const &lt; system。最好是避免ALL和index</strong></p>
<p>5.possible_keys：它表示Mysql在执行该sql语句的时候，可能用到的索引信息，仅仅是可能，实际不一<br>定会用到。</p>
<p>6.key：此字段是 mysql 在当前查询时所真正使用到的索引。 他是possible_keys的子集</p>
<p>7.key_len：表示查询优化器使用了索引的字节数，这个字段可以评估组合索引是否完全被使用，这也是<br>我们优化sql时，评估索引的重要指标</p>
<p>9.rows：mysql 查询优化器根据统计信息，估算该sql返回结果集需要扫描读取的行数，这个值相关重<br>要，索引优化之后，扫描读取的行数越多，说明索引设置不对，或者字段传入的类型之类的问题，说明<br>要优化空间越大</p>
<p>10.filtered：返回结果的行占需要读到的行(rows列的值)的百分比，就是百分比越高，说明需要查询到<br>数据越准确， 百分比越小，说明查询到的数据量大，而结果集很少</p>
<p>11.extra</p>
<figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> filesort ：表示 mysql 对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有</span><br><span class="line"><span class="keyword">using</span> filesort都建议优化去掉，因为这样的查询 cpu 资源消耗大，延时大。</span><br><span class="line"><span class="keyword">using</span> index：覆盖索引扫描，表示查询在索引树中就可查找所需数据，不用扫描表数据文件，往</span><br><span class="line">往说明性能不错。</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">temporary</span>：查询有使用临时表, 一般出现于排序， 分组和多表 <span class="keyword">join</span> 的情况， 查询效率不</span><br><span class="line">高，建议优化。</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">where</span> ：<span class="keyword">sql</span>使用了<span class="keyword">where</span>过滤,效率较高。</span><br></pre></td></tr></tbody></table></figure>
<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="RDB-和-AOF-机制"><a href="#RDB-和-AOF-机制" class="headerlink" title="RDB 和 AOF 机制"></a>RDB 和 AOF 机制</h2><p>RDB：Redis DataBase</p>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写<br>入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<p><strong>优点：</strong></p>
<p>1 、整个Redis数据库将只包含一个文件 dump.rdb，方便持久化。</p>
<p>2 、容灾性好，方便备份。</p>
<p>3 、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进<br>程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</p>
<p>4.相对于数据集大时，比 AOF 的启动效率更高。</p>
<p><strong>缺点：</strong></p>
<p>1 、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢<br>失。所以这种方式更适合数据要求不严谨的时候)</p>
<p>2 、由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导<br>致整个服务器停止服务几百毫秒，甚至是 1 秒钟。</p>
<p>AOF：Append Only File</p>
<p>以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以<br>打开文件看到详细的操作记录</p>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br></pre></td></tr></tbody></table></figure>
<p>1 、数据安全，Redis中提供了 3 中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也<br>是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据<br>将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁<br>盘中。。</p>
<p>2 、通过 append 模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redis-<br>check-aof 工具解决数据一致性问题。</p>
<p>3 、AOF 机制的 rewrite 模式。定期对AOF文件进行重写，以达到压缩的目的</p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><h3 id="1-、AOF-文件比-RDB-文件大，且恢复速度慢。"><a href="#1-、AOF-文件比-RDB-文件大，且恢复速度慢。" class="headerlink" title="1 、AOF 文件比 RDB 文件大，且恢复速度慢。"></a>1 、AOF 文件比 RDB 文件大，且恢复速度慢。</h3><p>2 、数据集大的时候，比 rdb 启动效率低。</p>
<p>3 、运行效率没有RDB高</p>
<h3 id="AOF文件比RDB更新频率高，优先使用AOF还原数据。"><a href="#AOF文件比RDB更新频率高，优先使用AOF还原数据。" class="headerlink" title="AOF文件比RDB更新频率高，优先使用AOF还原数据。"></a>AOF文件比RDB更新频率高，优先使用AOF还原数据。</h3><h3 id="AOF比RDB更安全也更大"><a href="#AOF比RDB更安全也更大" class="headerlink" title="AOF比RDB更安全也更大"></a>AOF比RDB更安全也更大</h3><h3 id="RDB性能比AOF好"><a href="#RDB性能比AOF好" class="headerlink" title="RDB性能比AOF好"></a>RDB性能比AOF好</h3><h3 id="如果两个都配了优先加载AOF"><a href="#如果两个都配了优先加载AOF" class="headerlink" title="如果两个都配了优先加载AOF"></a>如果两个都配了优先加载AOF</h3><h2 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h2><p>Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当<br>Redis中缓存的key过期了，Redis如何处理。</p>
<figure class="highlight gauss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">惰性过期 ：只有当访问一个<span class="built_in">key</span>时，才会判断该<span class="built_in">key</span>是否已过期，过期则清除。该策略可以最大化</span><br><span class="line">地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期<span class="built_in">key</span>没有再次被访问，从而</span><br><span class="line">不会被清除，占用大量内存。</span><br><span class="line">定期过期 ：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的<span class="built_in">key</span>，并清除其</span><br><span class="line">中已过期的<span class="built_in">key</span>。该策略是一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，</span><br><span class="line">可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</span><br></pre></td></tr></tbody></table></figure>
<p>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的<br>指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有<br>键。)</p>
<p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<h2 id="Redis线程模型、单线程快的原因"><a href="#Redis线程模型、单线程快的原因" class="headerlink" title="Redis线程模型、单线程快的原因"></a>Redis线程模型、单线程快的原因</h2><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器 file event handler。<br>这个文件事件处理器，它是单线程的，所以 Redis 才叫做单线程的模型，它采用IO多路复用机制来同时<br>监听多个Socket，根据Socket上的事件类型来选择对应的事件处理器来处理这个事件。可以实现高性能<br>的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了 Redis 内部的线程模型的简单性。</p>
<p>文件事件处理器的结构包含 4 个部分：多个Socket、IO多路复用程序、文件事件分派器以及事件处理器<br>（命令请求处理器、命令回复处理器、连接应答处理器等）。<br>多个 Socket 可能并发的产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听<br>多个 Socket，会将 Socket 放入一个队列中排队，每次从队列中取出一个 Socket 给事件分派器，事件<br>分派器把 Socket 给对应的事件处理器。<br>然后一个 Socket 的事件处理完之后，IO多路复用程序才会将队列中的下一个 Socket 给事件分派器。文<br>件事件分派器会根据每个 Socket 当前产生的事件，来选择对应的事件处理器来处理。</p>
<h3 id="单线程快的原因："><a href="#单线程快的原因：" class="headerlink" title="单线程快的原因："></a>单线程快的原因：</h3><h3 id="1-）纯内存操作"><a href="#1-）纯内存操作" class="headerlink" title="1 ）纯内存操作"></a>1 ）纯内存操作</h3><h3 id="2-）核心是基于非阻塞的IO多路复用机制"><a href="#2-）核心是基于非阻塞的IO多路复用机制" class="headerlink" title="2 ）核心是基于非阻塞的IO多路复用机制"></a>2 ）核心是基于非阻塞的IO多路复用机制</h3><h3 id="3-）单线程反而避免了多线程的频繁上下文切换带来的性能问题"><a href="#3-）单线程反而避免了多线程的频繁上下文切换带来的性能问题" class="headerlink" title="3 ）单线程反而避免了多线程的频繁上下文切换带来的性能问题"></a>3 ）单线程反而避免了多线程的频繁上下文切换带来的性能问题</h3><h2 id="简述Redis事务实现"><a href="#简述Redis事务实现" class="headerlink" title="简述Redis事务实现"></a>简述Redis事务实现</h2><h3 id="1-、事务开始"><a href="#1-、事务开始" class="headerlink" title="1 、事务开始"></a>1 、事务开始</h3><p><em>MULTI</em> 命令的执行，标识着一个事务的开始。 <em>MULTI</em> 命令会将客户端状态的flags属性中打开<br>REDIS_MULTI标识来完成的。</p>
<p><strong>2 、命令入队</strong></p>
<p>当一个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执行不同的操作。如果客<br>户端发送的命令为 <em>MULTI</em> 、 <em>EXEC</em> 、 <em>WATCH</em> 、 <em>DISCARD</em> 中的一个，立即执行这个命令，否则将命令放入一<br>个事务队列里面，然后向客户端返回QUEUED回复</p>
<figure class="highlight gauss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果客户端发送的命令为 <span class="built_in">EXEC</span>、DISCARD、WATCH、MULTI 四个命令的其中一个，那么服务器</span><br><span class="line">立即执行这个命令。</span><br><span class="line">如果客户端发送的是四个命令以外的其他命令，那么服务器并不立即执行这个命令。</span><br><span class="line">首先检查此命令的格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的 flags 属</span><br><span class="line">性关闭 REDIS_MULTI 标识，并且返回错误信息给客户端。</span><br><span class="line">如果正确，将这个命令放入一个事务队列里面，然后向客户端返回 QUEUED 回复</span><br></pre></td></tr></tbody></table></figure>
<p>事务队列是按照FIFO的方式保存入队的命令</p>
<p><strong>3 、事务执行</strong></p>
<p>客户端发送 EXEC 命令，服务器执行 EXEC 命令逻辑。</p>
<figure class="highlight oxygene"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果客户端状态的 <span class="keyword">flags</span> 属性不包含 REDIS_MULTI 标识，或者包含 REDIS_DIRTY_CAS 或者</span><br><span class="line">REDIS_DIRTY_EXEC 标识，那么就直接取消事务的执行。</span><br><span class="line">否则客户端处于事务状态（<span class="keyword">flags</span> 有 REDIS_MULTI 标识），服务器会遍历客户端的事务队列，然</span><br><span class="line">后执行事务队列中的所有命令，最后将返回结果全部返回给客户端；</span><br></pre></td></tr></tbody></table></figure>
<p>redis 不支持事务回滚机制，但是它会检查每一个事务中的命令是否错误。</p>
<p>Redis 事务不支持检查那些程序员自己逻辑错误。例如对 String 类型的数据库键执行对 HashMap 类型<br>的操作！</p>
<figure class="highlight smali"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WATCH 命令是一个乐观锁，可以为 Redis 事务提供<span class="built_in"> check-and-set </span>（CAS）行为。可以监控一个</span><br><span class="line">或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC</span><br><span class="line">命令。</span><br><span class="line">MULTI命令用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送</span><br><span class="line">任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有</span><br><span class="line">队列中的命令才会被执行。</span><br><span class="line">EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排</span><br><span class="line">列。当操作被打断时，返回空值 nil 。</span><br><span class="line">通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退</span><br><span class="line">出。</span><br><span class="line">UNWATCH命令可以取消watch对所有key的监控。</span><br></pre></td></tr></tbody></table></figure>
<h2 id="redis集群方案"><a href="#redis集群方案" class="headerlink" title="redis集群方案"></a>redis集群方案</h2><h3 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h3><h3 id="哨兵模式："><a href="#哨兵模式：" class="headerlink" title="哨兵模式："></a>哨兵模式：</h3><p>sentinel，哨兵是 redis 集群中非常重要的一个组件，主要有以下功能：</p>
<figure class="highlight crmsh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">集群监控：负责监控 redis <span class="keyword">master</span> <span class="title">和 slave</span> 进程是否正常工作。</span><br><span class="line">消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</span><br><span class="line">故障转移：如果 <span class="keyword">master</span> <span class="title">node</span> 挂掉了，会自动转移到 <span class="literal">slave</span> <span class="keyword">node</span> <span class="title">上。</span></span><br><span class="line"><span class="title">配置中心：如果故障转移发生了，通知 client</span> 客户端新的 <span class="keyword">master</span> <span class="title">地址。</span></span><br></pre></td></tr></tbody></table></figure>
<p>哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>
<figure class="highlight crmsh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">故障转移时，判断一个 <span class="keyword">master</span> <span class="title">node</span> 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布</span><br><span class="line">式选举</span><br><span class="line">即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的</span><br><span class="line">哨兵通常需要 <span class="number">3</span> 个实例，来保证自己的健壮性。</span><br><span class="line">哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。</span><br><span class="line">对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演</span><br><span class="line">练。</span><br></pre></td></tr></tbody></table></figure>
<p>Redis Cluster是一种服务端Sharding技术，3.0版本开始正式提供。采用slot(槽)的概念，一共分成<br>16384 个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行</p>
<p><strong>方案说明</strong></p>
<figure class="highlight gcode"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽<span class="comment">(哈希值)</span>区间的数据，默认分配了</span><br><span class="line"><span class="number">16384</span> 个槽位</span><br></pre></td></tr></tbody></table></figure>

<h3 id="每份数据分片会存储在多个互为主从的多节点上"><a href="#每份数据分片会存储在多个互为主从的多节点上" class="headerlink" title="每份数据分片会存储在多个互为主从的多节点上"></a>每份数据分片会存储在多个互为主从的多节点上</h3><h3 id="数据写入先写主节点，再同步到从节点-支持配置为阻塞同步"><a href="#数据写入先写主节点，再同步到从节点-支持配置为阻塞同步" class="headerlink" title="数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)"></a>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</h3><h3 id="同一分片多个节点间的数据不保持强一致性"><a href="#同一分片多个节点间的数据不保持强一致性" class="headerlink" title="同一分片多个节点间的数据不保持强一致性"></a>同一分片多个节点间的数据不保持强一致性</h3><figure class="highlight gauss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">读取数据时，当客户端操作的<span class="built_in">key</span>没有分配在该节点上时，redis会返回转向指令，指向正确的节点</span><br><span class="line">扩容时需要需要把旧节点的数据迁移一部分到新节点</span><br></pre></td></tr></tbody></table></figure>
<p>在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379 ，另外一个就是 加1w 的端<br>口号，比如 16379 。</p>
<p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的通信，用来进行故障检测、配置更新、<br>故障转移授权。cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交<br>换，占用更少的网络带宽和处理时间。</p>
<p><strong>优点</strong></p>
<figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">无中心架构，支持动态扩容，对业务透明</span><br><span class="line">具备Sentinel的监控和自动<span class="built_in">Failover</span>(故障转移)能力</span><br><span class="line">客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可</span><br><span class="line">高性能，客户端直连redis服务，免去了proxy代理的损耗</span><br></pre></td></tr></tbody></table></figure>
<p><strong>缺点</strong></p>
<figure class="highlight gcode"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运维也很复杂，数据迁移需要人工干预</span><br><span class="line">只能使用 <span class="number">0</span> 号数据库</span><br><span class="line">不支持批量操作<span class="comment">(pipeline管道操作)</span></span><br><span class="line">分布式逻辑和存储模块耦合等</span><br></pre></td></tr></tbody></table></figure>
<p>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用<br>哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java<br>redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的<br>ShardedJedisPool</p>
<p><strong>优点</strong></p>
<p>优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，<br>非常容易线性扩展，系统的灵活性很强</p>
<p><strong>缺点</strong></p>
<p>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。</p>
<p>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新<br>调整。连接不能共享，当应用规模增大时，资源浪费制约优化</p>
<h2 id="redis-主从复制的核心原理"><a href="#redis-主从复制的核心原理" class="headerlink" title="redis 主从复制的核心原理"></a>redis 主从复制的核心原理</h2><p>通过执行slaveof命令或设置slaveof选项，让一个服务器去复制另一个服务器的数据。主数据库可以进<br>行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接<br>受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数<br>据库。</p>
<p>全量复制：</p>
<p>（ 1 ）主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存(页表复制)、硬<br>盘IO的</p>
<p>（ 2 ）主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗</p>
<p>（ 3 ）从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行<br>bgrewriteaof，也会带来额外的消耗</p>
<p>部分复制：</p>
<figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 复制偏移量：执行复制的双方，主从节点，分别会维护一个复制偏移量offset</span><br><span class="line"><span class="number">2</span>. 复制积压缓冲区：主节点内部维护了一个固定长度的、先进先出(FIFO)队列 作为复制积压缓冲区，</span><br><span class="line">当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</span><br><span class="line"><span class="number">3</span>. 服务器运行<span class="built_in">ID</span>(runid)：每个Redis节点，都有其运行ID，运行ID由节点在启动时自动生成，主节点</span><br><span class="line">会将自己的运行ID发送给从节点，从节点会将主节点的运行ID存起来。 从节点Redis断开重连的时</span><br><span class="line">候，就是根据运行ID来判断同步的进度：</span><br><span class="line">如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继</span><br><span class="line">续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</span><br><span class="line">如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并</span><br><span class="line">不是当前的主节点，只能进行全量复制。</span><br></pre></td></tr></tbody></table></figure>
<p>过程原理：</p>
<h2 id="缓存雪崩、缓存穿透、缓存击穿"><a href="#缓存雪崩、缓存穿透、缓存击穿" class="headerlink" title="缓存雪崩、缓存穿透、缓存击穿"></a>缓存雪崩、缓存穿透、缓存击穿</h2><h3 id="缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内"><a href="#缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内" class="headerlink" title="缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内"></a>缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内</h3><h3 id="承受大量请求而崩掉。"><a href="#承受大量请求而崩掉。" class="headerlink" title="承受大量请求而崩掉。"></a>承受大量请求而崩掉。</h3><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><h3 id="缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。"><a href="#缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。" class="headerlink" title="缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。"></a>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</h3><h3 id="给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓"><a href="#给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓" class="headerlink" title="给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓"></a>给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓</h3><h3 id="存。"><a href="#存。" class="headerlink" title="存。"></a>存。</h3><h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><h3 id="缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承"><a href="#缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承" class="headerlink" title="缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承"></a>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承</h3><h3 id="受大量请求而崩掉。"><a href="#受大量请求而崩掉。" class="headerlink" title="受大量请求而崩掉。"></a>受大量请求而崩掉。</h3><h3 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h3><figure class="highlight xquery"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">接口层增加校验，如用户鉴权校验<span class="built_in">，id</span>做基础校验<span class="built_in">，id</span>&lt;=<span class="number">0</span>的直接拦截；</span><br><span class="line">从缓存取不到的数据，在数据库中也没有取到，这时也可以<span class="built_in">将key</span>-<span class="keyword">value</span>对写<span class="built_in">为key</span>-null，缓存有</span><br><span class="line">效时间可以设置短点，如 <span class="number">30</span> 秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户</span><br><span class="line">反复用同一<span class="built_in">个id</span>暴力攻击</span><br><span class="line">采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据</span><br><span class="line">会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</span><br></pre></td></tr></tbody></table></figure>
<h3 id="缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同"><a href="#缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同" class="headerlink" title="缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同"></a>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同</h3><h3 id="时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪"><a href="#时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪" class="headerlink" title="时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪"></a>时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪</h3><h3 id="崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查"><a href="#崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查" class="headerlink" title="崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查"></a>崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查</h3><h3 id="数据库。"><a href="#数据库。" class="headerlink" title="数据库。"></a>数据库。</h3><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h3 id="设置热点数据永远不过期。"><a href="#设置热点数据永远不过期。" class="headerlink" title="设置热点数据永远不过期。"></a>设置热点数据永远不过期。</h3><h3 id="加互斥锁"><a href="#加互斥锁" class="headerlink" title="加互斥锁"></a>加互斥锁</h3><h1 id="分布式-微服务"><a href="#分布式-微服务" class="headerlink" title="分布式/微服务"></a>分布式/微服务</h1><h2 id="CAP理论，BASE理论"><a href="#CAP理论，BASE理论" class="headerlink" title="CAP理论，BASE理论"></a>CAP理论，BASE理论</h2><p>Consistency (一致性)：</p>
<p>即更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致。</p>
<p>对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。</p>
<p>从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。</p>
<p>Availability (可用性):</p>
<p>即服务一直可用，而且是正常响应时间。系统能够很好的为用户服务，不出现用户操作失败或者访问超<br>时等用户体验不好的情况。</p>
<p>Partition Tolerance (分区容错性):</p>
<p>即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。分<br>区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如<br>现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对<br>于用户而言并没有什么体验上的影响。</p>
<p>CP和AP：分区容错是必须保证的，当发生网络分区的时候，如果要继续服务，那么强一致性和可用性<br>只能 2 选 1</p>
<p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致<br>性）</p>
<p>BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，<br>是基于CAP定理逐步演化而来的。BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以<br>根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<p>基本可用：</p>
<figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">响应时间上的损失: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理</span></span><br><span class="line">用户请求的时间变为 3 s。</span><br><span class="line">系统功能上的损失：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，</span><br><span class="line">系统的部分非核心功能无法使用。</span><br></pre></td></tr></tbody></table></figure>
<p>软状态：数据同步允许一定的延迟</p>
<p>最终一致性：系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态，不要<br>求实时</p>
<h2 id="负载均衡算法、类型"><a href="#负载均衡算法、类型" class="headerlink" title="负载均衡算法、类型"></a>负载均衡算法、类型</h2><h3 id="1-、轮询法"><a href="#1-、轮询法" class="headerlink" title="1 、轮询法"></a>1 、轮询法</h3><h3 id="将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的"><a href="#将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的" class="headerlink" title="将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的"></a>将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的</h3><h3 id="连接数和当前的系统负载。"><a href="#连接数和当前的系统负载。" class="headerlink" title="连接数和当前的系统负载。"></a>连接数和当前的系统负载。</h3><h3 id="2-、随机法"><a href="#2-、随机法" class="headerlink" title="2 、随机法"></a>2 、随机法</h3><h3 id="通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统"><a href="#通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统" class="headerlink" title="通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统"></a>通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统</h3><h3 id="计理论可以得知，随着客户端调用服务端的次数增多，"><a href="#计理论可以得知，随着客户端调用服务端的次数增多，" class="headerlink" title="计理论可以得知，随着客户端调用服务端的次数增多，"></a>计理论可以得知，随着客户端调用服务端的次数增多，</h3><h3 id="其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。"><a href="#其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。" class="headerlink" title="其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。"></a>其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。</h3><h3 id="3-、源地址哈希法"><a href="#3-、源地址哈希法" class="headerlink" title="3 、源地址哈希法"></a>3 、源地址哈希法</h3><h3 id="源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器"><a href="#源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器" class="headerlink" title="源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器"></a>源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器</h3><h3 id="列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均"><a href="#列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均" class="headerlink" title="列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均"></a>列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均</h3><h3 id="衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。"><a href="#衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。" class="headerlink" title="衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。"></a>衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</h3><h3 id="4-、加权轮询法"><a href="#4-、加权轮询法" class="headerlink" title="4 、加权轮询法"></a>4 、加权轮询法</h3><h3 id="不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置"><a href="#不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置" class="headerlink" title="不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置"></a>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置</h3><h3 id="高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权"><a href="#高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权" class="headerlink" title="高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权"></a>高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权</h3><h3 id="重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。"><a href="#重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。" class="headerlink" title="重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。"></a>重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</h3><h3 id="5-、加权随机法"><a href="#5-、加权随机法" class="headerlink" title="5 、加权随机法"></a>5 、加权随机法</h3><h3 id="与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是"><a href="#与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是" class="headerlink" title="与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是"></a>与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是</h3><h3 id="按照权重随机请求后端服务器，而非顺序。"><a href="#按照权重随机请求后端服务器，而非顺序。" class="headerlink" title="按照权重随机请求后端服务器，而非顺序。"></a>按照权重随机请求后端服务器，而非顺序。</h3><h3 id="6-、最小连接数法"><a href="#6-、最小连接数法" class="headerlink" title="6 、最小连接数法"></a>6 、最小连接数法</h3><h3 id="最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根"><a href="#最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根" class="headerlink" title="最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根"></a>最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根</h3><h3 id="据后端服务器当前的连接情况，动态地选取其中当前"><a href="#据后端服务器当前的连接情况，动态地选取其中当前" class="headerlink" title="据后端服务器当前的连接情况，动态地选取其中当前"></a>据后端服务器当前的连接情况，动态地选取其中当前</h3><h3 id="积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分"><a href="#积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分" class="headerlink" title="积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分"></a>积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分</h3><h3 id="流到每一台服务器。"><a href="#流到每一台服务器。" class="headerlink" title="流到每一台服务器。"></a>流到每一台服务器。</h3><h3 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h3><h3 id="DNS-方式实现负载均衡"><a href="#DNS-方式实现负载均衡" class="headerlink" title="DNS 方式实现负载均衡"></a>DNS 方式实现负载均衡</h3><h3 id="硬件负载均衡：F5-和-A10"><a href="#硬件负载均衡：F5-和-A10" class="headerlink" title="硬件负载均衡：F5 和 A10"></a>硬件负载均衡：F5 和 A10</h3><h3 id="软件负载均衡："><a href="#软件负载均衡：" class="headerlink" title="软件负载均衡："></a>软件负载均衡：</h3><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nginx、HAproxy、LVS。其中的区别：</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight mathematica"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Nginx</span>：七层负载均衡，支持 <span class="variable">HTTP</span>、<span class="built_in">E</span><span class="operator">-</span><span class="variable">mail</span> 协议，同时也支持 <span class="number">4</span> 层负载均衡；</span><br><span class="line"><span class="variable">HAproxy</span>：支持七层规则的，性能也很不错。<span class="variable">OpenStack</span> 默认使用的负载均衡软件就是</span><br><span class="line"><span class="variable">HAproxy</span>；</span><br><span class="line"><span class="variable">LVS</span>：运行在内核态，性能是软件负载均衡中最高的，严格来说工作在三层，所以更通用一些，</span><br><span class="line">适用各种应用服务。</span><br></pre></td></tr></tbody></table></figure>
<h2 id="分布式架构下，Session-共享有什么方案"><a href="#分布式架构下，Session-共享有什么方案" class="headerlink" title="分布式架构下，Session 共享有什么方案"></a>分布式架构下，Session 共享有什么方案</h2><p>1 、采用无状态服务，抛弃session</p>
<p>2 、存入cookie（有安全风险）</p>
<p>3 、服务器之间进行 Session 同步，这样可以保证每个服务器上都有全部的 Session 信息，不过当服务<br>器数量比较多的时候，同步是会有延迟甚至同步失败；</p>
<p>4 、 IP 绑定策略</p>
<p>使用 Nginx （或其他复杂均衡软硬件）中的 IP 绑定策略，同一个 IP 只能在指定的同一个机器访问，但<br>是这样做失去了负载均衡的意义，当挂掉一台服务器的时候，会影响一批用户的使用，风险很大；</p>
<p>5 、使用 Redis 存储</p>
<p>把 Session 放到 Redis 中存储，虽然架构上变得复杂，并且需要多访问一次 Redis ，但是这种方案带来<br>的好处也是很大的：</p>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">实现了 <span class="keyword">Session</span> 共享；</span><br><span class="line">可以水平扩展（增加 Redis 服务器）；</span><br><span class="line">服务器重启 <span class="keyword">Session</span> 不丢失（不过也要注意 <span class="keyword">Session</span> 在 Redis 中的刷新/失效机制）；</span><br><span class="line">不仅可以跨服务器 <span class="keyword">Session</span> 共享，甚至可以跨平台（例如网页端和 APP 端）。</span><br></pre></td></tr></tbody></table></figure>
<h2 id="简述你对RPC、RMI的理解"><a href="#简述你对RPC、RMI的理解" class="headerlink" title="简述你对RPC、RMI的理解"></a>简述你对RPC、RMI的理解</h2><p>RPC：在本地调用远程的函数，远程过程调用，可以跨语言实现 httpClient</p>
<p>RMI：远程方法调用，java中用于实现RPC的一种机制，RPC的java版本，是J2EE的网络调用机制，跨<br>JVM调用对象的方法，面向对象的思维方式</p>
<p>直接或间接实现接口 java.rmi.Remote 成为存在于服务器端的远程对象，供客户端访问并提供一定的<br>服务</p>
<p>远程对象必须实现java.rmi.server.UniCastRemoteObject类，这样才能保证客户端访问获得远程对象<br>时，该远程对象将会把自身的一个拷贝以Socket的形式传输给客户端，此时客户端所获得的这个拷贝称<br>为“存根”，而服务器端本身已存在的远程对象则称之为“骨架”。其实此时的存根是客户端的一个代理，<br>用于与服务器端的通信，而骨架也可认为是服务器端的一个代理，用于接收客户端的请求之后调用远程<br>方法来响应客户端的请求。</p>
<figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IService</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">Remote</span></span> </span>{</span><br><span class="line"><span class="keyword">String</span> service(<span class="keyword">String</span> content) throws RemoteException;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="title">implements</span> <span class="title">IService</span> </span>{</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight delphi"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">String</span> <span class="keyword">name</span>;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title class_">ServiceImpl</span>(<span class="title class_">String</span> name) throws <span class="title class_">RemoteException</span> {</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">service</span>(<span class="params"><span class="built_in">String</span> content</span>) {</span><br><span class="line"><span class="keyword">return</span> <span class="string">"server &gt;&gt; "</span> + content;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="分布式id生成方案"><a href="#分布式id生成方案" class="headerlink" title="分布式id生成方案"></a>分布式id生成方案</h2><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">uuid</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>{</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) {</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">IService service02 = <span class="keyword">new</span> <span class="type">ServiceImpl</span>(<span class="string">"service02"</span>);</span><br><span class="line">Context namingContext = <span class="keyword">new</span> <span class="type">InitialContext</span>();</span><br><span class="line">namingContext.rebind(<span class="string">"rmi://127.0.0.1/service02"</span>, service02);</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br><span class="line">System.out.println(<span class="string">"000000！"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">"rmi://127.0.0.1/"</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="type">Context</span> <span class="variable">namingContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line"><span class="type">IService</span> <span class="variable">service02</span> <span class="operator">=</span> (IService) namingContext.lookup(url +</span><br><span class="line"><span class="string">"service02"</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">stubClass</span> <span class="operator">=</span> service02.getClass();</span><br><span class="line">System.out.println(service02 + <span class="string">" is "</span> + stubClass.getName());</span><br><span class="line"><span class="comment">//com.sun.proxy.$Proxy0</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span>[] interfaces = stubClass.getInterfaces();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">Class</span> c : interfaces) {</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println("implement" + c.getName() + " interface");</span><br><span class="line">}</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(service02.service("hello"));</span><br><span class="line">} catch (<span class="keyword">Exception</span> e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="数据库自增序列"><a href="#数据库自增序列" class="headerlink" title="数据库自增序列"></a>数据库自增序列</h3><p>Leaf-segment</p>
<figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>，当前日期和时间 时间戳</span><br><span class="line"><span class="symbol">2 </span>，时钟序列。 计数器</span><br><span class="line"><span class="symbol">3 </span>，全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">优点：代码简单，性能好（本地生成，没有网络消耗），保证唯一（相对而言，重复概率极低可以忽</span><br><span class="line">略）</span><br><span class="line">缺点：</span><br><span class="line">每次生成的ID都是无序的，而且不是全数字，且无法保证趋势递增。</span><br><span class="line"><span class="type">UUID</span>生成的是字符串，字符串存储性能差，查询效率慢，写的时候由于不能产生顺序的append</span><br><span class="line">操作，需要进 行<span class="keyword">insert</span>操作，导致频繁的页分裂，这种操作在记录占用空间比较大的情况下，性</span><br><span class="line">能下降比较大，还会增加读 取磁盘次数</span><br><span class="line"><span class="type">UUID</span>长度过长，不适用于存储，耗费数据库性能。</span><br><span class="line">ID无一定业务含义，可读性差。</span><br><span class="line">有信息安全问题，有可能泄露mac地址</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">单机模式：</span><br><span class="line">优点：</span><br><span class="line">实现简单，依靠数据库即可，成本小。</span><br><span class="line">ID数字化，单调自增，满足数据库存储和查询性能。</span><br><span class="line">具有一定的业务可读性。（结合业务<span class="built_in">code</span>）</span><br><span class="line">缺点：</span><br><span class="line">强依赖<span class="built_in">DB</span>，存在单点问题，如果数据库宕机，则业务不可用。</span><br><span class="line"><span class="built_in">DB</span>生成ID性能有限，单点数据库压力大，无法扛高并发场景。</span><br><span class="line">信息安全问题，比如暴露订单量，url查询改一下id查到别人的订单</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight crmsh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">数据库高可用：多主模式做负载，基于序列的起始值和步长设置，不同的初始值，相同的步长，步长大</span><br><span class="line">于节点数</span><br><span class="line">优点：</span><br><span class="line">解决了ID生成的单点问题，同时平衡了负载。</span><br><span class="line">缺点：</span><br><span class="line">系统扩容困难：系统定义好步长之后，增加机器之后调整步长困难。</span><br><span class="line">数据库压力大：每次获取一个ID都必须读写一次数据库。</span><br><span class="line">主从同步的时候：电商下单-&gt;支付insert <span class="keyword">master</span> <span class="title">db</span> select数据 ，因为数据同步延迟导致</span><br><span class="line">查不到这个数 据。加cache(不是最好的解决方式)数据要求比较严谨的话查<span class="literal">master</span>主库。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight autoit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">采用每次获取一个ID区间段的方式来解决，区间段用完之后再去数据库获取新的号段，这样一来可以大</span><br><span class="line">大减轻数据库的压力</span><br><span class="line">核心字段：biz_tag，max_id，<span class="keyword">step</span></span><br><span class="line">biz_tag用来区分业务，max_id表示该biz_tag目前所被分配的ID号段的最大值，<span class="keyword">step</span>表示每次分配</span><br><span class="line">的号段长度，原来每次获取ID都要访问数据库，现在只需要把<span class="keyword">Step</span>设置的足够合理如 <span class="number">1000</span> ，那么现在</span><br><span class="line">可以在 <span class="number">1000</span> 个ID用完之后再去访问数据库</span><br><span class="line">优点：</span><br><span class="line">扩张灵活，性能强能够撑起大部分业务场景。</span><br><span class="line">ID号码是趋势递增的，满足数据库存储和查询性能要求。</span><br><span class="line">可用性高，即使ID生成服务器不可用，也能够使得业务在短时间内可用，为排查问题争取时间。</span><br><span class="line">缺点：</span><br><span class="line">可能存在多个节点同时请求ID区间的情况，依赖DB</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基于redis、mongodb、zk等中间件生成</span><br><span class="line">雪花算法</span><br></pre></td></tr></tbody></table></figure>
<h2 id="分布式锁解决方案"><a href="#分布式锁解决方案" class="headerlink" title="分布式锁解决方案"></a>分布式锁解决方案</h2><h3 id="需要这个锁独立于每一个服务之外，而不是在服务里面。"><a href="#需要这个锁独立于每一个服务之外，而不是在服务里面。" class="headerlink" title="需要这个锁独立于每一个服务之外，而不是在服务里面。"></a>需要这个锁独立于每一个服务之外，而不是在服务里面。</h3><h3 id="数据库：利用主键冲突控制一次只有一个线程能获取锁，非阻塞、不可重入、单点、失效时间"><a href="#数据库：利用主键冲突控制一次只有一个线程能获取锁，非阻塞、不可重入、单点、失效时间" class="headerlink" title="数据库：利用主键冲突控制一次只有一个线程能获取锁，非阻塞、不可重入、单点、失效时间"></a>数据库：利用主键冲突控制一次只有一个线程能获取锁，非阻塞、不可重入、单点、失效时间</h3><p>Zookeeper分布式锁：</p>
<p>Redis分布式锁：setNX，单线程处理网络请求，不需要考虑并发安全性</p>
<p>所有服务节点设置相同的key，返回为 0 、则锁获取失败</p>
<figure class="highlight arcade"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">双<span class="built_in">buffer</span>：将获取一个号段的方式优化成获取两个号段，在一个号段用完之后不用立马去更新号段，还</span><br><span class="line">有一个缓存号段备用，这样能够有效解决这种冲突问题，而且采用双<span class="built_in">buffer</span>的方式，在当前号段消耗了</span><br><span class="line"><span class="number">10</span> %的时候就去检查下一个号段有没有准备好，如果没有准备好就去更新下一个号段，当当前号段用完了</span><br><span class="line">就切换到下一个已经缓存好的号段去使用，同时在下一个号段消耗到 <span class="number">10</span> %的时候，又去检测下一个号段有</span><br><span class="line">没有准备好，如此往复。</span><br><span class="line">优点：</span><br><span class="line">基于JVM存储双<span class="built_in">buffer</span>的号段，减少了数据库查询，减少了网络依赖，效率更高。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight autoit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">缺点：</span><br><span class="line">segment号段长度是固定的，业务量大时可能会频繁更新号段，因为原本分配的号段会一下用完</span><br><span class="line">如果号段长度设置的过长，但凡缓存中有号段没有消耗完，其他节点重新获取的号段与之前相比可</span><br><span class="line">能跨度会很 大。动态调整<span class="keyword">Step</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">生成一个64bit的整性数字</span><br><span class="line">第一位符号位固定为<span class="number"> 0 </span>，<span class="number"> 41 </span>位时间戳，<span class="number"> 10 </span>位workId，<span class="number"> 12 </span>位序列号</span><br><span class="line">位数可以有不同实现</span><br><span class="line">优点：</span><br><span class="line">每个毫秒值包含的ID值很多，不够可以变动位数来增加，性能佳（依赖workId的实现）。</span><br><span class="line">时间戳值在高位，中间是固定的机器码，自增的序列在低位，整个ID是趋势递增的。</span><br><span class="line">能够根据业务场景数据库节点布置灵活挑战bit位划分，灵活度高。</span><br><span class="line">缺点：</span><br><span class="line">强依赖于机器时钟，如果时钟回拨，会导致重复的ID生成，所以一般基于此的算法发现时钟回拨，</span><br><span class="line">都会抛异常处 理，阻止ID生成，这可能导致服务不可用。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zk通过临时节点，解决了死锁的问题，一旦客户端获取到锁之后突然挂掉（<span class="keyword">Session</span>连接断开），那么这个临</span><br><span class="line">时节点就会自动删除掉，其他客户端自动获取锁。临时顺序节点解决惊群效应</span><br></pre></td></tr></tbody></table></figure>

<h3 id="删除锁：判断线程唯一标志，再删除"><a href="#删除锁：判断线程唯一标志，再删除" class="headerlink" title="删除锁：判断线程唯一标志，再删除"></a>删除锁：判断线程唯一标志，再删除</h3><p>可重入性及锁续期没有实现，通过redisson解决（类似AQS的实现，看门狗监听机制）</p>
<p>redlock：意思的机制都只操作单节点、即使Redis通过sentinel保证高可用，如果这个master节点由于<br>某些原因发生了主从切换，那么就会出现锁丢失的情况（redis同步设置可能数据丢失）。redlock从多<br>个节点申请锁，当一半以上节点获取成功、锁才算获取成功，redission有相应的实现</p>
<h2 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h2><h3 id="XA规范：分布式事务规范，定义了分布式事务模型"><a href="#XA规范：分布式事务规范，定义了分布式事务模型" class="headerlink" title="XA规范：分布式事务规范，定义了分布式事务模型"></a>XA规范：分布式事务规范，定义了分布式事务模型</h3><h3 id="四个角色：事务管理器-协调者TM-、资源管理器-参与者RM-，应用程序AP，通信资源管理器CRM"><a href="#四个角色：事务管理器-协调者TM-、资源管理器-参与者RM-，应用程序AP，通信资源管理器CRM" class="headerlink" title="四个角色：事务管理器(协调者TM)、资源管理器(参与者RM)，应用程序AP，通信资源管理器CRM"></a>四个角色：事务管理器(协调者TM)、资源管理器(参与者RM)，应用程序AP，通信资源管理器CRM</h3><h3 id="全局事务：一个横跨多个数据库的事务，要么全部提交、要么全部回滚"><a href="#全局事务：一个横跨多个数据库的事务，要么全部提交、要么全部回滚" class="headerlink" title="全局事务：一个横跨多个数据库的事务，要么全部提交、要么全部回滚"></a>全局事务：一个横跨多个数据库的事务，要么全部提交、要么全部回滚</h3><p>JTA事务时java对XA规范的实现，对应JDBC的单库事务</p>
<h3 id="两阶段协议："><a href="#两阶段协议：" class="headerlink" title="两阶段协议："></a>两阶段协议：</h3><p>第一阶段（ prepare ） ：每个参与者执行本地事务但不提交，进入 ready 状态，并通知协调者已经准<br>备就绪。</p>
<figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">setnx</span></span><br><span class="line">问题：</span><br><span class="line">&nbsp;<span class="number">1</span> 、早期版本没有超时参数，需要单独设置，存在死锁问题（中途宕机）</span><br><span class="line">&nbsp;<span class="number">2</span> 、后期版本提供加锁与设置时间原子操作，但是存在任务超时，锁自动释放，导致并发问题，加锁与释</span><br><span class="line">放锁不是同一线程问题</span><br></pre></td></tr></tbody></table></figure>

<p>第二阶段（ commit ） 当协调者确认每个参与者都 ready 后，通知参与者进行 commit 操作；如果有<br>参与者 fail ，则发送 rollback 命令，各参与者做回滚。</p>
<p>问题：</p>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单点故障：一旦事务管理器出现故障，整个系统不可用（参与者都会阻塞住）</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数据不一致：在阶段二，如果事务管理器只发送了部分 <span class="keyword">commit</span> 消息，此时网络发生异常，那么</span><br><span class="line">只有部分参与者接收到 <span class="keyword">commit</span> 消息，也就是说只有部分参与者提交了事务，使得系统数据不一</span><br><span class="line">致。</span><br><span class="line">响应时间较长：参与者和协调者资源都被锁住，提交或者回滚之后才能释放</span><br><span class="line">不确定性：当协事务管理器发送 <span class="keyword">commit</span> 之后，并且此时只有一个参与者收到了 <span class="keyword">commit</span>，那么当</span><br><span class="line">该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。</span><br></pre></td></tr></tbody></table></figure>
<h3 id="三阶段协议：主要是针对两阶段的优化，解决了2PC单点故障的问题，但是性能问题和不一致问题仍然"><a href="#三阶段协议：主要是针对两阶段的优化，解决了2PC单点故障的问题，但是性能问题和不一致问题仍然" class="headerlink" title="三阶段协议：主要是针对两阶段的优化，解决了2PC单点故障的问题，但是性能问题和不一致问题仍然"></a>三阶段协议：主要是针对两阶段的优化，解决了2PC单点故障的问题，但是性能问题和不一致问题仍然</h3><h3 id="没有根本解决"><a href="#没有根本解决" class="headerlink" title="没有根本解决"></a>没有根本解决</h3><p>引入了超时机制解决参与者阻塞的问题，超时后本地提交，2pc只有协调者有超时机制</p>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一阶段：CanCommit阶段，协调者询问事务参与者，是否有能力完成此次事务。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight gams"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果都返回<span class="keyword">yes</span>，则进入第二阶段</span><br><span class="line">有一个返回<span class="keyword">no</span>或等待响应超时，则中断事务，并向所有参与者发送<span class="keyword">abort</span>请求</span><br><span class="line">第二阶段：PreCommit阶段，此时协调者会向所有的参与者发送PreCommit请求，参与者收到后</span><br><span class="line">开始执行事务操作。参与者执行完事务操作后（此时属于未提交事务的状态），就会向协调者反馈</span><br><span class="line">“Ack”表示我已经准备好提交了，并等待协调者的下一步指令。</span><br><span class="line">第三阶段：DoCommit阶段， 在阶段二中如果所有的参与者节点都返回了Ack，那么协调者就会从</span><br><span class="line">“预提交状态”转变为“提交状态”。然后向所有的参与者节点发送<span class="string">"doCommit"</span>请求，参与者节点在</span><br><span class="line">收到提交请求后就会各自执行事务提交操作，并向协调者节点反馈“Ack”消息，协调者收到所有参</span><br><span class="line">与者的Ack消息后完成事务。 相反，如果有一个参与者节点未完成PreCommit的反馈或者反馈超</span><br><span class="line">时，那么协调者都会向所有的参与者节点发送<span class="keyword">abort</span>请求，从而中断事务。</span><br></pre></td></tr></tbody></table></figure>

<p>TCC（补偿事务）：Try、Confirm、Cancel</p>
<p>针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作</p>
<p>Try操作做业务检查及资源预留，Confirm做业务确认操作，Cancel实现一个与Try相反的操作既回滚操<br>作。TM首先发起所有的分支事务的try操作，任何一个分支事务的try操作执行失败，TM将会发起所有<br>分支事务的Cancel操作，若try操作全部成功，TM将会发起所有分支事务的Confirm操作，其中<br>Confirm/Cancel操作若执行失败，TM会进行重试。</p>
<p>TCC模型对业务的侵入性较强，改造的难度较大，每个操作都需要有 try、confirm、cancel三个接<br>口实现</p>
<figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">confirm 和 <span class="built_in">cancel</span> 接口还必须实现幂等性。</span><br></pre></td></tr></tbody></table></figure>
<h3 id="消息队列的事务消息："><a href="#消息队列的事务消息：" class="headerlink" title="消息队列的事务消息："></a>消息队列的事务消息：</h3><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发送prepare消息到消息中间件</span><br><span class="line">发送成功后，执行本地事务</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果事务执行成功，则<span class="keyword">commit</span>，消息中间件将消息下发至消费端（<span class="keyword">commit</span>前，消息不会被</span><br><span class="line">消费）</span><br><span class="line">如果事务执行失败，则回滚，消息中间件将这条<span class="keyword">prepare</span>消息删除</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">消费端接收到消息进行消费，如果消费失败，则不断重试</span><br></pre></td></tr></tbody></table></figure>
<h2 id="如何实现接口的幂等性"><a href="#如何实现接口的幂等性" class="headerlink" title="如何实现接口的幂等性"></a>如何实现接口的幂等性</h2><figure class="highlight gauss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">唯一id。每次操作，都根据操作和内容生成唯一的id，在执行之前先判断id是否存在，如果不存在</span><br><span class="line">则执行后续操作，并且保存到数据库或者redis等。</span><br><span class="line">服务端提供发送<span class="built_in">token</span>的接口，业务调用接口前先获取<span class="built_in">token</span>,然后调用业务接口请求时，把<span class="built_in">token</span></span><br><span class="line">携带过去,务器判断<span class="built_in">token</span>是否存在redis中，存在表示第一次请求，可以继续执行业务，执行业务</span><br><span class="line">完成后，最后需要把redis中的<span class="built_in">token</span>删除</span><br><span class="line">建去重表。将业务中有唯一标识的字段保存到去重表，如果表中存在，则表示已经处理过了</span><br><span class="line">版本控制。增加版本号，当版本号符合时，才能更新数据</span><br><span class="line">状态控制。例如订单有状态已支付 未支付 支付中 支付失败，当处于未支付的时候才允许修改为支</span><br><span class="line">付中等</span><br></pre></td></tr></tbody></table></figure>
<h2 id="简述ZAB-协议"><a href="#简述ZAB-协议" class="headerlink" title="简述ZAB 协议"></a>简述ZAB 协议</h2><p>ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持崩溃恢复的原子广播协议，实现分布式<br>数据一致性</p>
<p>所有客户端的请求都是写入到 Leader 进程中，然后，由 Leader 同步到其他节点，称为 Follower。在<br>集群数据同步的过程中，如果出现 Follower 节点崩溃或者 Leader 进程崩溃时，都会通过 Zab 协议来<br>保证数据一致性</p>
<p>ZAB 协议包括两种基本的模式： <strong>崩溃恢复和消息广播</strong> 。</p>
<p><strong>消息广播</strong> ：</p>
<p>集群中所有的事务请求都由 Leader 节点来处理，其他服务器为 Follower，Leader 将客户端的事务请<br>求转换为事务 Proposal，并且将 Proposal 分发给集群中其他所有的 Follower。</p>
<p>完成广播之后，Leader 等待 Follwer 反馈，当有过半数的 Follower 反馈信息后，Leader 将再次向集<br>群内 Follower 广播 Commit 信息，Commit 信息就是确认将之前的 Proposal 提交。</p>
<p>Leader 节点的写入是一个两步操作，第一步是广播事务操作，第二步是广播提交操作，其中过半数指<br>的是反馈的节点数 &gt;=N/2+1，N 是全部的 Follower 节点数量。</p>
<h3 id="崩溃恢复-："><a href="#崩溃恢复-：" class="headerlink" title="崩溃恢复 ："></a>崩溃恢复 ：</h3><h3 id="初始化集群，刚刚启动的时候"><a href="#初始化集群，刚刚启动的时候" class="headerlink" title="初始化集群，刚刚启动的时候"></a>初始化集群，刚刚启动的时候</h3><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Leader</span> 崩溃，因为故障宕机</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Leader</span> 失去了半数的机器支持，与集群中超过一半的节点断连</span><br></pre></td></tr></tbody></table></figure>
<p>此时开启新一轮 Leader 选举，选举产生的 Leader 会与过半的 Follower 进行同步，使数据一致，当与<br>过半的机器同步完成后，就退出恢复模式， 然后进入消息广播模式</p>
<p>整个 ZooKeeper 集群的一致性保证就是在上面两个状态之前切换，当 Leader 服务正常时，就是正常<br>的消息广播模式；当 Leader 不可用时，则进入崩溃恢复模式，崩溃恢复阶段会进行数据同步，完成以<br>后，重新进入消息广播阶段。</p>
<p><strong>Zxid</strong> 是 Zab 协议的一个事务编号，Zxid 是一个 64 位的数字，其中低 32 位是一个简单的单调递增计数<br>器，针对客户端每一个事务请求，计数器加 1 ；而高 32 位则代表 Leader 周期年代的编号。</p>
<p>Leader 周期（ epoch），可以理解为当前集群所处的年代或者周期，每当有一个新的 Leader 选举出<br>现时，就会从这个 Leader 服务器上取出其本地日志中最大事务的 Zxid，并从中读取 epoch 值，然后<br>加 1 ，以此作为新的周期 ID。高 32 位代表了每代 Leader 的唯一性，低 32 位则代表了每代 Leader 中<br>事务的唯一性。</p>
<p><strong>zab节点的三种状态</strong> ：</p>
<p>following：服从leader的命令</p>
<p>leading：负责协调事务</p>
<p>election/looking：选举状态</p>
<h2 id="zk的数据模型和节点类型"><a href="#zk的数据模型和节点类型" class="headerlink" title="zk的数据模型和节点类型"></a>zk的数据模型和节点类型</h2><h3 id="数据模型：树形结构"><a href="#数据模型：树形结构" class="headerlink" title="数据模型：树形结构"></a>数据模型：树形结构</h3><p>zk维护的数据主要有：客户端的会话（session）状态及数据节点（dataNode）信息。</p>
<p>zk在内存中构造了个DataTree的数据结构，维护着path到dataNode的映射以及dataNode间的树状层<br>级关系。为了提高读取性能，集群中每个服务节点都是将数据全量存储在内存中。所以，zk最适于读多<br>写少且轻量级数据的应用场景。</p>
<p>数据仅存储在内存是很不安全的，zk采用事务日志文件及快照文件的方案来落盘数据，保障数据在不丢<br>失的情况下能快速恢复。</p>
<p>树中的每个节点被称为— Znode</p>
<p>Znode 兼具文件和目录两种特点。可以做路径标识，也可以存储数据，并可以具有子 Znode。具有<br>增、删、改、查等操作。</p>
<p>Znode 具有原子性操作，读操作将获取与节点相关的所有数据，写操作也将 替换掉节点的所有数据。<br>另外，每一个节点都拥有自己的 ACL(访问控制列 表)，这个列表规定了用户的权限，即限定了特定用户<br>对目标节点可以执行的操作</p>
<p>Znode 存储数据大小有限制。每个 Znode 的数据大小至多 1M，常规使用中应该远小于此值。</p>
<p>Znode 通过路径引用，如同 Unix 中的文件路径。路径必须是绝对的，因此他们必须由斜杠字符来开<br>头。除此以外，他们必须是唯一的，也就是说每一个路径只有一个表示，因此这些路径不能改变。在<br>ZooKeeper 中，路径由 Unicode 字符串组成，并且有一些限制。字符串”/zookeeper”用以保存管理信<br>息，比如关键配额信息。</p>
<p>持久节点：一旦创建、该数据节点会一直存储在zk服务器上、即使创建该节点的客户端与服务端的会话<br>关闭了、该节点也不会被删除</p>
<p>临时节点：当创建该节点的客户端会话因超时或发生异常而关闭时、该节点也相应的在zk上被删除 。</p>
<p>有序节点：不是一种单独种类的节点、而是在持久节点和临时节点的基础上、增加了一个节点有序的性<br>质 。</p>
<h2 id="简述zk的命名服务、配置管理、集群管理"><a href="#简述zk的命名服务、配置管理、集群管理" class="headerlink" title="简述zk的命名服务、配置管理、集群管理"></a>简述zk的命名服务、配置管理、集群管理</h2><h3 id="命名服务："><a href="#命名服务：" class="headerlink" title="命名服务："></a>命名服务：</h3><p>通过指定的名字来获取资源或者服务地址。Zookeeper可以创建一个全局唯一的路径，这个路径就可以<br>作为一个名字。被命名的实体可以是集群中的机器，服务的地址，或者是远程的对象等。一些分布式服<br>务框架（RPC、RMI）中的服务地址列表，通过使用命名服务，客户端应用能够根据特定的名字来获取<br>资源的实体、服务地址和提供者信息等</p>
<p>配置管理：</p>
<p>实际项目开发中，经常使用.properties或者xml需要配置很多信息，如数据库连接信息、fps地址端口等<br>等。程序分布式部署时，如果把程序的这些配置信息保存在zk的znode节点下，当你要修改配置，即<br>znode会发生变化时，可以通过改变zk中某个目录节点的内容，利用watcher通知给各个客户端，从而<br>更改配置。</p>
<p>集群管理：</p>
<p>集群管理包括集群监控和集群控制，就是监控集群机器状态，剔除机器和加入机器。zookeeper可以方<br>便集群机器的管理，它可以实时监控znode节点的变化，一旦发现有机器挂了，该机器就会与zk断开连<br>接，对应的临时目录节点会被删除，其他所有机器都收到通知。新机器加入也是类似。</p>
<h2 id="讲下Zookeeper-watch机制"><a href="#讲下Zookeeper-watch机制" class="headerlink" title="讲下Zookeeper watch机制"></a>讲下Zookeeper watch机制</h2><p>客户端，可以通过在znode上设置watch，实现实时监听znode的变化</p>
<p>Watch事件是一个一次性的触发器，当被设置了Watch的数据发生了改变的时候，则服务器将这个改变<br>发送给设置了Watch的客户端</p>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父节点的创建，修改，删除都会触发Watcher事件。</span><br><span class="line">子节点的创建，删除会触发Watcher事件。</span><br></pre></td></tr></tbody></table></figure>
<p>一次性：一旦被触发就会移除，再次使用需要重新注册，因为每次变动都需要通知所有客户端，一次性<br>可以减轻压力，3.6.0默认持久递归，可以触发多次</p>
<p>轻量：只通知发生了事件，不会告知事件内容，减轻服务器和带宽压力</p>
<p>Watcher 机制包括三个角色：客户端线程、客户端的 WatchManager 以及 ZooKeeper 服务器</p>
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 客户端向 ZooKeeper 服务器注册一个 Watcher 监听，</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">2.</span> 把这个监听信息存储到客户端的 WatchManager 中</span><br><span class="line"><span class="bullet">3.</span> 当 ZooKeeper 中的节点发生变化时，会通知客户端，客户端会调用相应 Watcher 对象中的回调</span><br><span class="line">方法。watch回调是串行同步的</span><br></pre></td></tr></tbody></table></figure>
<h2 id="zk和eureka的区别"><a href="#zk和eureka的区别" class="headerlink" title="zk和eureka的区别"></a>zk和eureka的区别</h2><p>zk：CP设计(强一致性)，目标是一个分布式的协调系统，用于进行资源的统一管理。</p>
<p>当节点crash后，需要进行leader的选举，在这个期间内，zk服务是不可用的。</p>
<p>eureka：AP设计（高可用），目标是一个服务注册发现系统，专门用于微服务的服务发现注册。</p>
<p>Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和<br>查询服务。而Eureka的客户端在向某个Eureka注册时如果发现连接失败，会自动切换至其他节点，只<br>要有一台Eureka还在，就能保证注册服务可用（保证可用性），只不过查到的信息可能不是最新的（不<br>保证强一致性）</p>
<p>同时当eureka的服务端发现85%以上的服务都没有心跳的话，它就会认为自己的网络出了问题，就不会<br>从服务列表中删除这些失去心跳的服务，同时eureka的客户端也会缓存服务信息。eureka对于服务注<br>册发现来说是非常好的选择。</p>
<h2 id="Spring-Cloud和Dubbo的区别"><a href="#Spring-Cloud和Dubbo的区别" class="headerlink" title="Spring Cloud和Dubbo的区别"></a>Spring Cloud和Dubbo的区别</h2><p>底层协议：springcloud基于http协议，dubbo基于Tcp协议，决定了dubbo的性能相对会比较好</p>
<p>注册中心：Spring Cloud 使用的 eureka ，dubbo推荐使用zookeeper</p>
<p>模型定义：dubbo 将一个接口定义为一个服务，SpringCloud 则是将一个应用定义为一个服务</p>
<p>SpringCloud是一个生态，而Dubbo是SpringCloud生态中关于服务调用一种解决方案（服务治理）</p>
<h2 id="什么是Hystrix？简述实现机制"><a href="#什么是Hystrix？简述实现机制" class="headerlink" title="什么是Hystrix？简述实现机制"></a>什么是Hystrix？简述实现机制</h2><h3 id="分布式容错框架"><a href="#分布式容错框架" class="headerlink" title="分布式容错框架"></a>分布式容错框架</h3><h3 id="阻止故障的连锁反应，实现熔断"><a href="#阻止故障的连锁反应，实现熔断" class="headerlink" title="阻止故障的连锁反应，实现熔断"></a>阻止故障的连锁反应，实现熔断</h3><h3 id="快速失败，实现优雅降级"><a href="#快速失败，实现优雅降级" class="headerlink" title="快速失败，实现优雅降级"></a>快速失败，实现优雅降级</h3><h3 id="提供实时的监控和告警"><a href="#提供实时的监控和告警" class="headerlink" title="提供实时的监控和告警"></a>提供实时的监控和告警</h3><h3 id="资源隔离：线程隔离，信号量隔离"><a href="#资源隔离：线程隔离，信号量隔离" class="headerlink" title="资源隔离：线程隔离，信号量隔离"></a>资源隔离：线程隔离，信号量隔离</h3><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程隔离：Hystrix会给每一个<span class="keyword">Command</span>分配一个单独的线程池，这样在进行单个服务调用的时</span><br><span class="line">候，就可以在独立的线程池里面进行，而不会对其他线程池造成影响</span><br></pre></td></tr></tbody></table></figure>

<h3 id="信号量隔离：客户端需向依赖服务发起请求时，首先要获取一个信号量才能真正发起调用，由于信"><a href="#信号量隔离：客户端需向依赖服务发起请求时，首先要获取一个信号量才能真正发起调用，由于信" class="headerlink" title="信号量隔离：客户端需向依赖服务发起请求时，首先要获取一个信号量才能真正发起调用，由于信"></a>信号量隔离：客户端需向依赖服务发起请求时，首先要获取一个信号量才能真正发起调用，由于信</h3><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">号量的数量有限，当并发请求量超过信号量个数时，后续的请求都会直接拒绝，进入fallback流</span><br><span class="line">程。信号量隔离主要是通过控制并发请求量，防止请求线程大面积阻塞，从而达到限流和防止雪崩</span><br><span class="line">的目的。</span><br></pre></td></tr></tbody></table></figure>
<h3 id="熔断和降级：调用服务失败后快速失败"><a href="#熔断和降级：调用服务失败后快速失败" class="headerlink" title="熔断和降级：调用服务失败后快速失败"></a>熔断和降级：调用服务失败后快速失败</h3><h3 id="熔断是为了防止异常不扩散，保证系统的稳定性"><a href="#熔断是为了防止异常不扩散，保证系统的稳定性" class="headerlink" title="熔断是为了防止异常不扩散，保证系统的稳定性"></a>熔断是为了防止异常不扩散，保证系统的稳定性</h3><h3 id="降级：编写好调用失败的补救逻辑，然后对服务直接停止运行，这样这些接口就无法正常调用，但又不"><a href="#降级：编写好调用失败的补救逻辑，然后对服务直接停止运行，这样这些接口就无法正常调用，但又不" class="headerlink" title="降级：编写好调用失败的补救逻辑，然后对服务直接停止运行，这样这些接口就无法正常调用，但又不"></a>降级：编写好调用失败的补救逻辑，然后对服务直接停止运行，这样这些接口就无法正常调用，但又不</h3><h3 id="至于直接报错，只是服务水平下降"><a href="#至于直接报错，只是服务水平下降" class="headerlink" title="至于直接报错，只是服务水平下降"></a>至于直接报错，只是服务水平下降</h3><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">通过HystrixCommand 或者HystrixObservableCommand 将所有的外部系统（或者称为依赖）</span><br><span class="line">包装起来，整个包装对象是单独运行在一个线程之中（这是典型的命令模式）。</span><br><span class="line">超时请求应该超过你定义的阈值</span><br><span class="line">为每个依赖关系维护一个小的线程池（或信号量）<span class="comment">; 如果它变满了，那么依赖关系的请求将立即被</span></span><br><span class="line">拒绝，而不是排队等待。</span><br><span class="line">统计成功，失败（由客户端抛出的异常），超时和线程拒绝。</span><br><span class="line">打开断路器可以在一段时间内停止对特定服务的所有请求，如果服务的错误百分比通过阈值，手动</span><br><span class="line">或自动的关闭断路器。</span><br><span class="line">当请求被拒绝、连接超时或者断路器打开，直接执行fallback逻辑。</span><br><span class="line">近乎实时监控指标和配置变化。</span><br></pre></td></tr></tbody></table></figure>
<h2 id="springcloud核心组件及其作用"><a href="#springcloud核心组件及其作用" class="headerlink" title="springcloud核心组件及其作用"></a>springcloud核心组件及其作用</h2><p>Eureka：服务注册与发现</p>
<p>注册：每个服务都向Eureka登记自己提供服务的元数据，包括服务的ip地址、端口号、版本号、通信协<br>议等。eureka将各个服务维护在了一个服务清单中（双层Map，第一层key是服务名，第二层key是实<br>例名，value是服务地址加端口）。同时对服务维持心跳，剔除不可用的服务，eureka集群各节点相互<br>注册每个实例中都有一样的服务清单。</p>
<p>发现：eureka注册的服务之间调用不需要指定服务地址，而是通过服务名向注册中心咨询，并获取所有<br>服务实例清单(缓存到本地)，然后实现服务的请求访问。</p>
<p>Ribbon：服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台 （被调<br>用方的服务地址有多个），Ribbon也是通过发起http请求，来进行的调用，只不过是通过调用服务名的<br>地址来实现的。虽然说Ribbon不用去具体请求服务实例的ip地址或域名了，但是每调用一个接口都还要<br>手动去发起Http请求</p>
<p>Feign：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求 ，简化服务<br>间的调用，在Ribbon的基础上进行了进一步的封装。单独抽出了一个组件，就是Spring Cloud Feign。<br>在引入Spring Cloud Feign后，我们只需要创建一个接口并用注解的方式来配置它，即可完成对服务提<br>供方的接口绑定。</p>
<p>调用远程就像调用本地服务一样</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerController</span> {</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestTemplate restTemplate;</span><br><span class="line"><span class="meta">@GetMapping(<span class="string">"/ribbon-consumer"</span>)</span></span><br><span class="line"><span class="keyword">public</span> String helloConsumer(){</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">restTemplate.getForEntity(<span class="string">"http://exampleservice/index"</span>,String.<span class="keyword">class</span>).getBody();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> {</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getUser"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">getUser</span>(<span class="params"></span>){</span><br><span class="line"><span class="title class_">List</span>&lt;<span class="title class_">String</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">"张三"</span>);</span><br><span class="line"><span class="title class_">String</span> json = <span class="title class_">JSON</span>.<span class="title function_">toJSONString</span>(list);</span><br><span class="line"><span class="keyword">return</span> json;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = <span class="string">"user"</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> {</span><br><span class="line"><span class="meta">@GetMapping(<span class="string">"/getUser"</span>)</span></span><br><span class="line">String getUser();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Hystrix：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用<br>的隔离，通过统计接口超时次数返回默认值，实现服务熔断和降级</p>
<p>Zuul：如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务，<br>通过与Eureka进行整合，将自身注册为Eureka下的应用，从Eureka下获取所有服务的实例，来进行服<br>务的路由。Zuul还提供了一套过滤器机制，开发者可以自己指定哪些规则的请求需要执行校验逻辑，只<br>有通过校验逻辑的请求才会被路由到具体服务实例上，否则返回错误提示。</p>
<h2 id="Dubbo-的整体架构设计及分层"><a href="#Dubbo-的整体架构设计及分层" class="headerlink" title="Dubbo 的整体架构设计及分层"></a>Dubbo 的整体架构设计及分层</h2><h3 id="五个角色："><a href="#五个角色：" class="headerlink" title="五个角色："></a>五个角色：</h3><p>注册中心registry：服务注册与发现<br>服务提供者provider：暴露服务<br>服务消费者consumer：调用远程服务<br>监控中心monitor：统计服务的调用次数和调用时间<br>容器container：服务允许容器</p>
<p>调用流程：</p>
<p>1 ：container容器负责启动、加载、运行provider<br>2 ：provider在启动时，向regisitry中心注册自己提供的服务<br>3 ：consumer在启动时，向regisitry中心订阅自己所需的服务<br>4 ：regisitry返回服务提供者列表给consumer，如果有变更，registry将基于长连接推送变更数据给<br>consumer<br>5 ：consumer调用provider服务，基于负载均衡算法进行调用<br>6 ：consumer调用provider的统计，基于短链接定时每分钟一次统计到monitor</p>
<p>分层：</p>
<p>接口服务层（ Service）：面向开发者，业务代码、接口、实现等</p>
<p>配置层（ Config）：对外配置接口，以 ServiceConfig 和 ReferenceConfig 为中心</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> {</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line">UserClient userClient;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">test</span>(<span class="params"></span>){</span><br><span class="line"><span class="title class_">String</span> user = userClient.<span class="title function_">getUser</span>();</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>服务代理层（ Proxy）：对生产者和消费者、dubbo都会产生一个代理类封装调用细节，业务层对远程<br>调用无感</p>
<p>服务注册层（ Registry） ： 封装服务地址的注册和发现， 以服务 URL 为中心</p>
<p>路由层（ Cluster） ： 封装多个提供者的路由和负载均衡， 并桥接注册中心</p>
<p>监控层（ Monitor） ： RPC 调用次数和调用时间监控</p>
<p>远程调用层（ Protocal）：封装 RPC 调用</p>
<p>信息交换层（ Exchange）： 封装请求响应模式， 同步转异步</p>
<p>网络传输层（ Transport）：抽象 mina 和 netty 为统一接口，统一网络传输接口</p>
<p>数据序列化层（ Serialize） ： 数据传输的序列化和反序列化</p>
<h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><h2 id="简述RabbitMQ的架构设计"><a href="#简述RabbitMQ的架构设计" class="headerlink" title="简述RabbitMQ的架构设计"></a>简述RabbitMQ的架构设计</h2><p><strong>Broker</strong> ：rabbitmq的服务节点</p>
<p><strong>Queue</strong> ：队列，是RabbitMQ的内部对象，用于存储消息。RabbitMQ中消息只能存储在队列中。生产<br>者投递消息到队列，消费者从队列中获取消息并消费。多个消费者可以订阅同一个队列，这时队列中的<br>消息会被平均分摊(轮询)给多个消费者进行消费，而不是每个消费者都收到所有的消息进行消费。(注<br>意：RabbitMQ不支持队列层面的广播消费，如果需要广播消费，可以采用一个交换器通过路由Key绑<br>定多个队列，由多个消费者来订阅这些队列的方式。</p>
<p><strong>Exchange</strong> ：交换器。生产者将消息发送到Exchange，由交换器将消息路由到一个或多个队列中。如果<br>路由不到，或返回给生产者，或直接丢弃，或做其它处理。</p>
<p><strong>RoutingKey</strong> ：路由Key。生产者将消息发送给交换器的时候，一般会指定一个RoutingKey，用来指定<br>这个消息的路由规则。这个路由Key需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。<br>在交换器类型和绑定键固定的情况下，生产者可以在发送消息给交换器时通过指定RoutingKey来决定消<br>息流向哪里。</p>
<p><strong>Binding</strong> ：通过绑定将交换器和队列关联起来，在绑定的时候一般会指定一个绑定键，这样RabbitMQ<br>就可以指定如何正确的路由到队列了。</p>
<p>交换器和队列实际上是多对多关系。就像关系数据库中的两张表。他们通过BindingKey做关联(多对多<br>关系表)。在投递消息时，可以通过Exchange和RoutingKey(对应BindingKey)就可以找到相对应的队<br>列。</p>
<p><strong>信道</strong> ：信道是建立在Connection 之上的虚拟连接。当应用程序与Rabbit Broker建立TCP连接的时候，<br>客户端紧接着可以创建一个AMQP 信道(Channel) ，每个信道都会被指派一个唯一的D。RabbitMQ 处<br>理的每条AMQP 指令都是通过信道完成的。信道就像电缆里的光纤束。一条电缆内含有许多光纤束，允<br>许所有的连接通过多条光线束进行传输和接收。</p>
<h2 id="RabbitMQ如何确保消息发送-？-消息接收？"><a href="#RabbitMQ如何确保消息发送-？-消息接收？" class="headerlink" title="RabbitMQ如何确保消息发送 ？ 消息接收？"></a>RabbitMQ如何确保消息发送 ？ 消息接收？</h2><h3 id="发送方确认机制："><a href="#发送方确认机制：" class="headerlink" title="发送方确认机制："></a>发送方确认机制：</h3><figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">信道需要设置为 <span class="keyword">confirm</span> 模式，则所有在信道上发布的消息都会分配一个唯一 ID。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一旦消息被投递到queue（可持久化的消息需要写入磁盘），信道会发送一个确认给生产者（包含消息唯一</span><br><span class="line">ID）。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（未确认）消息给生产者。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">所有被发送的消息都将被 <span class="keyword">confirm</span>（即 ack） 或者被nack一次。但是没有对消息被 <span class="keyword">confirm</span> 的快慢做</span><br><span class="line">任何保证，并且同一条消息不会既被 <span class="keyword">confirm</span>又被nack</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者，</span><br><span class="line">生产者的回调方法会被触发。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfirmCallback接口：只确认是否正确到达 Exchange 中，成功到达则回调</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReturnCallback接口：消息失败返回时回调</span><br></pre></td></tr></tbody></table></figure>

<h3 id="接收方确认机制："><a href="#接收方确认机制：" class="headerlink" title="接收方确认机制："></a>接收方确认机制：</h3><h2 id="RabbitMQ事务消息"><a href="#RabbitMQ事务消息" class="headerlink" title="RabbitMQ事务消息"></a>RabbitMQ事务消息</h2><h3 id="通过对信道的设置实现"><a href="#通过对信道的设置实现" class="headerlink" title="通过对信道的设置实现"></a>通过对信道的设置实现</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> channel.txSelect()；通知服务器开启事务模式；服务端会返回Tx.Select-Ok</span><br><span class="line"><span class="bullet">2.</span> channel.basicPublish；发送消息，可以是多条，可以是消费消息提交ack</span><br><span class="line"><span class="bullet">3.</span> channel.txCommit()提交事务；</span><br><span class="line"><span class="bullet">4.</span> channel.txRollback()回滚事务；</span><br></pre></td></tr></tbody></table></figure>
<p>消费者使用事务：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="attribute">autoAck</span>=<span class="literal">false</span>，手动提交ack，以事务提交或回滚为准；</span><br><span class="line">2. <span class="attribute">autoAck</span>=<span class="literal">true</span>，不支持事务的，也就是说你即使在收到消息之后在回滚事务也是于事无补的，队</span><br><span class="line">列已经把消息移除了</span><br></pre></td></tr></tbody></table></figure>
<p>如果其中任意一个环节出现问题，就会抛出IoException异常，用户可以拦截异常进行事务回滚，或决<br>定要不要重复消息。</p>
<p>事务消息会降低rabbitmq的性能</p>
<h2 id="RabbitMQ死信队列、延时队列"><a href="#RabbitMQ死信队列、延时队列" class="headerlink" title="RabbitMQ死信队列、延时队列"></a>RabbitMQ死信队列、延时队列</h2><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消费者在声明队列时，可以指定noAck参数，当<span class="attribute">noAck</span>=<span class="literal">false</span>时，RabbitMQ会等待消费者显式发回ack信号</span><br><span class="line">后才从内存(或者磁盘，持久化消息)中移去消息。否则，消息被消费后会被立即删除。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，</span><br><span class="line">RabbitMQ 才能安全地把消息从队列中删除。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RabbitMQ不会为未ack的消息设置超时时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该</span><br><span class="line">消息的消费者连接是否已经断开。这么设计的原因是RabbitMQ允许消费者消费一条消息的时间可以很长。保</span><br><span class="line">证数据的最终一致性；</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果消费者返回ack之前断开了链接，RabbitMQ 会重新分发给下一个订阅的消费者。（可能存在消息重复消</span><br><span class="line">费的隐患，需要去重）</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 消息被消费方否定确认，使用 channel.basicNack 或 channel.basicReject ，并且此时</span><br><span class="line">requeue 属性被设置为false。</span><br><span class="line"><span class="bullet">2.</span> 消息在队列的存活时间超过设置的TTL时间。</span><br><span class="line"><span class="bullet">3.</span> 消息队列的消息数量已经超过最大队列长度。</span><br></pre></td></tr></tbody></table></figure>
<p>那么该消息将成为“死信”。“死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该<br>消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃</p>
<p>为每个需要使用死信的业务队列配置一个死信交换机，这里同一个项目的死信交换机可以共用一个，然<br>后为每个业务队列分配一个单独的路由key，死信队列只不过是绑定在死信交换机上的队列，死信交换<br>机也不是什么特殊的交换机，只不过是用来接受死信的交换机，所以可以为任何类型【Direct、<br>Fanout、Topic】</p>
<h3 id="TTL：一条消息或者该队列中的所有消息的最大存活时间"><a href="#TTL：一条消息或者该队列中的所有消息的最大存活时间" class="headerlink" title="TTL：一条消息或者该队列中的所有消息的最大存活时间"></a>TTL：一条消息或者该队列中的所有消息的最大存活时间</h3><h3 id="如果一条消息设置了TTL属性或者进入了设置TTL属性的队列，那么这条消息如果在TTL设置的时间内没"><a href="#如果一条消息设置了TTL属性或者进入了设置TTL属性的队列，那么这条消息如果在TTL设置的时间内没" class="headerlink" title="如果一条消息设置了TTL属性或者进入了设置TTL属性的队列，那么这条消息如果在TTL设置的时间内没"></a>如果一条消息设置了TTL属性或者进入了设置TTL属性的队列，那么这条消息如果在TTL设置的时间内没</h3><h3 id="有被消费，则会成为“死信”。如果同时配置了队列的TTL和消息的TTL，那么较小的那个值将会被使用。"><a href="#有被消费，则会成为“死信”。如果同时配置了队列的TTL和消息的TTL，那么较小的那个值将会被使用。" class="headerlink" title="有被消费，则会成为“死信”。如果同时配置了队列的TTL和消息的TTL，那么较小的那个值将会被使用。"></a>有被消费，则会成为“死信”。如果同时配置了队列的TTL和消息的TTL，那么较小的那个值将会被使用。</h3><h3 id="只需要消费者一直消费死信队列里的消息"><a href="#只需要消费者一直消费死信队列里的消息" class="headerlink" title="只需要消费者一直消费死信队列里的消息"></a>只需要消费者一直消费死信队列里的消息</h3><h2 id="RabbitMQ镜像队列机制"><a href="#RabbitMQ镜像队列机制" class="headerlink" title="RabbitMQ镜像队列机制"></a>RabbitMQ镜像队列机制</h2><p>镜像queue有master节点和slave节点。master和slave是针对一个queue而言的，而不是一个node作<br>为所有queue的master，其它node作为slave。一个queue第一次创建的node为它的master节点，其<br>它node为slave节点。</p>
<p>无论客户端的请求打到master还是slave最终数据都是从master节点获取。当请求打到master节点时，<br>master节点直接将消息返回给client，同时master节点会通过GM（Guaranteed Multicast）协议将<br>queue的最新状态广播到slave节点。GM保证了广播消息的原子性，即要么都更新要么都不更新。</p>
<p>当请求打到slave节点时，slave节点需要将请求先重定向到master节点，master节点将将消息返回给<br>client，同时master节点会通过GM协议将queue的最新状态广播到slave节点。</p>
<p>如果有新节点加入，RabbitMQ不会同步之前的历史数据，新节点只会复制该节点加入到集群之后新增<br>的消息。</p>
<h2 id="简述kafka架构设计"><a href="#简述kafka架构设计" class="headerlink" title="简述kafka架构设计"></a>简述kafka架构设计</h2><p><strong>Consumer Group：</strong> 消费者组，消费者组内每个消费者负责消费不同分区的数据，提高消费能力。逻<br>辑上的一个订阅者。</p>
<p><strong>Topic：</strong> 可以理解为一个队列，Topic 将消息分类，生产者和消费者面向的是同一个 Topic。</p>
<p><strong>Partition：</strong> 为了实现扩展性，提高并发能力，一个Topic 以多个Partition的方式分布到多个 Broker<br>上，每个 Partition 是一个 有序的队列。一个 Topic 的每个Partition都有若干个副本（Replica），一个<br>Leader 和若干个 Follower。生产者发送数据的对象，以及消费者消费数据的对象，都是 Leader。<br>Follower负责实时从 Leader 中同步数据，保持和 Leader 数据的同步。Leader 发生故障时，某个<br>Follower 还会成为新的 Leader。</p>
<p><strong>Offset：</strong> 消费者消费的位置信息，监控数据消费到什么位置，当消费者挂掉再重新恢复的时候，可以从<br>消费位置继续消费。</p>
<p><strong>Zookeeper：</strong> Kafka 集群能够正常工作，需要依赖于 Zookeeper，Zookeeper 帮助 Kafka 存储和管理<br>集群信息。</p>
<h2 id="kafka怎么处理消息顺序、重复发送、重复消费、消息丢失"><a href="#kafka怎么处理消息顺序、重复发送、重复消费、消息丢失" class="headerlink" title="kafka怎么处理消息顺序、重复发送、重复消费、消息丢失"></a>kafka怎么处理消息顺序、重复发送、重复消费、消息丢失</h2><h2 id="Kafka在什么情况下会出现消息丢失及解决方案？"><a href="#Kafka在什么情况下会出现消息丢失及解决方案？" class="headerlink" title="Kafka在什么情况下会出现消息丢失及解决方案？"></a>Kafka在什么情况下会出现消息丢失及解决方案？</h2><h3 id="1-）消息发送"><a href="#1-）消息发送" class="headerlink" title="1 ）消息发送"></a>1 ）消息发送</h3><h3 id="2-）消费"><a href="#2-）消费" class="headerlink" title="2 ）消费"></a>2 ）消费</h3><p>3 ）broker的刷盘</p>
<p>减小刷盘间隔</p>
<h2 id="Kafka是pull？push？优劣势分析"><a href="#Kafka是pull？push？优劣势分析" class="headerlink" title="Kafka是pull？push？优劣势分析"></a>Kafka是pull？push？优劣势分析</h2><p>pull模式：</p>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据consumer的消费能力进行数据拉取，可以控制速率</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 、<span class="attribute">ack</span>=0，不重试</span><br><span class="line">producer发送消息完，不管结果了，如果发送失败也就丢失了。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 、<span class="attribute">ack</span>=1，leader crash</span><br><span class="line">producer发送消息完，只等待lead写入成功就返回了，leader crash了，这时follower没来及同步，消</span><br><span class="line">息丢失。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight sqf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> 、unclean.<span class="built_in">leader</span>.election.enable 配置<span class="literal">true</span></span><br><span class="line">允许选举ISR以外的副本作为<span class="built_in">leader</span>,会导致数据丢失，默认为<span class="literal">false</span>。producer发送异步消息完，只等待</span><br><span class="line">lead写入成功就返回了，<span class="built_in">leader</span> crash了，这时ISR中没有follower，<span class="built_in">leader</span>从OSR中选举，因为OSR</span><br><span class="line">中本来落后于<span class="built_in">Leader</span>造成消息丢失。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方案：</span><br><span class="line">1 、配置：<span class="attribute">ack</span>=all / -1,tries &gt; 1,unclean.leader.election.<span class="built_in">enable</span> : <span class="literal">false</span></span><br><span class="line">producer发送消息完，等待follower同步完再返回，如果异常则重试。副本的数量可能影响吞吐量。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight sqf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不允许选举ISR以外的副本作为<span class="built_in">leader</span>。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> 、配置：min<span class="selector-class">.insync</span><span class="selector-class">.replicas</span> &gt; <span class="number">1</span></span><br><span class="line">副本指定必须确认写操作成功的最小副本数量。如果不能满足这个最小值，则生产者将引发一个异常(要么是</span><br><span class="line">NotEnoughReplicas，要么是NotEnoughReplicasAfterAppend)。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight arcade"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>.insync.replicas和ack更大的持久性保证。确保如果大多数副本没有收到写操作，则生产者将引发异</span><br><span class="line">常。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> 、失败的<span class="built_in">offset</span>单独记录</span><br><span class="line">producer发送消息，会自动重试，遇到不可恢复异常会抛出，这时可以捕获异常记录到数据库或缓存，进行</span><br><span class="line">单独处理。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">先<span class="keyword">commit</span>再处理消息。如果在处理消息的时候异常了，但是<span class="keyword">offset</span> 已经提交了，这条消息对于该消费者来</span><br><span class="line">说就是丢失了，再也不会消费到了。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="可以批量拉取、也可以单条拉取"><a href="#可以批量拉取、也可以单条拉取" class="headerlink" title="可以批量拉取、也可以单条拉取"></a>可以批量拉取、也可以单条拉取</h3><h3 id="可以设置不同的提交方式，实现不同的传输语义"><a href="#可以设置不同的提交方式，实现不同的传输语义" class="headerlink" title="可以设置不同的提交方式，实现不同的传输语义"></a>可以设置不同的提交方式，实现不同的传输语义</h3><p>缺点：如果kafka没有数据，会导致consumer空循环，消耗资源</p>
<p>解决：通过参数设置，consumer拉取数据为空或者没有达到一定数量时进行阻塞</p>
<p>push模式：不会导致consumer循环等待</p>
<p>缺点：速率固定、忽略了consumer的消费能力，可能导致拒绝服务或者网络拥塞等情况</p>
<h2 id="Kafka中zk的作用"><a href="#Kafka中zk的作用" class="headerlink" title="Kafka中zk的作用"></a>Kafka中zk的作用</h2><p>/brokers/ids：临时节点，保存所有broker节点信息，存储broker的物理地址、版本信息、启动时间<br>等，节点名称为brokerID，broker定时发送心跳到zk，如果断开则该brokerID会被删除</p>
<p>/brokers/topics：临时节点，节点保存broker节点下所有的topic信息，每一个topic节点下包含一个固<br>定的partitions节点，partitions的子节点就是topic的分区，每个分区下保存一个state节点、保存着当<br>前leader分区和ISR的brokerID，state节点由leader创建，若leader宕机该节点会被删除，直到有新的<br>leader选举产生、重新生成state节点</p>
<p>/consumers/[group_id]/owners/[topic]/[broker_id-partition_id]：维护消费者和分区的注册关系</p>
<p>/consumers/[group_id]/offsets/[topic]/[broker_id-partition_id]：分区消息的消费进度Offset</p>
<p>client通过topic找到topic树下的state节点、获取leader的brokerID，到broker树中找到broker的物理<br>地址，但是client不会直连zk，而是通过配置的broker获取到zk中的信息</p>
<h2 id="简述kafka的rebalance机制"><a href="#简述kafka的rebalance机制" class="headerlink" title="简述kafka的rebalance机制"></a>简述kafka的rebalance机制</h2><p>consumer group中的消费者与topic下的partion重新匹配的过程</p>
<p>何时会产生rebalance：</p>
<figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">consumer <span class="keyword">group</span>中的成员个数发生变化</span><br><span class="line">consumer消费超时</span><br><span class="line"><span class="keyword">group</span>订阅的topic个数发生变化</span><br><span class="line"><span class="keyword">group</span>订阅的topic的分区数发生变化</span><br></pre></td></tr></tbody></table></figure>

<p>coordinator：通常是partition的leader节点所在的broker，负责监控group中consumer的存活，<br>consumer维持到coordinator的心跳，判断consumer的消费超时</p>
<figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">coordinator通过心跳返回通知consumer进行rebalance</span><br><span class="line">consumer请求coordinator加入组，coordinator选举产生leader consumer</span><br><span class="line">leader consumer从coordinator获取所有的consumer，发送<span class="keyword">syncGroup(分配信息)给到</span></span><br><span class="line"><span class="keyword"></span>coordinator</span><br><span class="line">coordinator通过心跳机制将<span class="keyword">syncGroup下发给consumer</span></span><br><span class="line"><span class="keyword"></span>完成rebalance</span><br></pre></td></tr></tbody></table></figure>
<p>leader consumer监控topic的变化，通知coordinator触发rebalance</p>
<p>如果C1消费消息超时，触发rebalance，重新分配后、该消息会被其他消费者消费，此时C1消费完成提<br>交offset、导致错误</p>
<p>解决：coordinator每次rebalance，会标记一个Generation给到consumer，每次rebalance该<br>Generation会+1，consumer提交offset时，coordinator会比对Generation，不一致则拒绝提交</p>
<h2 id="Kafka的性能好在什么地方"><a href="#Kafka的性能好在什么地方" class="headerlink" title="Kafka的性能好在什么地方"></a>Kafka的性能好在什么地方</h2><p>kafka不基于内存，而是硬盘存储，因此消息堆积能力更强</p>
<p>顺序写：利用磁盘的顺序访问速度可以接近内存，kafka的消息都是append操作，partition是有序的，<br>节省了磁盘的寻道时间，同时通过批量操作、节省写入次数，partition物理上分为多个segment存储，<br>方便删除</p>
<h3 id="传统："><a href="#传统：" class="headerlink" title="传统："></a>传统：</h3><h3 id="读取磁盘文件数据到内核缓冲区"><a href="#读取磁盘文件数据到内核缓冲区" class="headerlink" title="读取磁盘文件数据到内核缓冲区"></a>读取磁盘文件数据到内核缓冲区</h3><figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将内核缓冲区的数据<span class="keyword">copy</span>到用户缓冲区</span><br><span class="line">将用户缓冲区的数据<span class="keyword">copy</span>到socket的发送缓冲区</span><br><span class="line">将socket发送缓冲区中的数据发送到网卡、进行传输</span><br></pre></td></tr></tbody></table></figure>
<p>零拷贝：</p>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接将内核缓冲区的数据发送到网卡传输</span><br><span class="line">使用的是操作系统的指令支持</span><br></pre></td></tr></tbody></table></figure>
<p>kafka不太依赖jvm，主要理由操作系统的pageCache，如果生产消费速率相当，则直接用pageCache<br>交换数据，不需要经过磁盘IO</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>you can reward me here. Thank you!</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="lz 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="lz 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>lz
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://llzzoomm.github.io/2023/04/16/java-ji-chu-yuan-li/" title="java基础原理">https://llzzoomm.github.io/2023/04/16/java-ji-chu-yuan-li/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%8E%9F%E7%90%86/" rel="tag"><i class="fa fa-tag"></i> 原理</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/04/01/ren-zheng-shou-quan/" rel="prev" title="one five">
      <i class="fa fa-chevron-left"></i> one five
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/06/04/day01ceshi/" rel="next" title="测试基础01">
      测试基础01 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E5%9F%BA%E7%A1%80"><span class="nav-text">java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-text">什么是面向对象？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%EF%BC%8C%E6%98%AF%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%92%E5%BA%A6"><span class="nav-text">对比面向过程，是两种不同的处理问题的角度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E6%9B%B4%E6%B3%A8%E9%87%8D%E4%BA%8B%E6%83%85%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%AD%A5%E9%AA%A4%E5%8F%8A%E9%A1%BA%E5%BA%8F%EF%BC%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%9B%B4%E6%B3%A8%E9%87%8D%E4%BA%8B%E6%83%85%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%82%E4%B8%8E%E8%80%85%EF%BC%88%E5%AF%B9%E8%B1%A1%EF%BC%89%E3%80%81%E5%8F%8A%E5%90%84%E8%87%AA%E9%9C%80%E8%A6%81%E5%81%9A"><span class="nav-text">面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、及各自需要做</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88"><span class="nav-text">什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E5%A6%82%EF%BC%9A%E6%B4%97%E8%A1%A3%E6%9C%BA%E6%B4%97%E8%A1%A3%E6%9C%8D"><span class="nav-text">比如：洗衣机洗衣服</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%BC%9A%E5%B0%86%E4%BB%BB%E5%8A%A1%E6%8B%86%E8%A7%A3%E6%88%90%E4%B8%80%E7%B3%BB%E5%88%97%E7%9A%84%E6%AD%A5%E9%AA%A4%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89%EF%BC%8C-1-%E3%80%81%E6%89%93%E5%BC%80%E6%B4%97%E8%A1%A3%E6%9C%BA%E2%80%94%E2%80%93-gt-2%E3%80%81%E6%94%BE%E8%A1%A3%E6%9C%8D%E2%80%94%E2%80%93-gt-3%E3%80%81%E6%94%BE%E6%B4%97%E8%A1%A3%E7%B2%89%E2%80%94%E2%80%93"><span class="nav-text">面向过程会将任务拆解成一系列的步骤（函数）， 1 、打开洗衣机—–&gt;2、放衣服—–&gt;3、放洗衣粉—–</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gt-4%E3%80%81%E6%B8%85%E6%B4%97%E2%80%94%E2%80%93-gt-5%E3%80%81%E7%83%98%E5%B9%B2"><span class="nav-text">&gt;4、清洗—–&gt;5、烘干</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BC%9A%E6%8B%86%E5%87%BA%E4%BA%BA%E5%92%8C%E6%B4%97%E8%A1%A3%E6%9C%BA%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="nav-text">面向对象会拆出人和洗衣机两个对象：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%BA%EF%BC%9A%E6%89%93%E5%BC%80%E6%B4%97%E8%A1%A3%E6%9C%BA-%E6%94%BE%E8%A1%A3%E6%9C%8D-%E6%94%BE%E6%B4%97%E8%A1%A3%E7%B2%89"><span class="nav-text">人：打开洗衣机 放衣服 放洗衣粉</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%97%E8%A1%A3%E6%9C%BA%EF%BC%9A%E6%B8%85%E6%B4%97-%E7%83%98%E5%B9%B2"><span class="nav-text">洗衣机：清洗 烘干</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E4%BB%A5%E4%B8%8A%E4%BE%8B%E5%AD%90%E8%83%BD%E7%9C%8B%E5%87%BA%EF%BC%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E6%AF%94%E8%BE%83%E7%9B%B4%E6%8E%A5%E9%AB%98%E6%95%88%EF%BC%8C%E8%80%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%9B%B4%E6%98%93%E4%BA%8E%E5%A4%8D%E7%94%A8%E3%80%81%E6%89%A9%E5%B1%95%E5%92%8C%E7%BB%B4%E6%8A%A4"><span class="nav-text">从以上例子能看出，面向过程比较直接高效，而面向对象更易于复用、扩展和维护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1"><span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85-%EF%BC%9A%E5%B0%81%E8%A3%85%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%8C%E5%9C%A8%E4%BA%8E%E6%98%8E%E7%A1%AE%E6%A0%87%E8%AF%86%E5%87%BA%E5%85%81%E8%AE%B8%E5%A4%96%E9%83%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E6%89%80%E6%9C%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E6%8D%AE%E9%A1%B9"><span class="nav-text">封装 ：封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%BB%86%E8%8A%82%E5%AF%B9%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E9%80%8F%E6%98%8E%EF%BC%8C%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E6%97%A0%E9%9C%80%E4%BF%AE%E6%94%B9%E6%88%96%E8%80%85%E5%85%B3%E5%BF%83%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="nav-text">内部细节对外部调用透明，外部调用无需修改或者关心内部实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF-%EF%BC%9A%E7%BB%A7%E6%89%BF%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B9%B6%E5%81%9A%E5%87%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E6%94%B9%E5%8F%98%E5%92%8C-%E6%88%96%E6%89%A9%E5%B1%95"><span class="nav-text">继承 ：继承基类的方法，并做出自己的改变和&#x2F;或扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E5%85%B1%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%B1%9E%E6%80%A7%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%EF%BC%8C%E8%80%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E5%86%8D%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%8F%AA%E9%9C%80%E6%89%A9%E5%B1%95%E8%87%AA%E5%B7%B1%E4%B8%AA%E6%80%A7%E5%8C%96%E7%9A%84"><span class="nav-text">子类共性的方法或者属性直接使用父类的，而不需要自己再定义，只需扩展自己个性化的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81-%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E6%89%80%E5%B1%9E%E7%B1%BB%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%A4%96%E9%83%A8%E5%AF%B9%E5%90%8C%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%8C%E5%AE%9E%E9%99%85%E6%89%A7%E8%A1%8C%E7%9A%84%E9%80%BB%E8%BE%91%E4%B8%8D%E5%90%8C%E3%80%82"><span class="nav-text">多态 ：基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%8C%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%EF%BC%8C%E7%88%B6%E7%B1%BB%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="nav-text">继承，方法重写，父类引用指向子类对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E6%B3%95%E8%B0%83%E7%94%A8%E5%AD%90%E7%B1%BB%E7%89%B9%E6%9C%89%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-text">无法调用子类特有的功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK-JRE-JVM"><span class="nav-text">JDK JRE JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK%EF%BC%9A"><span class="nav-text">JDK：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%92%8Cequals%E6%AF%94%E8%BE%83"><span class="nav-text">&#x3D;&#x3D;和equals比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E7%9A%84%E6%98%AF%E6%A0%88%E4%B8%AD%E7%9A%84%E5%80%BC%EF%BC%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%8F%98%E9%87%8F%E5%80%BC%EF%BC%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%A0%86%E4%B8%AD%E5%86%85%E5%AD%98%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="nav-text">&#x3D;&#x3D;对比的是栈中的值，基本数据类型是变量值，引用类型是堆中内存对象的地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hashCode%E4%B8%8Eequals"><span class="nav-text">hashCode与equals</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final"><span class="nav-text">final</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%BB%88%E7%9A%84"><span class="nav-text">最终的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E7%B1%BB%EF%BC%9A%E8%A1%A8%E7%A4%BA%E7%B1%BB%E4%B8%8D%E5%8F%AF%E8%A2%AB%E7%BB%A7%E6%89%BF"><span class="nav-text">修饰类：表示类不可被继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95%EF%BC%9A%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E4%B8%8D%E5%8F%AF%E8%A2%AB%E5%AD%90%E7%B1%BB%E8%A6%86%E7%9B%96%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8F%AF%E4%BB%A5%E9%87%8D%E8%BD%BD"><span class="nav-text">修饰方法：表示方法不可被子类覆盖，但是可以重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%EF%BC%9A%E8%A1%A8%E7%A4%BA%E5%8F%98%E9%87%8F%E4%B8%80%E6%97%A6%E8%A2%AB%E8%B5%8B%E5%80%BC%E5%B0%B1%E4%B8%8D%E5%8F%AF%E4%BB%A5%E6%9B%B4%E6%94%B9%E5%AE%83%E7%9A%84%E5%80%BC%E3%80%82"><span class="nav-text">修饰变量：表示变量一旦被赋值就不可以更改它的值。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%88-1-%EF%BC%89%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-text">（ 1 ）修饰成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%88-3-%EF%BC%89%E4%BF%AE%E9%A5%B0%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE"><span class="nav-text">（ 3 ）修饰基本类型数据和引用类型数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%98%AF%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%8C%E5%88%99%E5%85%B6%E6%95%B0%E5%80%BC%E4%B8%80%E6%97%A6%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E5%90%8E%E4%BE%BF%E4%B8%8D%E8%83%BD%E6%9B%B4%E6%94%B9%EF%BC%9B"><span class="nav-text">如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%8C%E5%88%99%E5%9C%A8%E5%AF%B9%E5%85%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E5%90%8E%E4%BE%BF%E4%B8%8D%E8%83%BD%E5%86%8D%E8%AE%A9%E5%85%B6%E6%8C%87%E5%90%91%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E3%80%82-%E4%BD%86%E6%98%AF%E5%BC%95%E7%94%A8%E7%9A%84%E5%80%BC%E6%98%AF%E5%8F%AF%E5%8F%98"><span class="nav-text">如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 但是引用的值是可变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9A%84-%E3%80%82"><span class="nav-text">的 。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A6%96%E5%85%88%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E7%82%B9%E6%98%AF-%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%A4%96%E9%83%A8%E7%B1%BB%E6%98%AF%E5%A4%84%E4%BA%8E%E5%90%8C%E4%B8%80%E4%B8%AA%E7%BA%A7%E5%88%AB%E7%9A%84%EF%BC%8C%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8D%E4%BC%9A%E5%9B%A0%E4%B8%BA%E5%AE%9A%E4%B9%89%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E5%B0%B1%E4%BC%9A%E9%9A%8F%E7%9D%80"><span class="nav-text">首先需要知道的一点是: 内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E5%B0%B1%E8%A2%AB%E9%94%80%E6%AF%81%E3%80%82"><span class="nav-text">方法的执行完毕就被销毁。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%99%E9%87%8C%E5%B0%B1%E4%BC%9A%E4%BA%A7%E7%94%9F%E9%97%AE%E9%A2%98%EF%BC%9A%E5%BD%93%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E7%BB%93%E6%9D%9F%E6%97%B6%EF%BC%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%B0%B1%E4%BC%9A%E8%A2%AB%E9%94%80%E6%AF%81%E4%BA%86%EF%BC%8C%E4%BD%86%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%8F%AF%E8%83%BD%E8%BF%98%E5%AD%98%E5%9C%A8-%E5%8F%AA%E6%9C%89"><span class="nav-text">这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89%E4%BA%BA%E5%86%8D%E5%BC%95%E7%94%A8%E5%AE%83%E6%97%B6%EF%BC%8C%E6%89%8D%E4%BC%9A%E6%AD%BB%E4%BA%A1-%E3%80%82%E8%BF%99%E9%87%8C%E5%B0%B1%E5%87%BA%E7%8E%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E7%9F%9B%E7%9B%BE%EF%BC%9A%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E4%BA%86%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%8F%98%E9%87%8F%E3%80%82%E4%B8%BA%E4%BA%86%E8%A7%A3"><span class="nav-text">没有人再引用它时，才会死亡)。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%8C%E5%B0%B1%E5%B0%86%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%A4%8D%E5%88%B6%E4%BA%86%E4%B8%80%E4%BB%BD%E4%BD%9C%E4%B8%BA%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%BD%93%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%AD%BB%E4%BA%A1%E5%90%8E%EF%BC%8C%E5%86%85%E9%83%A8%E7%B1%BB%E4%BB%8D%E5%8F%AF%E4%BB%A5"><span class="nav-text">决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%A4%8D%E5%88%B6%E4%B8%BA%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%97%B6%EF%BC%8C%E5%BF%85%E9%A1%BB%E4%BF%9D%E8%AF%81%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E5%9C%A8%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%AD%E4%BF%AE"><span class="nav-text">将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E4%BA%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%8C%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B9%9F%E5%BE%97%E8%B7%9F%E7%9D%80%E6%94%B9%E5%8F%98%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F"><span class="nav-text">改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder"><span class="nav-text">String、StringBuffer、StringBuilder</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%EF%BC%9A%E7%BB%8F%E5%B8%B8%E9%9C%80%E8%A6%81%E6%94%B9%E5%8F%98%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AE%B9%E6%97%B6%E4%BD%BF%E7%94%A8%E5%90%8E%E9%9D%A2%E4%B8%A4%E4%B8%AA"><span class="nav-text">场景：经常需要改变字符串内容时使用后面两个</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">重载和重写的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%EF%BC%9A-%E5%8F%91%E7%94%9F%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%EF%BC%8C%E6%96%B9%E6%B3%95%E5%90%8D%E5%BF%85%E9%A1%BB%E7%9B%B8%E5%90%8C%EF%BC%8C%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%E3%80%81%E4%B8%AA%E6%95%B0%E4%B8%8D%E5%90%8C%E3%80%81%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%90%8C%EF%BC%8C%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E8%AE%BF%E9%97%AE"><span class="nav-text">重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%8F%91%E7%94%9F%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E3%80%82"><span class="nav-text">修饰符可以不同，发生在编译时。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99%EF%BC%9A-%E5%8F%91%E7%94%9F%E5%9C%A8%E7%88%B6%E5%AD%90%E7%B1%BB%E4%B8%AD%EF%BC%8C%E6%96%B9%E6%B3%95%E5%90%8D%E3%80%81%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E5%BF%85%E9%A1%BB%E7%9B%B8%E5%90%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E8%8C%83%E5%9B%B4%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E%E7%88%B6%E7%B1%BB%EF%BC%8C%E6%8A%9B%E5%87%BA%E7%9A%84%E5%BC%82%E5%B8%B8%E8%8C%83%E5%9B%B4%E5%B0%8F%E4%BA%8E"><span class="nav-text">重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">接口和抽象类的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List%E5%92%8CSet%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">List和Set的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB"><span class="nav-text">ArrayList和LinkedList区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap%E5%92%8CHashTable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%85%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%98%AF%E4%BB%80"><span class="nav-text">HashMap和HashTable有什么区别？其底层实现是什</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%88%EF%BC%9F"><span class="nav-text">么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB-%EF%BC%9A"><span class="nav-text">区别 ：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap%E5%8E%9F%E7%90%86%EF%BC%8Cjdk7%E5%92%8Cjdk8%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">ConcurrentHashMap原理，jdk7和jdk8版本的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">什么是字节码？采用字节码的好处是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="nav-text">Java中的异常体系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">Java类加载器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%A8%A1%E5%9E%8B"><span class="nav-text">双亲委托模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9A"><span class="nav-text">双亲委派模型的好处：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6"><span class="nav-text">GC如何判断对象可以被回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95%EF%BC%9A%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%9C%89%E4%B8%80%E4%B8%AA%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%B1%9E%E6%80%A7%EF%BC%8C%E6%96%B0%E5%A2%9E%E4%B8%80%E4%B8%AA%E5%BC%95%E7%94%A8%E6%97%B6%E8%AE%A1%E6%95%B0%E5%8A%A0-1-%EF%BC%8C%E5%BC%95%E7%94%A8%E9%87%8A%E6%94%BE%E6%97%B6%E8%AE%A1%E6%95%B0%E5%87%8F-1-%EF%BC%8C%E8%AE%A1"><span class="nav-text">引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加 1 ，引用释放时计数减 1 ，计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E4%B8%BA-0-%E6%97%B6%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6%EF%BC%8C"><span class="nav-text">数为 0 时可以回收，</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%8F%AF%E8%BE%BE%E5%AF%B9%E8%B1%A1%E5%B9%B6%E4%B8%8D%E6%98%AF%E7%AB%8B%E5%8D%B3%E6%AD%BB%E4%BA%A1%E7%9A%84%EF%BC%8C%E5%AF%B9%E8%B1%A1%E6%8B%A5%E6%9C%89%E4%B8%80%E6%AC%A1%E8%87%AA%E6%88%91%E6%8B%AF%E6%95%91%E7%9A%84%E6%9C%BA%E4%BC%9A%E3%80%82%E5%AF%B9%E8%B1%A1%E8%A2%AB%E7%B3%BB%E7%BB%9F%E5%AE%A3%E5%91%8A%E6%AD%BB%E4%BA%A1%E8%87%B3"><span class="nav-text">可达性算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会。对象被系统宣告死亡至</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E3%80%81%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3"><span class="nav-text">线程、并发相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-text">线程的生命周期？线程有几种状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BA%BF%E7%A8%8B%E9%80%9A%E5%B8%B8%E6%9C%89%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%8C%E5%88%9B%E5%BB%BA%EF%BC%8C%E5%B0%B1%E7%BB%AA%EF%BC%8C%E8%BF%90%E8%A1%8C%E3%80%81%E9%98%BB%E5%A1%9E%E5%92%8C%E6%AD%BB%E4%BA%A1%E7%8A%B6%E6%80%81%E3%80%82"><span class="nav-text">1.线程通常有五种状态，创建，就绪，运行、阻塞和死亡状态。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%98%BB%E5%A1%9E%E7%9A%84%E6%83%85%E5%86%B5%E5%8F%88%E5%88%86%E4%B8%BA%E4%B8%89%E7%A7%8D%EF%BC%9A"><span class="nav-text">2.阻塞的情况又分为三种：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep-%E3%80%81wait-%E3%80%81join-%E3%80%81yield-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">sleep()、wait()、join()、yield()的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%94%81%E6%B1%A0"><span class="nav-text">1.锁池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E9%9C%80%E8%A6%81%E7%AB%9E%E4%BA%89%E5%90%8C%E6%AD%A5%E9%94%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%83%BD%E4%BC%9A%E6%94%BE%E5%9C%A8%E9%94%81%E6%B1%A0%E5%BD%93%E4%B8%AD%EF%BC%8C%E6%AF%94%E5%A6%82%E5%BD%93%E5%89%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%81%E5%B7%B2%E7%BB%8F%E8%A2%AB%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%BE%97%E5%88%B0%EF%BC%8C%E5%88%99%E5%85%B6%E4%BB%96%E7%BA%BF"><span class="nav-text">所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E9%9C%80%E8%A6%81%E5%9C%A8%E8%BF%99%E4%B8%AA%E9%94%81%E6%B1%A0%E8%BF%9B%E8%A1%8C%E7%AD%89%E5%BE%85%EF%BC%8C%E5%BD%93%E5%89%8D%E9%9D%A2%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%87%8A%E6%94%BE%E5%90%8C%E6%AD%A5%E9%94%81%E5%90%8E%E9%94%81%E6%B1%A0%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%8E%BB%E7%AB%9E%E4%BA%89%E5%90%8C%E6%AD%A5%E9%94%81%EF%BC%8C%E5%BD%93%E6%9F%90%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%BE%97%E5%88%B0"><span class="nav-text">程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">对线程安全的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81%E5%BA%94%E8%AF%A5%E6%98%AF%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%EF%BC%8C%E5%A0%86%E6%98%AF%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE"><span class="nav-text">不是线程安全、应该是内存安全，堆是共享内存，可以被所有线程访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86-%E6%98%AF%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%85%B1%E6%9C%89%E7%9A%84%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%88%86%E5%85%A8%E5%B1%80%E5%A0%86%E5%92%8C%E5%B1%80%E9%83%A8%E5%A0%86%E3%80%82%E5%85%A8%E5%B1%80%E5%A0%86%E5%B0%B1%E6%98%AF%E6%89%80%E6%9C%89%E6%B2%A1%E6%9C%89%E5%88%86%E9%85%8D%E7%9A%84%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%B1%80%E9%83%A8%E5%A0%86%E5%B0%B1%E6%98%AF%E7%94%A8%E6%88%B7%E5%88%86"><span class="nav-text">堆 是进程和线程共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%9A%84%E7%A9%BA%E9%97%B4%E3%80%82%E5%A0%86%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%B9%E8%BF%9B%E7%A8%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%97%B6%E5%80%99%E5%88%86%E9%85%8D%EF%BC%8C%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%90%91%E7%B3%BB%E7%BB%9F%E8%A6%81%E9%A2%9D%E5%A4%96%E7%9A%84%E5%A0%86%EF%BC%8C%E4%BD%86%E6%98%AF%E7%94%A8%E5%AE%8C%E4%BA%86"><span class="nav-text">配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是用完了</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%81%E8%BF%98%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E8%A6%81%E4%B8%8D%E7%84%B6%E5%B0%B1%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E3%80%82"><span class="nav-text">要还给操作系统，要不然就是内存泄漏。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%89%8D%E4%B8%BB%E6%B5%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%83%BD%E6%98%AF%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%EF%BC%8C%E5%8D%B3%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C%E3%80%82%E4%B8%BA%E4%BA%86%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%EF%BC%8C%E6%AF%8F%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AA%E8%83%BD%E8%AE%BF%E9%97%AE%E5%88%86%E9%85%8D%E7%BB%99%E8%87%AA%E5%B7%B1"><span class="nav-text">目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%8C%E8%80%8C%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E5%88%AB%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%9A%84%EF%BC%8C%E8%BF%99%E6%98%AF%E7%94%B1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BF%9D%E9%9A%9C%E7%9A%84%E3%80%82"><span class="nav-text">的内存空间，而不能访问别的进程的，这是由操作系统保障的。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%AF%8F%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E4%B8%AD%E9%83%BD%E4%BC%9A%E6%9C%89%E4%B8%80%E5%9D%97%E7%89%B9%E6%AE%8A%E7%9A%84%E5%85%AC%E5%85%B1%E5%8C%BA%E5%9F%9F%EF%BC%8C%E9%80%9A%E5%B8%B8%E7%A7%B0%E4%B8%BA%E5%A0%86%EF%BC%88%E5%86%85%E5%AD%98%EF%BC%89%E3%80%82%E8%BF%9B%E7%A8%8B%E5%86%85%E7%9A%84%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E9%83%BD%E5%8F%AF%E4%BB%A5"><span class="nav-text">在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%88%B0%E8%AF%A5%E5%8C%BA%E5%9F%9F%EF%BC%8C%E8%BF%99%E5%B0%B1%E6%98%AF%E9%80%A0%E6%88%90%E9%97%AE%E9%A2%98%E7%9A%84%E6%BD%9C%E5%9C%A8%E5%8E%9F%E5%9B%A0%E3%80%82"><span class="nav-text">访问到该区域，这就是造成问题的潜在原因。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread%E3%80%81Runable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">Thread、Runable的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">对守护线程的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%9A%E4%B8%BA%E6%89%80%E6%9C%89%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%9B%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E9%83%BD%E6%98%AF%E6%95%B4%E4%B8%AAJVM%E4%B8%AD%E6%89%80%E6%9C%89%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BF%9D"><span class="nav-text">守护线程：为所有非守护线程提供服务的线程；任何一个守护线程都是整个JVM中所有非守护线程的保</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A7%86%EF%BC%9B"><span class="nav-text">姆；</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%B1%BB%E4%BC%BC%E4%BA%8E%E6%95%B4%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E9%BB%98%E9%BB%98%E6%97%A0%E9%97%BB%E7%9A%84%E5%B0%8F%E5%96%BD%E5%96%BD%EF%BC%9B%E5%AE%83%E7%9A%84%E7%94%9F%E6%AD%BB%E6%97%A0%E5%85%B3%E9%87%8D%E8%A6%81%EF%BC%8C%E5%AE%83%E5%8D%B4%E4%BE%9D%E8%B5%96%E6%95%B4%E4%B8%AA%E8%BF%9B%E7%A8%8B%E8%80%8C%E8%BF%90%E8%A1%8C%EF%BC%9B%E5%93%AA"><span class="nav-text">守护线程类似于整个进程的一个默默无闻的小喽喽；它的生死无关重要，它却依赖整个进程而运行；哪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A9%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F%E4%BA%86%EF%BC%8C%E6%B2%A1%E6%9C%89%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BA%86%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%B0%B1%E7%BB%93%E6%9D%9F%E4%BA%86%EF%BC%8C%E7%90%86%E9%83%BD%E6%B2%A1%E7%90%86%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%B0%B1%E6%8A%8A%E5%AE%83%E4%B8%AD%E6%96%AD%E4%BA%86%EF%BC%9B"><span class="nav-text">天其他线程结束了，没有要执行的了，程序就结束了，理都没理守护线程，就把它中断了；</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">ThreadLocal的原理和使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="nav-text">使用场景：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%8E%9F%E5%9B%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D"><span class="nav-text">ThreadLocal内存泄露原因，如何避免</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%BA%E7%A8%8B%E5%BA%8F%E5%9C%A8%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E5%90%8E%EF%BC%8C%E6%97%A0%E6%B3%95%E9%87%8A%E6%94%BE%E5%B7%B2%E7%94%B3%E8%AF%B7%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%8C%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%8D%B1%E5%AE%B3%E5%8F%AF%E4%BB%A5%E5%BF%BD%E7%95%A5%EF%BC%8C%E4%BD%86%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="nav-text">内存泄露为程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E7%A7%AF%E5%90%8E%E6%9E%9C%E5%BE%88%E4%B8%A5%E9%87%8D%EF%BC%8C%E6%97%A0%E8%AE%BA%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98-%E8%BF%9F%E6%97%A9%E4%BC%9A%E8%A2%AB%E5%8D%A0%E5%85%89%EF%BC%8C"><span class="nav-text">堆积后果很严重，无论多少内存,迟早会被占光，</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%86%8D%E4%BC%9A%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%88%96%E8%80%85%E5%8F%98%E9%87%8F%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E3%80%82"><span class="nav-text">不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E3%80%81%E5%B9%B6%E8%A1%8C%E3%80%81%E4%B8%B2%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">并发、并行、串行的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E8%A1%8C%E5%9C%A8%E6%97%B6%E9%97%B4%E4%B8%8A%E4%B8%8D%E5%8F%AF%E8%83%BD%E5%8F%91%E7%94%9F%E9%87%8D%E5%8F%A0%EF%BC%8C%E5%89%8D%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%B2%A1%E6%90%9E%E5%AE%9A%EF%BC%8C%E4%B8%8B%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%B0%B1%E5%8F%AA%E8%83%BD%E7%AD%89%E7%9D%80"><span class="nav-text">串行在时间上不可能发生重叠，前一个任务没搞定，下一个任务就只能等着</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%9C%A8%E6%97%B6%E9%97%B4%E4%B8%8A%E6%98%AF%E9%87%8D%E5%8F%A0%E7%9A%84%EF%BC%8C%E4%B8%A4%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%9C%A8-%E5%90%8C%E4%B8%80%E6%97%B6%E5%88%BB%E4%BA%92%E4%B8%8D%E5%B9%B2%E6%89%B0-%E7%9A%84%E5%90%8C%E6%97%B6%E6%89%A7%E8%A1%8C%E3%80%82"><span class="nav-text">并行在时间上是重叠的，两个任务在 同一时刻互不干扰 的同时执行。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%85%81%E8%AE%B8%E4%B8%A4%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%BD%BC%E6%AD%A4%E5%B9%B2%E6%89%B0%E3%80%82%E7%BB%9F%E4%B8%80%E6%97%B6%E9%97%B4%E7%82%B9%E3%80%81%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E8%BF%90%E8%A1%8C%EF%BC%8C%E4%BA%A4%E6%9B%BF%E6%89%A7%E8%A1%8C"><span class="nav-text">并发允许两个任务彼此干扰。统一时间点、只有一个任务运行，交替执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-text">并发的三大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%A3%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%8E%9F%E5%AD%90%E6%80%A7%E6%8C%87%E7%9A%84%E6%98%AF%E6%9C%80%E5%B0%8F%E7%9A%84%E6%93%8D%E4%BD%9C%E5%8D%95%E5%85%83%EF%BC%8C%E6%AF%94%E5%A6%82%E8%87%AA%E5%A2%9E%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%AE%83%E6%9C%AC%E8%BA%AB%E5%85%B6%E5%AE%9E%E5%B9%B6%E4%B8%8D%E6%98%AF%E5%8E%9F%E5%AD%90%E6%80%A7%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%88%86%E4%BA%86-3-%E6%AD%A5%E7%9A%84%EF%BC%8C"><span class="nav-text">那程序中原子性指的是最小的操作单元，比如自增操作，它本身其实并不是原子性操作，分了 3 步的，</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E6%8B%AC%E8%AF%BB%E5%8F%96%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%A7%8B%E5%80%BC%E3%80%81%E8%BF%9B%E8%A1%8C%E5%8A%A0-1-%E6%93%8D%E4%BD%9C%E3%80%81%E5%86%99%E5%85%A5%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E3%80%82%E6%89%80%E4%BB%A5%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%EF%BC%8C%E6%9C%89%E5%8F%AF%E8%83%BD%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%B2%A1%E8%87%AA%E5%A2%9E"><span class="nav-text">包括读取变量的原始值、进行加 1 操作、写入工作内存。所以在多线程中，有可能一个线程还没自增</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%89%8D%E6%89%A7%E8%A1%8C%E5%88%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%8C%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%B0%B1%E5%B7%B2%E7%BB%8F%E8%AF%BB%E5%8F%96%E4%BA%86%E5%80%BC%EF%BC%8C%E5%AF%BC%E8%87%B4%E7%BB%93%E6%9E%9C%E9%94%99%E8%AF%AF%E3%80%82%E9%82%A3%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E8%83%BD%E4%BF%9D%E8%AF%81%E8%87%AA%E5%A2%9E%E6%93%8D%E4%BD%9C%E6%98%AF"><span class="nav-text">完，可能才执行到第二部，另一个线程就已经读取了值，导致结果错误。那如果我们能保证自增操作是</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%B1%E8%83%BD%E4%BF%9D%E8%AF%81%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E8%AF%BB%E5%8F%96%E5%88%B0%E7%9A%84%E4%B8%80%E5%AE%9A%E6%98%AF%E8%87%AA%E5%A2%9E%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82"><span class="nav-text">一个原子性的操作，那么就能保证其他线程读取到的一定是自增后的数据。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile"><span class="nav-text">volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96%E3%80%82"><span class="nav-text">2. 禁止指令重排序优化。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E8%A7%A3%E9%87%8A%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="nav-text">为什么用线程池？解释下线程池参数？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E3%80%81%E9%99%8D%E4%BD%8E%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97%EF%BC%9B%E6%8F%90%E9%AB%98%E7%BA%BF%E7%A8%8B%E5%88%A9%E7%94%A8%E7%8E%87%EF%BC%8C%E9%99%8D%E4%BD%8E%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B6%88%E8%80%97%E3%80%82"><span class="nav-text">1 、降低资源消耗；提高线程利用率，降低创建和销毁线程的消耗。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E3%80%81%E6%8F%90%E9%AB%98%E5%93%8D%E5%BA%94%E9%80%9F%E5%BA%A6%EF%BC%9B%E4%BB%BB%E5%8A%A1%E6%9D%A5%E4%BA%86%EF%BC%8C%E7%9B%B4%E6%8E%A5%E6%9C%89%E7%BA%BF%E7%A8%8B%E5%8F%AF%E7%94%A8%E5%8F%AF%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%88%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%86%8D%E6%89%A7%E8%A1%8C%E3%80%82"><span class="nav-text">2 、提高响应速度；任务来了，直接有线程可用可执行，而不是先创建线程，再执行。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E3%80%81%E6%8F%90%E9%AB%98%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%AF%E7%AE%A1%E7%90%86%E6%80%A7%EF%BC%9B%E7%BA%BF%E7%A8%8B%E6%98%AF%E7%A8%80%E7%BC%BA%E8%B5%84%E6%BA%90%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%AF%E4%BB%A5%E7%BB%9F%E4%B8%80%E5%88%86%E9%85%8D%E8%B0%83%E4%BC%98%E7%9B%91%E6%8E%A7%E3%80%82"><span class="nav-text">3 、提高线程的可管理性；线程是稀缺资源，使用线程池可以统一分配调优监控。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-text">简述线程池处理流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%88%E6%B7%BB%E5%8A%A0%E5%88%97%E9%98%9F%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%88"><span class="nav-text">线程池中阻塞队列的作用？为什么是先添加列队而不是先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">创建最大线程？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E3%80%81%E4%B8%80%E8%88%AC%E7%9A%84%E9%98%9F%E5%88%97%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%9C%89%E9%99%90%E9%95%BF%E5%BA%A6%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%B6%85%E5%87%BA%E4%BA%86%E7%BC%93%E5%86%B2%E9%95%BF%E5%BA%A6%EF%BC%8C%E5%B0%B1%E6%97%A0%E6%B3%95%E4%BF%9D%E7%95%99%E5%BD%93%E5%89%8D%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="nav-text">1 、一般的队列只能保证作为一个有限长度的缓冲区，如果超出了缓冲长度，就无法保留当前的任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%86%EF%BC%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E9%80%9A%E8%BF%87%E9%98%BB%E5%A1%9E%E5%8F%AF%E4%BB%A5%E4%BF%9D%E7%95%99%E4%BD%8F%E5%BD%93%E5%89%8D%E6%83%B3%E8%A6%81%E7%BB%A7%E7%BB%AD%E5%85%A5%E9%98%9F%E7%9A%84%E4%BB%BB%E5%8A%A1%E3%80%82"><span class="nav-text">了，阻塞队列通过阻塞可以保留住当前想要继续入队的任务。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E3%80%81%E5%9C%A8%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%98%AF%E8%A6%81%E8%8E%B7%E5%8F%96%E5%85%A8%E5%B1%80%E9%94%81%E7%9A%84%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99%E5%85%B6%E5%AE%83%E7%9A%84%E5%B0%B1%E5%BE%97%E9%98%BB%E5%A1%9E%EF%BC%8C%E5%BD%B1%E5%93%8D%E4%BA%86%E6%95%B4%E4%BD%93%E6%95%88%E7%8E%87%E3%80%82"><span class="nav-text">2 、在创建新线程的时候，是要获取全局锁的，这个时候其它的就得阻塞，影响了整体效率。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86"><span class="nav-text">线程池中线程复用原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring"><span class="nav-text">spring</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAIOC%E5%AE%B9%E5%99%A8"><span class="nav-text">如何实现一个IOC容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E5%8C%85%E6%89%AB%E6%8F%8F%E8%B7%AF%E5%BE%84"><span class="nav-text">1 、配置文件配置包扫描路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E6%8C%87%E5%AE%9A%E9%9C%80%E8%A6%81%E6%89%AB%E6%8F%8F%E7%9A%84%E5%8C%85%E8%B7%AF%E5%BE%84"><span class="nav-text">配置文件中指定需要扫描的包路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%BA%9B%E6%B3%A8%E8%A7%A3%EF%BC%8C%E5%88%86%E5%88%AB%E8%A1%A8%E7%A4%BA%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%B1%82%E3%80%81%E4%B8%9A%E5%8A%A1%E6%9C%8D%E5%8A%A1%E5%B1%82%E3%80%81%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%B1%82%E3%80%81%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%B3%A8%E8%A7%A3%E3%80%81%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%B3%A8"><span class="nav-text">定义一些注解，分别表示访问控制层、业务服务层、数据持久层、依赖注入注解、获取配置文件注</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3"><span class="nav-text">解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E8%8E%B7%E5%8F%96%E9%9C%80%E8%A6%81%E6%89%AB%E6%8F%8F%E7%9A%84%E5%8C%85%E8%B7%AF%E5%BE%84%EF%BC%8C%E8%8E%B7%E5%8F%96%E5%88%B0%E5%BD%93%E5%89%8D%E8%B7%AF%E5%BE%84%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BF%A1%E6%81%AF%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%86%E5%BD%93%E5%89%8D%E8%B7%AF"><span class="nav-text">从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息及文件夹信息，我们将当前路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">spring是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9AOP%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">谈谈你对AOP的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%98%AF%E7%94%B1%E8%AE%B8%E5%A4%9A%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BB%84%E4%BB%B6%E6%89%80%E7%BB%84%E6%88%90%E7%9A%84%EF%BC%8C%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%E5%90%84%E8%B4%9F%E8%B4%A3%E4%B8%80%E5%9D%97%E7%89%B9%E5%AE%9A%E5%8A%9F%E8%83%BD%E3%80%82%E9%99%A4%E4%BA%86%E5%AE%9E%E7%8E%B0%E8%87%AA%E8%BA%AB%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B9%8B%E5%A4%96%EF%BC%8C%E8%BF%99"><span class="nav-text">系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%9B%E7%BB%84%E4%BB%B6%E8%BF%98%E7%BB%8F%E5%B8%B8%E6%89%BF%E6%8B%85%E7%9D%80%E9%A2%9D%E5%A4%96%E7%9A%84%E8%81%8C%E8%B4%A3%E3%80%82%E4%BE%8B%E5%A6%82%E6%97%A5%E5%BF%97%E3%80%81%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%92%8C%E5%AE%89%E5%85%A8%E8%BF%99%E6%A0%B7%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%B8%B8%E8%9E%8D%E5%85%A5%E5%88%B0%E8%87%AA%E8%BA%AB%E5%85%B7%E6%9C%89%E6%A0%B8%E5%BF%83"><span class="nav-text">些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E7%9A%84%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%8E%BB%E3%80%82%E8%BF%99%E4%BA%9B%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%B8%B8%E8%A2%AB%E7%A7%B0%E4%B8%BA%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AE%83%E4%BB%AC%E4%BC%9A%E8%B7%A8%E8%B6%8A%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%E3%80%82"><span class="nav-text">业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E4%B8%BA%E5%88%86%E6%95%A3%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E5%85%A5%E5%85%AC%E5%85%B1%E8%A1%8C%E4%B8%BA%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8COOP%E5%88%99%E6%98%BE%E5%BE%97%E6%97%A0%E8%83%BD%E4%B8%BA%E5%8A%9B%E3%80%82%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8COOP%E5%85%81%E8%AE%B8%E4%BD%A0%E5%AE%9A%E4%B9%89%E4%BB%8E"><span class="nav-text">当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E5%88%B0%E4%B8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E4%BD%86%E5%B9%B6%E4%B8%8D%E9%80%82%E5%90%88%E5%AE%9A%E4%B9%89%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%E5%85%B3%E7%B3%BB%E3%80%82%E4%BE%8B%E5%A6%82%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD%E3%80%82"><span class="nav-text">上到下的关系，但并不适合定义从左到右的关系。例如日志功能。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E4%BB%A3%E7%A0%81%E5%BE%80%E5%BE%80%E6%B0%B4%E5%B9%B3%E5%9C%B0%E6%95%A3%E5%B8%83%E5%9C%A8%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E5%B1%82%E6%AC%A1%E4%B8%AD%EF%BC%8C%E8%80%8C%E4%B8%8E%E5%AE%83%E6%89%80%E6%95%A3%E5%B8%83%E5%88%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E6%AF%AB%E6%97%A0%E5%85%B3%E7%B3%BB%E3%80%82"><span class="nav-text">日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8OOP%E8%AE%BE%E8%AE%A1%E4%B8%AD%EF%BC%8C%E5%AE%83%E5%AF%BC%E8%87%B4%E4%BA%86%E5%A4%A7%E9%87%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E9%87%8D%E5%A4%8D%EF%BC%8C%E8%80%8C%E4%B8%8D%E5%88%A9%E4%BA%8E%E5%90%84%E4%B8%AA%E6%A8%A1%E5%9D%97%E7%9A%84%E9%87%8D%E7%94%A8%E3%80%82"><span class="nav-text">在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOP%EF%BC%9A%E5%B0%86%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E4%BA%A4%E5%8F%89%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%EF%BC%88%E6%AF%94%E5%A6%82%E5%AE%89%E5%85%A8%EF%BC%8C%E6%97%A5%E5%BF%97%EF%BC%8C%E4%BA%8B%E5%8A%A1%E7%AD%89%EF%BC%89%EF%BC%8C%E5%B0%81%E8%A3%85%E6%88%90%E4%B8%80%E4%B8%AA%E5%88%87%E9%9D%A2%EF%BC%8C%E7%84%B6%E5%90%8E%E6%B3%A8%E5%85%A5%E5%88%B0%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1"><span class="nav-text">AOP：将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%88%E5%85%B7%E4%BD%93%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%EF%BC%89%E4%B8%AD%E5%8E%BB%E3%80%82AOP%E5%8F%AF%E4%BB%A5%E5%AF%B9%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%88%96%E6%9F%90%E4%BA%9B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%BC%BA%EF%BC%8C%E6%AF%94%E5%A6%82%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%A2%9E"><span class="nav-text">（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%89%A7%E8%A1%8C%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E4%B9%8B%E5%89%8D%E9%A2%9D%E5%A4%96%E7%9A%84%E5%81%9A%E4%B8%80%E4%BA%9B%E4%BA%8B%E6%83%85%EF%BC%8C%E5%9C%A8%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%90%8E%E9%A2%9D%E5%A4%96%E7%9A%84%E5%81%9A%E4%B8%80%E4%BA%9B%E4%BA%8B%E6%83%85"><span class="nav-text">强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9IOC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">谈谈你对IOC的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E6%A6%82%E5%BF%B5%E3%80%81%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E3%80%81%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-text">容器概念、控制反转、依赖注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%9A"><span class="nav-text">控制反转：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89%E5%BC%95%E5%85%A5IOC%E5%AE%B9%E5%99%A8%E4%B9%8B%E5%89%8D%EF%BC%8C%E5%AF%B9%E8%B1%A1A%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%AF%B9%E8%B1%A1B%EF%BC%8C%E9%82%A3%E4%B9%88%E5%AF%B9%E8%B1%A1A%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%96%E8%80%85%E8%BF%90%E8%A1%8C%E5%88%B0%E6%9F%90%E4%B8%80%E7%82%B9%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%87%AA%E5%B7%B1%E5%BF%85%E9%A1%BB"><span class="nav-text">没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%8A%A8%E5%8E%BB%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1B%E6%88%96%E8%80%85%E4%BD%BF%E7%94%A8%E5%B7%B2%E7%BB%8F%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AF%B9%E8%B1%A1B%E3%80%82%E6%97%A0%E8%AE%BA%E6%98%AF%E5%88%9B%E5%BB%BA%E8%BF%98%E6%98%AF%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1B%EF%BC%8C%E6%8E%A7%E5%88%B6%E6%9D%83%E9%83%BD%E5%9C%A8%E8%87%AA%E5%B7%B1%E6%89%8B%E4%B8%8A%E3%80%82"><span class="nav-text">主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%85%A5IOC%E5%AE%B9%E5%99%A8%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%AF%B9%E8%B1%A1A%E4%B8%8E%E5%AF%B9%E8%B1%A1B%E4%B9%8B%E9%97%B4%E5%A4%B1%E5%8E%BB%E4%BA%86%E7%9B%B4%E6%8E%A5%E8%81%94%E7%B3%BB%EF%BC%8C%E5%BD%93%E5%AF%B9%E8%B1%A1A%E8%BF%90%E8%A1%8C%E5%88%B0%E9%9C%80%E8%A6%81%E5%AF%B9%E8%B1%A1B%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8CIOC%E5%AE%B9%E5%99%A8%E4%BC%9A"><span class="nav-text">引入IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运行到需要对象B的时候，IOC容器会</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%8A%A8%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1B%E6%B3%A8%E5%85%A5%E5%88%B0%E5%AF%B9%E8%B1%A1A%E9%9C%80%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9%E3%80%82"><span class="nav-text">主动创建一个对象B注入到对象A需要的地方。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%89%8D%E5%90%8E%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%8C%E4%B8%8D%E9%9A%BE%E7%9C%8B%E5%87%BA%E6%9D%A5%EF%BC%9A%E5%AF%B9%E8%B1%A1A%E8%8E%B7%E5%BE%97%E4%BE%9D%E8%B5%96%E5%AF%B9%E8%B1%A1B%E7%9A%84%E8%BF%87%E7%A8%8B-%E7%94%B1%E4%B8%BB%E5%8A%A8%E8%A1%8C%E4%B8%BA%E5%8F%98%E4%B8%BA%E4%BA%86%E8%A2%AB%E5%8A%A8%E8%A1%8C%E4%B8%BA%EF%BC%8C%E6%8E%A7%E5%88%B6%E6%9D%83%E9%A2%A0%E5%80%92"><span class="nav-text">通过前后的对比，不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%9D%A5%E4%BA%86%EF%BC%8C%E8%BF%99%E5%B0%B1%E6%98%AF%E2%80%9C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E2%80%9D%E8%BF%99%E4%B8%AA%E5%90%8D%E7%A7%B0%E7%9A%84%E7%94%B1%E6%9D%A5%E3%80%82"><span class="nav-text">过来了，这就是“控制反转”这个名称的由来。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E9%83%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%9D%83%E5%85%A8%E9%83%A8%E4%B8%8A%E7%BC%B4%E7%BB%99%E2%80%9C%E7%AC%AC%E4%B8%89%E6%96%B9%E2%80%9DIOC%E5%AE%B9%E5%99%A8%EF%BC%8C%E6%89%80%E4%BB%A5%EF%BC%8CIOC%E5%AE%B9%E5%99%A8%E6%88%90%E4%BA%86%E6%95%B4%E4%B8%AA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B3%E9%94%AE%E6%A0%B8%E5%BF%83%EF%BC%8C%E5%AE%83%E8%B5%B7%E5%88%B0%E4%BA%86%E4%B8%80"><span class="nav-text">全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%8D%E7%B1%BB%E4%BC%BC%E2%80%9C%E7%B2%98%E5%90%88%E5%89%82%E2%80%9D%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E6%8A%8A%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E7%B2%98%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%8F%91%E6%8C%A5%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E8%BF%99%E4%B8%AA%E2%80%9C%E7%B2%98%E5%90%88%E5%89%82%E2%80%9D%EF%BC%8C%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AF%B9"><span class="nav-text">种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B1%A1%E4%B9%8B%E9%97%B4%E4%BC%9A%E5%BD%BC%E6%AD%A4%E5%A4%B1%E5%8E%BB%E8%81%94%E7%B3%BB%EF%BC%8C%E8%BF%99%E5%B0%B1%E6%98%AF%E6%9C%89%E4%BA%BA%E6%8A%8AIOC%E5%AE%B9%E5%99%A8%E6%AF%94%E5%96%BB%E6%88%90%E2%80%9C%E7%B2%98%E5%90%88%E5%89%82%E2%80%9D%E7%9A%84%E7%94%B1%E6%9D%A5%E3%80%82"><span class="nav-text">象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9A"><span class="nav-text">依赖注入：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%80%9C%E8%8E%B7%E5%BE%97%E4%BE%9D%E8%B5%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E8%A2%AB%E5%8F%8D%E8%BD%AC%E4%BA%86%E2%80%9D%E3%80%82%E6%8E%A7%E5%88%B6%E8%A2%AB%E5%8F%8D%E8%BD%AC%E4%B9%8B%E5%90%8E%EF%BC%8C%E8%8E%B7%E5%BE%97%E4%BE%9D%E8%B5%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E7%94%B1%E8%87%AA%E8%BA%AB%E7%AE%A1%E7%90%86%E5%8F%98%E4%B8%BA%E4%BA%86%E7%94%B1IOC%E5%AE%B9%E5%99%A8"><span class="nav-text">“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%8A%A8%E6%B3%A8%E5%85%A5%E3%80%82%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%98%AF%E5%AE%9E%E7%8E%B0IOC%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B0%B1%E6%98%AF%E7%94%B1IOC%E5%AE%B9%E5%99%A8%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%97%B4%EF%BC%8C%E5%8A%A8%E6%80%81%E5%9C%B0%E5%B0%86%E6%9F%90%E7%A7%8D%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%B3%A8%E5%85%A5%E5%88%B0%E5%AF%B9"><span class="nav-text">主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B1%A1%E4%B9%8B%E4%B8%AD%E3%80%82"><span class="nav-text">象之中。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BeanFactory%E5%92%8CApplicationContext%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">BeanFactory和ApplicationContext有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BSpring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="nav-text">描述一下Spring Bean的生命周期？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%8BSpring%E6%94%AF%E6%8C%81%E7%9A%84%E5%87%A0%E7%A7%8Dbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%82"><span class="nav-text">解释下Spring支持的几种bean的作用域。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8BBean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B9%88%EF%BC%9F"><span class="nav-text">Spring框架中的单例Bean是线程安全的么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">Spring 框架中都用到了哪些设计模式？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%EF%BC%9A%E7%94%B1%E4%B8%80%E4%B8%AA%E5%B7%A5%E5%8E%82%E7%B1%BB%E6%A0%B9%E6%8D%AE%E4%BC%A0%E5%85%A5%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8C%E5%8A%A8%E6%80%81%E5%86%B3%E5%AE%9A%E5%BA%94%E8%AF%A5%E5%88%9B%E5%BB%BA%E5%93%AA%E4%B8%80%E4%B8%AA%E4%BA%A7%E5%93%81%E7%B1%BB%E3%80%82"><span class="nav-text">简单工厂：由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-text">工厂方法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BB%85%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%B9%B6%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E8%AE%BF%E9%97%AE%E5%AE%83%E7%9A%84%E5%85%A8%E5%B1%80%E8%AE%BF%E9%97%AE%E7%82%B9"><span class="nav-text">单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-text">适配器模式：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9A"><span class="nav-text">动态代理：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-text">观察者模式：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-text">策略模式：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%EF%BC%9A%E7%88%B6%E7%B1%BB%E5%AE%9A%E4%B9%89%E4%BA%86%E9%AA%A8%E6%9E%B6%EF%BC%88%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E5%8F%8A%E9%A1%BA%E5%BA%8F%EF%BC%89%EF%BC%8C%E6%9F%90%E4%BA%9B%E7%89%B9%E5%AE%9A%E6%96%B9%E6%B3%95%E7%94%B1%E5%AD%90%E7%B1%BB%E5%AE%9E%E7%8E%B0%E3%80%82"><span class="nav-text">模板方法：父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%EF%BC%8C%E5%87%8F%E5%B0%91%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81%E3%80%82%E9%99%A4%E4%BA%86%E5%AD%90%E7%B1%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%89%B9%E5%AE%9A%E6%96%B9%E6%B3%95%EF%BC%8C%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%E5%8F%8A%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E9%83%BD%E5%9C%A8%E7%88%B6"><span class="nav-text">最大的好处：代码复用，减少重复代码。除了子类要实现的特定方法，其他方法及方法调用顺序都在父</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E4%B8%AD%E9%A2%84%E5%85%88%E5%86%99%E5%A5%BD%E4%BA%86%E3%80%82"><span class="nav-text">类中预先写好了。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9F"><span class="nav-text">Spring事务的实现方式和原理以及隔离级别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="nav-text">spring事务传播机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%B3%95%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E6%97%B6-%E4%BA%8B%E5%8A%A1%E5%A6%82%E4%BD%95%E5%9C%A8%E8%BF%99%E4%BA%9B%E6%96%B9%E6%B3%95%E9%97%B4%E4%BC%A0%E6%92%AD"><span class="nav-text">多个事务方法相互调用时,事务如何在这些方法间传播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SUPPORTS%EF%BC%9A%E5%BD%93%E5%89%8D%E5%AD%98%E5%9C%A8%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%88%99%E5%8A%A0%E5%85%A5%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E6%B2%A1%E6%9C%89%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%B0%B1%E4%BB%A5%E9%9D%9E%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C"><span class="nav-text">SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MANDATORY%EF%BC%9A%E5%BD%93%E5%89%8D%E5%AD%98%E5%9C%A8%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%88%99%E5%8A%A0%E5%85%A5%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E3%80%82"><span class="nav-text">MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#REQUIRES-NEW%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%AD%98%E5%9C%A8%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%88%99%E6%8C%82%E8%B5%B7%E8%AF%A5%E4%BA%8B%E5%8A%A1%E3%80%82"><span class="nav-text">REQUIRES_NEW：创建一个新事务，如果存在当前事务，则挂起该事务。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NOT-SUPPORTED%EF%BC%9A%E4%BB%A5%E9%9D%9E%E4%BA%8B%E5%8A%A1%E6%96%B9%E5%BC%8F%E6%89%A7%E8%A1%8C-%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E5%AD%98%E5%9C%A8%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%88%99%E6%8C%82%E8%B5%B7%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1"><span class="nav-text">NOT_SUPPORTED：以非事务方式执行,如果当前存在事务，则挂起当前事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NEVER%EF%BC%9A%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="nav-text">NEVER：不使用事务，如果当前事务存在，则抛出异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NESTED%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E5%9C%A8%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1%E4%B8%AD%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%90%A6%E5%88%99REQUIRED%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%80%E6%A0%B7%EF%BC%88%E5%BC%80%E5%90%AF%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1%EF%BC%89"><span class="nav-text">NESTED：如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样（开启一个事务）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring%E4%BA%8B%E5%8A%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88"><span class="nav-text">spring事务什么时候会失效?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1"><span class="nav-text">3 、数据库不支持事务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFbean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">什么是bean的自动装配，有哪些方式？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#springmvc%E3%80%81springBoot"><span class="nav-text">springmvc、springBoot</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Boot%E3%80%81Spring-MVC-%E5%92%8C-Spring-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-text">Spring Boot、Spring MVC 和 Spring 有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">SpringMVC 工作流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-MVC%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="nav-text">Spring MVC的主要组件？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Boot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-text">Spring Boot 自动配置原理？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Spring-Boot-%E4%B8%AD%E7%9A%84-Starter"><span class="nav-text">如何理解 Spring Boot 中的 Starter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">什么是嵌入式服务器？为什么要使用嵌入式服务器?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mybatis"><span class="nav-text">Mybatis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#mybatis%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">mybatis的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E3%80%81%E5%9F%BA%E4%BA%8E-SQL-%E8%AF%AD%E5%8F%A5%E7%BC%96%E7%A8%8B%EF%BC%8C%E7%9B%B8%E5%BD%93%E7%81%B5%E6%B4%BB%EF%BC%8C%E4%B8%8D%E4%BC%9A%E5%AF%B9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%88%96%E8%80%85%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%8E%B0%E6%9C%89%E8%AE%BE%E8%AE%A1%E9%80%A0%E6%88%90%E4%BB%BB%E4%BD%95%E5%BD%B1%E5%93%8D%EF%BC%8CSQL-%E5%86%99%E5%9C%A8"><span class="nav-text">1 、基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyBatis-%E4%B8%8EHibernate-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-text">MyBatis 与Hibernate 有哪些不同？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL-%E5%92%8C-ORM-%E7%9A%84%E4%BA%89%E8%AE%BA%EF%BC%8C%E6%B0%B8%E8%BF%9C%E9%83%BD%E4%B8%8D%E4%BC%9A%E7%BB%88%E6%AD%A2"><span class="nav-text">SQL 和 ORM 的争论，永远都不会终止</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E9%80%9F%E5%BA%A6%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9A"><span class="nav-text">开发速度的对比：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">#{}和${}的区别是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%AF%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%84%E7%90%86%E3%80%81%E6%98%AF%E5%8D%A0%E4%BD%8D%E7%AC%A6%EF%BC%8C-%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2%E3%80%81%E6%98%AF%E6%8B%BC%E6%8E%A5%E7%AC%A6%E3%80%82"><span class="nav-text">#{}是预编译处理、是占位符， ${}是字符串替换、是拼接符。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0-Mybatis-%E7%9A%84%E6%8F%92%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6%E3%80%82"><span class="nav-text">简述 Mybatis 的插件运行原理，如何编写一个插件。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql"><span class="nav-text">Mysql</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-text">索引的基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%94%A8%E6%9D%A5%E5%BF%AB%E9%80%9F%E5%9C%B0%E5%AF%BB%E6%89%BE%E9%82%A3%E4%BA%9B%E5%85%B7%E6%9C%89%E7%89%B9%E5%AE%9A%E5%80%BC%E7%9A%84%E8%AE%B0%E5%BD%95%E3%80%82%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%B8%80%E8%88%AC%E6%9D%A5%E8%AF%B4%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E6%97%B6%E9%81%8D%E5%8E%86%E6%95%B4%E5%BC%A0%E8%A1%A8%E3%80%82"><span class="nav-text">索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A%E5%B0%B1%E6%98%AF%E6%8A%8A%E6%97%A0%E5%BA%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%98%E6%88%90%E6%9C%89%E5%BA%8F%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="nav-text">索引的原理：就是把无序的数据变成有序的查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8A%8A%E5%88%9B%E5%BB%BA%E4%BA%86%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%97%E7%9A%84%E5%86%85%E5%AE%B9%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="nav-text">1. 把创建了索引的列的内容进行排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AF%B9%E6%8E%92%E5%BA%8F%E7%BB%93%E6%9E%9C%E7%94%9F%E6%88%90%E5%80%92%E6%8E%92%E8%A1%A8"><span class="nav-text">2. 对排序结果生成倒排表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%9C%A8%E5%80%92%E6%8E%92%E8%A1%A8%E5%86%85%E5%AE%B9%E4%B8%8A%E6%8B%BC%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%9C%B0%E5%9D%80%E9%93%BE"><span class="nav-text">3. 在倒排表内容上拼上数据地址链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%9C%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%85%88%E6%8B%BF%E5%88%B0%E5%80%92%E6%8E%92%E8%A1%A8%E5%86%85%E5%AE%B9%EF%BC%8C%E5%86%8D%E5%8F%96%E5%87%BA%E6%95%B0%E6%8D%AE%E5%9C%B0%E5%9D%80%E9%93%BE%EF%BC%8C%E4%BB%8E%E8%80%8C%E6%8B%BF%E5%88%B0%E5%85%B7%E4%BD%93%E6%95%B0%E6%8D%AE"><span class="nav-text">4. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql%E8%81%9A%E7%B0%87%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">mysql聚簇和非聚簇索引的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%BD%E6%98%AFB-%E6%A0%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">都是B+树的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%9A%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%94%BE%E5%88%B0%E4%BA%86%E4%B8%80%E5%9D%97%E3%80%81%E5%B9%B6%E4%B8%94%E6%98%AF%E6%8C%89%E7%85%A7%E4%B8%80%E5%AE%9A%E7%9A%84%E9%A1%BA%E5%BA%8F%E7%BB%84%E7%BB%87%E7%9A%84%EF%BC%8C%E6%89%BE%E5%88%B0%E7%B4%A2%E5%BC%95%E4%B9%9F%E5%B0%B1%E6%89%BE%E5%88%B0%E4%BA%86%E6%95%B0"><span class="nav-text">聚簇索引：将数据存储与索引放到了一块、并且是按照一定的顺序组织的，找到索引也就找到了数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%AE%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%A9%E7%90%86%E5%AD%98%E6%94%BE%E9%A1%BA%E5%BA%8F%E4%B8%8E%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%B8%80%E8%87%B4%E7%9A%84%EF%BC%8C%E5%8D%B3%EF%BC%9A%E5%8F%AA%E8%A6%81%E7%B4%A2%E5%BC%95%E6%98%AF%E7%9B%B8%E9%82%BB%E7%9A%84%EF%BC%8C%E9%82%A3%E4%B9%88%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E5%AE%9A%E4%B9%9F%E6%98%AF"><span class="nav-text">据，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E9%82%BB%E5%9C%B0%E5%AD%98%E6%94%BE%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%8A%E7%9A%84"><span class="nav-text">相邻地存放在磁盘上的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%9A%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E4%B8%8D%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E3%80%81%E5%AD%98%E5%82%A8%E7%9A%84%E6%98%AF%E6%95%B0%E6%8D%AE%E8%A1%8C%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%E6%A0%B9%E6%8D%AE%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E8%A1%8C%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-text">非聚簇索引：叶子节点不存储数据、存储的是数据行地址，也就是说根据索引查找到数据行的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E5%8F%96%E7%A3%81%E7%9B%98%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%B0%B1%E6%9C%89%E7%82%B9%E7%B1%BB%E4%BC%BC%E4%B8%80%E6%9C%AC%E6%A0%91%E7%9A%84%E7%9B%AE%E5%BD%95%EF%BC%8C%E6%AF%94%E5%A6%82%E6%88%91%E4%BB%AC%E8%A6%81%E6%89%BE%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%8C%E9%82%A3%E6%88%91%E4%BB%AC%E5%85%88%E5%9C%A8%E8%BF%99%E4%B8%AA"><span class="nav-text">再取磁盘查找数据，这个就有点类似一本树的目录，比如我们要找第三章第一节，那我们先在这个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E9%87%8C%E9%9D%A2%E6%89%BE%EF%BC%8C%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E9%A1%B5%E7%A0%81%E5%90%8E%E5%86%8D%E5%8E%BB%E5%AF%B9%E5%BA%94%E7%9A%84%E9%A1%B5%E7%A0%81%E7%9C%8B%E6%96%87%E7%AB%A0%E3%80%82"><span class="nav-text">目录里面找，找到对应的页码后再去对应的页码看文章。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%90%84%E8%87%AA%E4%BC%98%E5%8A%A3"><span class="nav-text">mysql索引的数据结构，各自优劣</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%EF%BC%9A"><span class="nav-text">哈希索引：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E5%B0%B1%E6%98%AF%E9%87%87%E7%94%A8%E4%B8%80%E5%AE%9A%E7%9A%84%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%8C%E6%8A%8A%E9%94%AE%E5%80%BC%E6%8D%A2%E7%AE%97%E6%88%90%E6%96%B0%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC%EF%BC%8C%E6%A3%80%E7%B4%A2%E6%97%B6%E4%B8%8D%E9%9C%80%E8%A6%81%E7%B1%BB%E4%BC%BCB-%E6%A0%91%E9%82%A3%E6%A0%B7%E4%BB%8E%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0"><span class="nav-text">哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E9%80%90%E7%BA%A7%E6%9F%A5%E6%89%BE%EF%BC%8C%E5%8F%AA%E9%9C%80%E4%B8%80%E6%AC%A1%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%8D%B3%E5%8F%AF%E7%AB%8B%E5%88%BB%E5%AE%9A%E4%BD%8D%E5%88%B0%E7%9B%B8%E5%BA%94%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E9%80%9F%E5%BA%A6%E9%9D%9E%E5%B8%B8%E5%BF%AB"><span class="nav-text">叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%98%AF%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%EF%BC%8C%E9%82%A3%E4%B9%88%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E6%98%8E%E6%98%BE%E6%9C%89%E7%BB%9D%E5%AF%B9%E4%BC%98%E5%8A%BF%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%8F%AA%E9%9C%80%E8%A6%81%E7%BB%8F%E8%BF%87%E4%B8%80%E6%AC%A1%E7%AE%97%E6%B3%95%E5%8D%B3%E5%8F%AF%E6%89%BE%E5%88%B0%E7%9B%B8%E5%BA%94%E7%9A%84%E9%94%AE%E5%80%BC%EF%BC%9B%E5%89%8D%E6%8F%90"><span class="nav-text">如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；前提</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%AF%E9%94%AE%E5%80%BC%E9%83%BD%E6%98%AF%E5%94%AF%E4%B8%80%E7%9A%84%E3%80%82%E5%A6%82%E6%9E%9C%E9%94%AE%E5%80%BC%E4%B8%8D%E6%98%AF%E5%94%AF%E4%B8%80%E7%9A%84%EF%BC%8C%E5%B0%B1%E9%9C%80%E8%A6%81%E5%85%88%E6%89%BE%E5%88%B0%E8%AF%A5%E9%94%AE%E6%89%80%E5%9C%A8%E4%BD%8D%E7%BD%AE%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E6%A0%B9%E6%8D%AE%E9%93%BE%E8%A1%A8%E5%BE%80%E5%90%8E%E6%89%AB%E6%8F%8F%EF%BC%8C%E7%9B%B4"><span class="nav-text">是键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%B0%E6%89%BE%E5%88%B0%E7%9B%B8%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9B"><span class="nav-text">到找到相应的数据；</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%98%AF%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E6%A3%80%E7%B4%A2%EF%BC%8C%E8%BF%99%E6%97%B6%E5%80%99%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E5%B0%B1%E6%AF%AB%E6%97%A0%E7%94%A8%E6%AD%A6%E4%B9%8B%E5%9C%B0%E4%BA%86%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%8E%9F%E5%85%88%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E9%94%AE%E5%80%BC%EF%BC%8C%E7%BB%8F%E8%BF%87%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%90%8E%EF%BC%8C"><span class="nav-text">如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%8F%AF%E8%83%BD%E5%8F%98%E6%88%90%E4%B8%8D%E8%BF%9E%E7%BB%AD%E7%9A%84%E4%BA%86%EF%BC%8C%E5%B0%B1%E6%B2%A1%E5%8A%9E%E6%B3%95%E5%86%8D%E5%88%A9%E7%94%A8%E7%B4%A2%E5%BC%95%E5%AE%8C%E6%88%90%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E6%A3%80%E7%B4%A2%EF%BC%9B"><span class="nav-text">有可能变成不连续的了，就没办法再利用索引完成范围查询检索；</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="nav-text">索引设计的原则？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%9B%B4%E5%BF%AB%E3%80%81%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%E6%9B%B4%E5%B0%8F"><span class="nav-text">查询更快、占用空间更小</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="nav-text">什么是最左前缀原则？什么是最左匹配原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-text">锁的类型有哪些</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B1%9E%E6%80%A7%E5%88%86%E7%B1%BB%EF%BC%9A%E5%85%B1%E4%BA%AB%E9%94%81%E3%80%81%E6%8E%92%E4%BB%96%E9%94%81%E3%80%82"><span class="nav-text">基于锁的属性分类：共享锁、排他锁。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%86%E7%B1%BB%EF%BC%9A%E8%A1%8C%E7%BA%A7%E9%94%81-INNODB-%E3%80%81%E8%A1%A8%E7%BA%A7%E9%94%81-INNODB%E3%80%81MYISAM-%E3%80%81%E9%A1%B5%E7%BA%A7%E9%94%81-BDB%E5%BC%95%E6%93%8E-%E3%80%81%E8%AE%B0%E5%BD%95%E9%94%81%E3%80%81%E9%97%B4"><span class="nav-text">基于锁的粒度分类：行级锁(INNODB)、表级锁(INNODB、MYISAM)、页级锁(BDB引擎 )、记录锁、间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%99%E9%94%81%E3%80%81%E4%B8%B4%E9%94%AE%E9%94%81%E3%80%82"><span class="nav-text">隙锁、临键锁。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81%E5%88%86%E7%B1%BB%EF%BC%9A%E6%84%8F%E5%90%91%E5%85%B1%E4%BA%AB%E9%94%81%E3%80%81%E6%84%8F%E5%90%91%E6%8E%92%E5%AE%83%E9%94%81%E3%80%82"><span class="nav-text">基于锁的状态分类：意向共享锁、意向排它锁。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E9%94%81"><span class="nav-text">表锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E9%94%81"><span class="nav-text">行锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%94%81"><span class="nav-text">页锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%BD%93%E4%BA%8B%E5%8A%A1A%E5%8A%A0%E9%94%81%E6%88%90%E5%8A%9F%E4%B9%8B%E5%90%8E%E5%B0%B1%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E7%8A%B6%E6%80%81%E5%91%8A%E8%AF%89%E5%90%8E%E9%9D%A2%E7%9A%84%E4%BA%BA%EF%BC%8C%E5%B7%B2%E7%BB%8F%E6%9C%89%E4%BA%BA%E5%AF%B9%E8%A1%A8%E9%87%8C%E7%9A%84%E8%A1%8C%E5%8A%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E6%8E%92%E4%BB%96%E9%94%81"><span class="nav-text">如果当事务A加锁成功之后就设置一个状态告诉后面的人，已经有人对表里的行加了一个排他锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%86%EF%BC%8C%E4%BD%A0%E4%BB%AC%E4%B8%8D%E8%83%BD%E5%AF%B9%E6%95%B4%E4%B8%AA%E8%A1%A8%E5%8A%A0%E5%85%B1%E4%BA%AB%E9%94%81%E6%88%96%E6%8E%92%E5%AE%83%E9%94%81%E4%BA%86%EF%BC%8C%E9%82%A3%E4%B9%88%E5%90%8E%E9%9D%A2%E9%9C%80%E8%A6%81%E5%AF%B9%E6%95%B4%E4%B8%AA%E8%A1%A8%E5%8A%A0%E9%94%81%E7%9A%84%E4%BA%BA%E5%8F%AA%E9%9C%80%E8%A6%81%E8%8E%B7%E5%8F%96%E8%BF%99%E4%B8%AA%E7%8A%B6%E6%80%81"><span class="nav-text">了，你们不能对整个表加共享锁或排它锁了，那么后面需要对整个表加锁的人只需要获取这个状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%B1%E7%9F%A5%E9%81%93%E8%87%AA%E5%B7%B1%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%AF%E4%BB%A5%E5%AF%B9%E8%A1%A8%E5%8A%A0%E9%94%81%EF%BC%8C%E9%81%BF%E5%85%8D%E4%BA%86%E5%AF%B9%E6%95%B4%E4%B8%AA%E7%B4%A2%E5%BC%95%E6%A0%91%E7%9A%84%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E6%89%AB%E6%8F%8F%E6%98%AF%E5%90%A6%E5%8A%A0%E9%94%81%EF%BC%8C%E8%80%8C%E8%BF%99%E4%B8%AA%E7%8A%B6%E6%80%81%E5%B0%B1%E6%98%AF"><span class="nav-text">就知道自己是不是可以对表加锁，避免了对整个索引树的每个节点扫描是否加锁，而这个状态就是</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%84%8F%E5%90%91%E9%94%81%E3%80%82"><span class="nav-text">意向锁。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%84%8F%E5%90%91%E5%85%B1%E4%BA%AB%E9%94%81"><span class="nav-text">意向共享锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%84%8F%E5%90%91%E6%8E%92%E4%BB%96%E9%94%81"><span class="nav-text">意向排他锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%94%81%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-text">InnoDB存储引擎的锁的算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E5%BF%83%E8%BF%87%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E9%87%8C%E9%9D%A2%E7%9A%84sql%E8%80%97%E6%97%B6%E5%90%97%EF%BC%9F%E7%BB%9F%E8%AE%A1%E8%BF%87%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F%E5%AF%B9%E6%85%A2"><span class="nav-text">关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E9%83%BD%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E8%BF%87%EF%BC%9F"><span class="nav-text">查询都怎么优化过？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E9%99%A4%E4%BA%86%E4%BD%BF%E7%94%A8%E4%B8%BB%E9%94%AE%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%9F%A5%E8%AF%A2%EF%BC%8C%E5%85%B6%E4%BB%96%E7%9A%84%E9%83%BD%E4%BC%9A%E5%9C%A8%E6%B5%8B%E8%AF%95%E5%BA%93%E4%B8%8A%E6%B5%8B%E8%AF%95%E5%85%B6%E8%80%97%E6%97%B6%EF%BC%8C%E6%85%A2%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%B8%BB%E8%A6%81%E7%94%B1%E8%BF%90"><span class="nav-text">在业务系统中，除了使用主键进行的查询，其他的都会在测试库上测试其耗时，慢查询的统计主要由运</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%B4%E5%9C%A8%E5%81%9A%EF%BC%8C%E4%BC%9A%E5%AE%9A%E6%9C%9F%E5%B0%86%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%8F%8D%E9%A6%88%E7%BB%99%E6%88%91%E4%BB%AC%E3%80%82"><span class="nav-text">维在做，会定期将业务中的慢查询反馈给我们。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-text">事务的基本特性和隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7ACID%E5%88%86%E5%88%AB%E6%98%AF%EF%BC%9A"><span class="nav-text">事务基本特性ACID分别是：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7-%E6%8C%87%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E8%A6%81%E4%B9%88%E5%85%A8%E9%83%A8%E6%88%90%E5%8A%9F%EF%BC%8C%E8%A6%81%E4%B9%88%E5%85%A8%E9%83%A8%E5%A4%B1%E8%B4%A5%E3%80%82"><span class="nav-text">原子性 指的是一个事务中的操作要么全部成功，要么全部失败。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7-%E6%8C%87%E7%9A%84%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E6%98%AF%E4%BB%8E%E4%B8%80%E4%B8%AA%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%88%B0%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E7%8A%B6%E6%80%81%E3%80%82%E6%AF%94%E5%A6%82A%E8%BD%AC%E8%B4%A6%E7%BB%99B100%E5%9D%97%E9%92%B1%EF%BC%8C"><span class="nav-text">一致性 指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%87%E8%AE%BEA%E5%8F%AA%E6%9C%89-90-%E5%9D%97%EF%BC%8C%E6%94%AF%E4%BB%98%E4%B9%8B%E5%89%8D%E6%88%91%E4%BB%AC%E6%95%B0%E6%8D%AE%E5%BA%93%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%AC%A6%E5%90%88%E7%BA%A6%E6%9D%9F%E7%9A%84-%E4%BD%86%E6%98%AF%E5%A6%82%E6%9E%9C%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%88%90%E5%8A%9F%E4%BA%86-%E6%88%91%E4%BB%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">假设A只有 90 块，支付之前我们数据库里的数据都是符合约束的,但是如果事务执行成功了,我们的数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%B0%B1%E7%A0%B4%E5%9D%8F%E7%BA%A6%E6%9D%9F%E4%BA%86-%E5%9B%A0%E6%AD%A4%E4%BA%8B%E5%8A%A1%E4%B8%8D%E8%83%BD%E6%88%90%E5%8A%9F-%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E8%AF%B4%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E4%BF%9D%E8%AF%81"><span class="nav-text">数据就破坏约束了,因此事务不能成功,这里我们说事务提供了一致性的保证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7-%E6%8C%87%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%9C%A8%E6%9C%80%E7%BB%88%E6%8F%90%E4%BA%A4%E5%89%8D%EF%BC%8C%E5%AF%B9%E5%85%B6%E4%BB%96%E4%BA%8B%E5%8A%A1%E6%98%AF%E4%B8%8D%E5%8F%AF%E8%A7%81%E7%9A%84%E3%80%82"><span class="nav-text">隔离性 指的是一个事务的修改在最终提交前，对其他事务是不可见的。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7-%E6%8C%87%E7%9A%84%E6%98%AF%E4%B8%80%E6%97%A6%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%EF%BC%8C%E6%89%80%E5%81%9A%E7%9A%84%E4%BF%AE%E6%94%B9%E5%B0%B1%E4%BC%9A%E6%B0%B8%E4%B9%85%E4%BF%9D%E5%AD%98%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E3%80%82"><span class="nav-text">持久性 指的是一旦事务提交，所做的修改就会永久保存到数据库中。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7%E6%9C%89-4-%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%EF%BC%9A"><span class="nav-text">隔离性有 4 个隔离级别，分别是：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ACID%E9%9D%A0%E4%BB%80%E4%B9%88%E4%BF%9D%E8%AF%81%E7%9A%84%EF%BC%9F"><span class="nav-text">ACID靠什么保证的？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I%E9%9A%94%E7%A6%BB%E6%80%A7%E7%94%B1MVCC%E6%9D%A5%E4%BF%9D%E8%AF%81"><span class="nav-text">I隔离性由MVCC来保证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMVCC"><span class="nav-text">什么是MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%9A%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E6%97%B6%E9%80%9A%E8%BF%87%E4%B8%80%E7%A7%8D%E7%B1%BB%E4%BC%BC%E5%BF%AB%E7%85%A7%E7%9A%84%E6%96%B9%E5%BC%8F%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E4%B8%8B%E6%9D%A5%EF%BC%8C%E8%BF%99%E6%A0%B7%E8%AF%BB%E9%94%81%E5%B0%B1%E5%92%8C%E5%86%99%E9%94%81%E4%B8%8D%E5%86%B2%E7%AA%81%E4%BA%86%EF%BC%8C"><span class="nav-text">多版本并发控制：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E8%AE%B0%E5%BD%95%E4%B8%AD%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%BF%85%E8%A6%81%E7%9A%84%E9%9A%90%E8%97%8F%E5%88%97%EF%BC%9A"><span class="nav-text">聚簇索引记录中有两个必要的隐藏列：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E8%A1%A8%E5%90%8E%E9%9D%9Esharding-key%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%8C%E5%88%86%E8%A1%A8%E5%90%8E%E7%9A%84%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="nav-text">分表后非sharding_key的查询怎么处理，分表后的排序？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="nav-text">mysql主从同步原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0MyISAM%E5%92%8CInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">简述MyISAM和InnoDB的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0mysql%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-text">简述mysql中索引类型及对数据库的性能的影响</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%EF%BC%9A%E5%85%81%E8%AE%B8%E8%A2%AB%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%97%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E7%9A%84%E5%80%BC%E3%80%82"><span class="nav-text">普通索引：允许被索引的数据列包含重复的值。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%9A%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7%E3%80%82"><span class="nav-text">唯一索引：可以保证数据记录的唯一性。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%EF%BC%9A%E6%98%AF%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%9C%A8%E4%B8%80%E5%BC%A0%E8%A1%A8%E4%B8%AD%E5%8F%AA%E8%83%BD%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%B8%BB%E9%94%AE%E7%94%A8%E4%BA%8E%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%EF%BC%8C%E4%BD%BF%E7%94%A8"><span class="nav-text">主键：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-PRIMARY-KEY-%E6%9D%A5%E5%88%9B%E5%BB%BA%E3%80%82"><span class="nav-text">关键字 PRIMARY KEY 来创建。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%8F%AF%E4%BB%A5%E6%9E%81%E5%A4%A7%E7%9A%84%E6%8F%90%E9%AB%98%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E3%80%82"><span class="nav-text">索引可以极大的提高数据的查询速度。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96%E9%9A%90%E8%97%8F%E5%99%A8%EF%BC%8C%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD%E3%80%82"><span class="nav-text">通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%86%E6%98%AF%E4%BC%9A%E9%99%8D%E4%BD%8E%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E6%9B%B4%E6%96%B0%E8%A1%A8%E7%9A%84%E9%80%9F%E5%BA%A6%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%9C%A8%E6%89%A7%E8%A1%8C%E8%BF%99%E4%BA%9B%E5%86%99%E6%93%8D%E4%BD%9C%E6%97%B6%EF%BC%8C%E8%BF%98%E8%A6%81%E6%93%8D%E4%BD%9C%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="nav-text">但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E9%9C%80%E8%A6%81%E5%8D%A0%E7%89%A9%E7%90%86%E7%A9%BA%E9%97%B4%EF%BC%8C%E9%99%A4%E4%BA%86%E6%95%B0%E6%8D%AE%E8%A1%A8%E5%8D%A0%E6%95%B0%E6%8D%AE%E7%A9%BA%E9%97%B4%E4%B9%8B%E5%A4%96%EF%BC%8C%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%E8%BF%98%E8%A6%81%E5%8D%A0%E4%B8%80%E5%AE%9A%E7%9A%84%E7%89%A9%E7%90%86%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%A6%81%E5%BB%BA%E7%AB%8B%E8%81%9A"><span class="nav-text">索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%8C%E9%82%A3%E4%B9%88%E9%9C%80%E8%A6%81%E7%9A%84%E7%A9%BA%E9%97%B4%E5%B0%B1%E4%BC%9A%E6%9B%B4%E5%A4%A7%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%BE%88%E5%A4%9A%EF%BC%8C%E4%B8%80%E6%97%A6%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E6%94%B9%E5%8F%98%EF%BC%8C%E9%82%A3%E4%B9%88%E6%89%80%E6%9C%89%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E9%83%BD"><span class="nav-text">簇索引，那么需要的空间就会更大，如果非聚集索引很多，一旦聚集索引改变，那么所有非聚集索引都</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%9A%E8%B7%9F%E7%9D%80%E5%8F%98%E3%80%82"><span class="nav-text">会跟着变。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E6%80%8E%E4%B9%88%E7%9C%8B"><span class="nav-text">mysql执行计划怎么看</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis"><span class="nav-text">redis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB-%E5%92%8C-AOF-%E6%9C%BA%E5%88%B6"><span class="nav-text">RDB 和 AOF 机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E3%80%81AOF-%E6%96%87%E4%BB%B6%E6%AF%94-RDB-%E6%96%87%E4%BB%B6%E5%A4%A7%EF%BC%8C%E4%B8%94%E6%81%A2%E5%A4%8D%E9%80%9F%E5%BA%A6%E6%85%A2%E3%80%82"><span class="nav-text">1 、AOF 文件比 RDB 文件大，且恢复速度慢。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF%E6%96%87%E4%BB%B6%E6%AF%94RDB%E6%9B%B4%E6%96%B0%E9%A2%91%E7%8E%87%E9%AB%98%EF%BC%8C%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8AOF%E8%BF%98%E5%8E%9F%E6%95%B0%E6%8D%AE%E3%80%82"><span class="nav-text">AOF文件比RDB更新频率高，优先使用AOF还原数据。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF%E6%AF%94RDB%E6%9B%B4%E5%AE%89%E5%85%A8%E4%B9%9F%E6%9B%B4%E5%A4%A7"><span class="nav-text">AOF比RDB更安全也更大</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB%E6%80%A7%E8%83%BD%E6%AF%94AOF%E5%A5%BD"><span class="nav-text">RDB性能比AOF好</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%A4%E4%B8%AA%E9%83%BD%E9%85%8D%E4%BA%86%E4%BC%98%E5%85%88%E5%8A%A0%E8%BD%BDAOF"><span class="nav-text">如果两个都配了优先加载AOF</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%9A%84%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-text">Redis的过期键的删除策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E3%80%81%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%BF%AB%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-text">Redis线程模型、单线程快的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%BF%AB%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="nav-text">单线程快的原因：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%EF%BC%89%E7%BA%AF%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C"><span class="nav-text">1 ）纯内存操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%EF%BC%89%E6%A0%B8%E5%BF%83%E6%98%AF%E5%9F%BA%E4%BA%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="nav-text">2 ）核心是基于非阻塞的IO多路复用机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%EF%BC%89%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%8F%8D%E8%80%8C%E9%81%BF%E5%85%8D%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%A2%91%E7%B9%81%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-text">3 ）单线程反而避免了多线程的频繁上下文切换带来的性能问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0Redis%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0"><span class="nav-text">简述Redis事务实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E3%80%81%E4%BA%8B%E5%8A%A1%E5%BC%80%E5%A7%8B"><span class="nav-text">1 、事务开始</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88"><span class="nav-text">redis集群方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E"><span class="nav-text">主从</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-text">哨兵模式：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%8F%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87%E4%BC%9A%E5%AD%98%E5%82%A8%E5%9C%A8%E5%A4%9A%E4%B8%AA%E4%BA%92%E4%B8%BA%E4%B8%BB%E4%BB%8E%E7%9A%84%E5%A4%9A%E8%8A%82%E7%82%B9%E4%B8%8A"><span class="nav-text">每份数据分片会存储在多个互为主从的多节点上</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%85%88%E5%86%99%E4%B8%BB%E8%8A%82%E7%82%B9%EF%BC%8C%E5%86%8D%E5%90%8C%E6%AD%A5%E5%88%B0%E4%BB%8E%E8%8A%82%E7%82%B9-%E6%94%AF%E6%8C%81%E9%85%8D%E7%BD%AE%E4%B8%BA%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5"><span class="nav-text">数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E4%B8%80%E5%88%86%E7%89%87%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%BF%9D%E6%8C%81%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-text">同一分片多个节点间的数据不保持强一致性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="nav-text">redis 主从复制的核心原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-text">缓存雪崩、缓存穿透、缓存击穿</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E6%98%AF%E6%8C%87%E7%BC%93%E5%AD%98%E5%90%8C%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%A7%E9%9D%A2%E7%A7%AF%E7%9A%84%E5%A4%B1%E6%95%88%EF%BC%8C%E6%89%80%E4%BB%A5%EF%BC%8C%E5%90%8E%E9%9D%A2%E7%9A%84%E8%AF%B7%E6%B1%82%E9%83%BD%E4%BC%9A%E8%90%BD%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8A%EF%BC%8C%E9%80%A0%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%AD%E6%97%B6%E9%97%B4%E5%86%85"><span class="nav-text">缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%BF%E5%8F%97%E5%A4%A7%E9%87%8F%E8%AF%B7%E6%B1%82%E8%80%8C%E5%B4%A9%E6%8E%89%E3%80%82"><span class="nav-text">承受大量请求而崩掉。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="nav-text">解决方案：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE%E9%9A%8F%E6%9C%BA%EF%BC%8C%E9%98%B2%E6%AD%A2%E5%90%8C%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F%E7%8E%B0%E8%B1%A1%E5%8F%91%E7%94%9F%E3%80%82"><span class="nav-text">缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%99%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%8A%A0%E7%9B%B8%E5%BA%94%E7%9A%84%E7%BC%93%E5%AD%98%E6%A0%87%E8%AE%B0%EF%BC%8C%E8%AE%B0%E5%BD%95%E7%BC%93%E5%AD%98%E6%98%AF%E5%90%A6%E5%A4%B1%E6%95%88%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%BC%93%E5%AD%98%E6%A0%87%E8%AE%B0%E5%A4%B1%E6%95%88%EF%BC%8C%E5%88%99%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BC%93"><span class="nav-text">给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E3%80%82"><span class="nav-text">存。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="nav-text">缓存预热</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E6%98%AF%E6%8C%87%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%83%BD%E6%B2%A1%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%89%80%E6%9C%89%E7%9A%84%E8%AF%B7%E6%B1%82%E9%83%BD%E8%90%BD%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8A%EF%BC%8C%E9%80%A0%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%AD%E6%97%B6%E9%97%B4%E5%86%85%E6%89%BF"><span class="nav-text">缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%97%E5%A4%A7%E9%87%8F%E8%AF%B7%E6%B1%82%E8%80%8C%E5%B4%A9%E6%8E%89%E3%80%82"><span class="nav-text">受大量请求而崩掉。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A-1"><span class="nav-text">解决方案：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%98%AF%E6%8C%87%E7%BC%93%E5%AD%98%E4%B8%AD%E6%B2%A1%E6%9C%89%E4%BD%86%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%80%E8%88%AC%E6%98%AF%E7%BC%93%E5%AD%98%E6%97%B6%E9%97%B4%E5%88%B0%E6%9C%9F%EF%BC%89%EF%BC%8C%E8%BF%99%E6%97%B6%E7%94%B1%E4%BA%8E%E5%B9%B6%E5%8F%91%E7%94%A8%E6%88%B7%E7%89%B9%E5%88%AB%E5%A4%9A%EF%BC%8C%E5%90%8C"><span class="nav-text">缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E8%AF%BB%E7%BC%93%E5%AD%98%E6%B2%A1%E8%AF%BB%E5%88%B0%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%8F%88%E5%90%8C%E6%97%B6%E5%8E%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%BB%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%BC%95%E8%B5%B7%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%8B%E5%8A%9B%E7%9E%AC%E9%97%B4%E5%A2%9E%E5%A4%A7%EF%BC%8C%E9%80%A0%E6%88%90%E8%BF%87%E5%A4%A7%E5%8E%8B%E5%8A%9B%E3%80%82%E5%92%8C%E7%BC%93%E5%AD%98%E9%9B%AA"><span class="nav-text">时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B4%A9%E4%B8%8D%E5%90%8C%E7%9A%84%E6%98%AF%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%8C%87%E5%B9%B6%E5%8F%91%E6%9F%A5%E5%90%8C%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E6%98%AF%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E9%83%BD%E8%BF%87%E6%9C%9F%E4%BA%86%EF%BC%8C%E5%BE%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E9%83%BD%E6%9F%A5%E4%B8%8D%E5%88%B0%E4%BB%8E%E8%80%8C%E6%9F%A5"><span class="nav-text">崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%82"><span class="nav-text">数据库。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%BF%87%E6%9C%9F%E3%80%82"><span class="nav-text">设置热点数据永远不过期。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-text">加互斥锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="nav-text">分布式&#x2F;微服务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CAP%E7%90%86%E8%AE%BA%EF%BC%8CBASE%E7%90%86%E8%AE%BA"><span class="nav-text">CAP理论，BASE理论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E3%80%81%E7%B1%BB%E5%9E%8B"><span class="nav-text">负载均衡算法、类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E3%80%81%E8%BD%AE%E8%AF%A2%E6%B3%95"><span class="nav-text">1 、轮询法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E8%AF%B7%E6%B1%82%E6%8C%89%E9%A1%BA%E5%BA%8F%E8%BD%AE%E6%B5%81%E5%9C%B0%E5%88%86%E9%85%8D%E5%88%B0%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%EF%BC%8C%E5%AE%83%E5%9D%87%E8%A1%A1%E5%9C%B0%E5%AF%B9%E5%BE%85%E5%90%8E%E7%AB%AF%E7%9A%84%E6%AF%8F%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E8%80%8C%E4%B8%8D%E5%85%B3%E5%BF%83%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E9%99%85%E7%9A%84"><span class="nav-text">将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E6%95%B0%E5%92%8C%E5%BD%93%E5%89%8D%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD%E3%80%82"><span class="nav-text">连接数和当前的系统负载。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E3%80%81%E9%9A%8F%E6%9C%BA%E6%B3%95"><span class="nav-text">2 、随机法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95%EF%BC%8C%E6%A0%B9%E6%8D%AE%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%88%97%E8%A1%A8%E5%A4%A7%E5%B0%8F%E5%80%BC%E6%9D%A5%E9%9A%8F%E6%9C%BA%E9%80%89%E5%8F%96%E5%85%B6%E4%B8%AD%E7%9A%84%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E3%80%82%E7%94%B1%E6%A6%82%E7%8E%87%E7%BB%9F"><span class="nav-text">通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%90%86%E8%AE%BA%E5%8F%AF%E4%BB%A5%E5%BE%97%E7%9F%A5%EF%BC%8C%E9%9A%8F%E7%9D%80%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E6%AC%A1%E6%95%B0%E5%A2%9E%E5%A4%9A%EF%BC%8C"><span class="nav-text">计理论可以得知，随着客户端调用服务端的次数增多，</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E5%AE%9E%E9%99%85%E6%95%88%E6%9E%9C%E8%B6%8A%E6%9D%A5%E8%B6%8A%E6%8E%A5%E8%BF%91%E4%BA%8E%E5%B9%B3%E5%9D%87%E5%88%86%E9%85%8D%E8%B0%83%E7%94%A8%E9%87%8F%E5%88%B0%E5%90%8E%E7%AB%AF%E7%9A%84%E6%AF%8F%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%BD%AE%E8%AF%A2%E7%9A%84%E7%BB%93%E6%9E%9C%E3%80%82"><span class="nav-text">其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E3%80%81%E6%BA%90%E5%9C%B0%E5%9D%80%E5%93%88%E5%B8%8C%E6%B3%95"><span class="nav-text">3 、源地址哈希法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E5%9C%B0%E5%9D%80%E5%93%88%E5%B8%8C%E7%9A%84%E6%80%9D%E6%83%B3%E6%98%AF%E6%A0%B9%E6%8D%AE%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84IP%E5%9C%B0%E5%9D%80%EF%BC%8C%E9%80%9A%E8%BF%87%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E5%BE%97%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E6%95%B0%E5%80%BC%EF%BC%8C%E7%94%A8%E8%AF%A5%E6%95%B0%E5%80%BC%E5%AF%B9%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E7%9A%84%E5%A4%A7%E5%B0%8F%E8%BF%9B%E8%A1%8C%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97%EF%BC%8C%E5%BE%97%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%9C%E4%BE%BF%E6%98%AF%E5%AE%A2%E6%9C%8D%E7%AB%AF%E8%A6%81%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%BA%8F%E5%8F%B7%E3%80%82%E9%87%87%E7%94%A8%E6%BA%90%E5%9C%B0%E5%9D%80%E5%93%88%E5%B8%8C%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%B4%9F%E8%BD%BD%E5%9D%87"><span class="nav-text">列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A1%EF%BC%8C%E5%90%8C%E4%B8%80IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E5%BD%93%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%97%E8%A1%A8%E4%B8%8D%E5%8F%98%E6%97%B6%EF%BC%8C%E5%AE%83%E6%AF%8F%E6%AC%A1%E9%83%BD%E4%BC%9A%E6%98%A0%E5%B0%84%E5%88%B0%E5%90%8C%E4%B8%80%E5%8F%B0%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E3%80%82"><span class="nav-text">衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E3%80%81%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E6%B3%95"><span class="nav-text">4 、加权轮询法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E8%83%BD%E6%9C%BA%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%B9%B6%E4%B8%8D%E7%9B%B8%E5%90%8C%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%AE%83%E4%BB%AC%E7%9A%84%E6%8A%97%E5%8E%8B%E8%83%BD%E5%8A%9B%E4%B9%9F%E4%B8%8D%E7%9B%B8%E5%90%8C%E3%80%82%E7%BB%99%E9%85%8D%E7%BD%AE"><span class="nav-text">不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E3%80%81%E8%B4%9F%E8%BD%BD%E4%BD%8E%E7%9A%84%E6%9C%BA%E5%99%A8%E9%85%8D%E7%BD%AE%E6%9B%B4%E9%AB%98%E7%9A%84%E6%9D%83%E9%87%8D%EF%BC%8C%E8%AE%A9%E5%85%B6%E5%A4%84%E7%90%86%E6%9B%B4%E5%A4%9A%E7%9A%84%E8%AF%B7%EF%BC%9B%E8%80%8C%E9%85%8D%E7%BD%AE%E4%BD%8E%E3%80%81%E8%B4%9F%E8%BD%BD%E9%AB%98%E7%9A%84%E6%9C%BA%E5%99%A8%EF%BC%8C%E7%BB%99%E5%85%B6%E5%88%86%E9%85%8D%E8%BE%83%E4%BD%8E%E7%9A%84%E6%9D%83"><span class="nav-text">高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%EF%BC%8C%E9%99%8D%E4%BD%8E%E5%85%B6%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD%EF%BC%8C%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E8%83%BD%E5%BE%88%E5%A5%BD%E5%9C%B0%E5%A4%84%E7%90%86%E8%BF%99%E4%B8%80%E9%97%AE%E9%A2%98%EF%BC%8C%E5%B9%B6%E5%B0%86%E8%AF%B7%E6%B1%82%E9%A1%BA%E5%BA%8F%E4%B8%94%E6%8C%89%E7%85%A7%E6%9D%83%E9%87%8D%E5%88%86%E9%85%8D%E5%88%B0%E5%90%8E%E7%AB%AF%E3%80%82"><span class="nav-text">重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E3%80%81%E5%8A%A0%E6%9D%83%E9%9A%8F%E6%9C%BA%E6%B3%95"><span class="nav-text">5 、加权随机法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E6%B3%95%E4%B8%80%E6%A0%B7%EF%BC%8C%E5%8A%A0%E6%9D%83%E9%9A%8F%E6%9C%BA%E6%B3%95%E4%B9%9F%E6%A0%B9%E6%8D%AE%E5%90%8E%E7%AB%AF%E6%9C%BA%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%EF%BC%8C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%88%86%E9%85%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9D%83%E9%87%8D%E3%80%82%E4%B8%8D%E5%90%8C%E7%9A%84%E6%98%AF%EF%BC%8C%E5%AE%83%E6%98%AF"><span class="nav-text">与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E7%85%A7%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E8%AF%B7%E6%B1%82%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E8%80%8C%E9%9D%9E%E9%A1%BA%E5%BA%8F%E3%80%82"><span class="nav-text">按照权重随机请求后端服务器，而非顺序。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E3%80%81%E6%9C%80%E5%B0%8F%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%B3%95"><span class="nav-text">6 、最小连接数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E8%BF%9E%E6%8E%A5%E6%95%B0%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83%E7%81%B5%E6%B4%BB%E5%92%8C%E6%99%BA%E8%83%BD%EF%BC%8C%E7%94%B1%E4%BA%8E%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%B0%BD%E7%9B%B8%E5%90%8C%EF%BC%8C%E5%AF%B9%E4%BA%8E%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%84%E7%90%86%E6%9C%89%E5%BF%AB%E6%9C%89%E6%85%A2%EF%BC%8C%E5%AE%83%E6%98%AF%E6%A0%B9"><span class="nav-text">最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%AE%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BD%93%E5%89%8D%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%83%85%E5%86%B5%EF%BC%8C%E5%8A%A8%E6%80%81%E5%9C%B0%E9%80%89%E5%8F%96%E5%85%B6%E4%B8%AD%E5%BD%93%E5%89%8D"><span class="nav-text">据后端服务器当前的连接情况，动态地选取其中当前</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%AF%E5%8E%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%9C%80%E5%B0%91%E7%9A%84%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9D%A5%E5%A4%84%E7%90%86%E5%BD%93%E5%89%8D%E7%9A%84%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%9C%B0%E6%8F%90%E9%AB%98%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%A9%E7%94%A8%E6%95%88%E7%8E%87%EF%BC%8C%E5%B0%86%E8%B4%9F%E8%B4%A3%E5%90%88%E7%90%86%E5%9C%B0%E5%88%86"><span class="nav-text">积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E5%88%B0%E6%AF%8F%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%82"><span class="nav-text">流到每一台服务器。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="nav-text">类型：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS-%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-text">DNS 方式实现负载均衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9AF5-%E5%92%8C-A10"><span class="nav-text">硬件负载均衡：F5 和 A10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9A"><span class="nav-text">软件负载均衡：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B8%8B%EF%BC%8CSession-%E5%85%B1%E4%BA%AB%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%A1%88"><span class="nav-text">分布式架构下，Session 共享有什么方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%BD%A0%E5%AF%B9RPC%E3%80%81RMI%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">简述你对RPC、RMI的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88"><span class="nav-text">分布式id生成方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%A2%9E%E5%BA%8F%E5%88%97"><span class="nav-text">数据库自增序列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">分布式锁解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E8%BF%99%E4%B8%AA%E9%94%81%E7%8B%AC%E7%AB%8B%E4%BA%8E%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%A4%96%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%9C%A8%E6%9C%8D%E5%8A%A1%E9%87%8C%E9%9D%A2%E3%80%82"><span class="nav-text">需要这个锁独立于每一个服务之外，而不是在服务里面。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E5%88%A9%E7%94%A8%E4%B8%BB%E9%94%AE%E5%86%B2%E7%AA%81%E6%8E%A7%E5%88%B6%E4%B8%80%E6%AC%A1%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%83%BD%E8%8E%B7%E5%8F%96%E9%94%81%EF%BC%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E3%80%81%E5%8D%95%E7%82%B9%E3%80%81%E5%A4%B1%E6%95%88%E6%97%B6%E9%97%B4"><span class="nav-text">数据库：利用主键冲突控制一次只有一个线程能获取锁，非阻塞、不可重入、单点、失效时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%94%81%EF%BC%9A%E5%88%A4%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%94%AF%E4%B8%80%E6%A0%87%E5%BF%97%EF%BC%8C%E5%86%8D%E5%88%A0%E9%99%A4"><span class="nav-text">删除锁：判断线程唯一标志，再删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">分布式事务解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XA%E8%A7%84%E8%8C%83%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%84%E8%8C%83%EF%BC%8C%E5%AE%9A%E4%B9%89%E4%BA%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="nav-text">XA规范：分布式事务规范，定义了分布式事务模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E4%B8%AA%E8%A7%92%E8%89%B2%EF%BC%9A%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8-%E5%8D%8F%E8%B0%83%E8%80%85TM-%E3%80%81%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8-%E5%8F%82%E4%B8%8E%E8%80%85RM-%EF%BC%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8FAP%EF%BC%8C%E9%80%9A%E4%BF%A1%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8CRM"><span class="nav-text">四个角色：事务管理器(协调者TM)、资源管理器(参与者RM)，应用程序AP，通信资源管理器CRM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E4%BA%8B%E5%8A%A1%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%A8%AA%E8%B7%A8%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%EF%BC%8C%E8%A6%81%E4%B9%88%E5%85%A8%E9%83%A8%E6%8F%90%E4%BA%A4%E3%80%81%E8%A6%81%E4%B9%88%E5%85%A8%E9%83%A8%E5%9B%9E%E6%BB%9A"><span class="nav-text">全局事务：一个横跨多个数据库的事务，要么全部提交、要么全部回滚</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="nav-text">两阶段协议：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E9%98%B6%E6%AE%B5%E5%8D%8F%E8%AE%AE%EF%BC%9A%E4%B8%BB%E8%A6%81%E6%98%AF%E9%92%88%E5%AF%B9%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%BA%862PC%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BD%86%E6%98%AF%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98%E4%BB%8D%E7%84%B6"><span class="nav-text">三阶段协议：主要是针对两阶段的优化，解决了2PC单点故障的问题，但是性能问题和不一致问题仍然</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89%E6%A0%B9%E6%9C%AC%E8%A7%A3%E5%86%B3"><span class="nav-text">没有根本解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%EF%BC%9A"><span class="nav-text">消息队列的事务消息：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7"><span class="nav-text">如何实现接口的幂等性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0ZAB-%E5%8D%8F%E8%AE%AE"><span class="nav-text">简述ZAB 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D-%EF%BC%9A"><span class="nav-text">崩溃恢复 ：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%86%E7%BE%A4%EF%BC%8C%E5%88%9A%E5%88%9A%E5%90%AF%E5%8A%A8%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-text">初始化集群，刚刚启动的时候</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zk%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8C%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="nav-text">zk的数据模型和节点类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%EF%BC%9A%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="nav-text">数据模型：树形结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0zk%E7%9A%84%E5%91%BD%E5%90%8D%E6%9C%8D%E5%8A%A1%E3%80%81%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E3%80%81%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86"><span class="nav-text">简述zk的命名服务、配置管理、集群管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E6%9C%8D%E5%8A%A1%EF%BC%9A"><span class="nav-text">命名服务：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B2%E4%B8%8BZookeeper-watch%E6%9C%BA%E5%88%B6"><span class="nav-text">讲下Zookeeper watch机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zk%E5%92%8Ceureka%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">zk和eureka的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Cloud%E5%92%8CDubbo%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">Spring Cloud和Dubbo的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFHystrix%EF%BC%9F%E7%AE%80%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-text">什么是Hystrix？简述实现机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%B9%E9%94%99%E6%A1%86%E6%9E%B6"><span class="nav-text">分布式容错框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E6%AD%A2%E6%95%85%E9%9A%9C%E7%9A%84%E8%BF%9E%E9%94%81%E5%8F%8D%E5%BA%94%EF%BC%8C%E5%AE%9E%E7%8E%B0%E7%86%94%E6%96%AD"><span class="nav-text">阻止故障的连锁反应，实现熔断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7"><span class="nav-text">快速失败，实现优雅降级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BE%9B%E5%AE%9E%E6%97%B6%E7%9A%84%E7%9B%91%E6%8E%A7%E5%92%8C%E5%91%8A%E8%AD%A6"><span class="nav-text">提供实时的监控和告警</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%EF%BC%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9A%94%E7%A6%BB"><span class="nav-text">资源隔离：线程隔离，信号量隔离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9A%94%E7%A6%BB%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9C%80%E5%90%91%E4%BE%9D%E8%B5%96%E6%9C%8D%E5%8A%A1%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82%E6%97%B6%EF%BC%8C%E9%A6%96%E5%85%88%E8%A6%81%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%89%8D%E8%83%BD%E7%9C%9F%E6%AD%A3%E5%8F%91%E8%B5%B7%E8%B0%83%E7%94%A8%EF%BC%8C%E7%94%B1%E4%BA%8E%E4%BF%A1"><span class="nav-text">信号量隔离：客户端需向依赖服务发起请求时，首先要获取一个信号量才能真正发起调用，由于信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%86%94%E6%96%AD%E5%92%8C%E9%99%8D%E7%BA%A7%EF%BC%9A%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%A4%B1%E8%B4%A5%E5%90%8E%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5"><span class="nav-text">熔断和降级：调用服务失败后快速失败</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%86%94%E6%96%AD%E6%98%AF%E4%B8%BA%E4%BA%86%E9%98%B2%E6%AD%A2%E5%BC%82%E5%B8%B8%E4%B8%8D%E6%89%A9%E6%95%A3%EF%BC%8C%E4%BF%9D%E8%AF%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="nav-text">熔断是为了防止异常不扩散，保证系统的稳定性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%8D%E7%BA%A7%EF%BC%9A%E7%BC%96%E5%86%99%E5%A5%BD%E8%B0%83%E7%94%A8%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A1%A5%E6%95%91%E9%80%BB%E8%BE%91%EF%BC%8C%E7%84%B6%E5%90%8E%E5%AF%B9%E6%9C%8D%E5%8A%A1%E7%9B%B4%E6%8E%A5%E5%81%9C%E6%AD%A2%E8%BF%90%E8%A1%8C%EF%BC%8C%E8%BF%99%E6%A0%B7%E8%BF%99%E4%BA%9B%E6%8E%A5%E5%8F%A3%E5%B0%B1%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E8%B0%83%E7%94%A8%EF%BC%8C%E4%BD%86%E5%8F%88%E4%B8%8D"><span class="nav-text">降级：编写好调用失败的补救逻辑，然后对服务直接停止运行，这样这些接口就无法正常调用，但又不</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%B3%E4%BA%8E%E7%9B%B4%E6%8E%A5%E6%8A%A5%E9%94%99%EF%BC%8C%E5%8F%AA%E6%98%AF%E6%9C%8D%E5%8A%A1%E6%B0%B4%E5%B9%B3%E4%B8%8B%E9%99%8D"><span class="nav-text">至于直接报错，只是服务水平下降</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#springcloud%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8"><span class="nav-text">springcloud核心组件及其作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dubbo-%E7%9A%84%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%88%86%E5%B1%82"><span class="nav-text">Dubbo 的整体架构设计及分层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E4%B8%AA%E8%A7%92%E8%89%B2%EF%BC%9A"><span class="nav-text">五个角色：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MQ"><span class="nav-text">MQ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0RabbitMQ%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-text">简述RabbitMQ的架构设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81-%EF%BC%9F-%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%EF%BC%9F"><span class="nav-text">RabbitMQ如何确保消息发送 ？ 消息接收？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E6%96%B9%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="nav-text">发送方确认机制：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="nav-text">接收方确认机制：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="nav-text">RabbitMQ事务消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%AF%B9%E4%BF%A1%E9%81%93%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%AE%9E%E7%8E%B0"><span class="nav-text">通过对信道的设置实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E3%80%81%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97"><span class="nav-text">RabbitMQ死信队列、延时队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TTL%EF%BC%9A%E4%B8%80%E6%9D%A1%E6%B6%88%E6%81%AF%E6%88%96%E8%80%85%E8%AF%A5%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%B6%88%E6%81%AF%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%98%E6%B4%BB%E6%97%B6%E9%97%B4"><span class="nav-text">TTL：一条消息或者该队列中的所有消息的最大存活时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E6%9D%A1%E6%B6%88%E6%81%AF%E8%AE%BE%E7%BD%AE%E4%BA%86TTL%E5%B1%9E%E6%80%A7%E6%88%96%E8%80%85%E8%BF%9B%E5%85%A5%E4%BA%86%E8%AE%BE%E7%BD%AETTL%E5%B1%9E%E6%80%A7%E7%9A%84%E9%98%9F%E5%88%97%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E6%9D%A1%E6%B6%88%E6%81%AF%E5%A6%82%E6%9E%9C%E5%9C%A8TTL%E8%AE%BE%E7%BD%AE%E7%9A%84%E6%97%B6%E9%97%B4%E5%86%85%E6%B2%A1"><span class="nav-text">如果一条消息设置了TTL属性或者进入了设置TTL属性的队列，那么这条消息如果在TTL设置的时间内没</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E8%A2%AB%E6%B6%88%E8%B4%B9%EF%BC%8C%E5%88%99%E4%BC%9A%E6%88%90%E4%B8%BA%E2%80%9C%E6%AD%BB%E4%BF%A1%E2%80%9D%E3%80%82%E5%A6%82%E6%9E%9C%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AE%E4%BA%86%E9%98%9F%E5%88%97%E7%9A%84TTL%E5%92%8C%E6%B6%88%E6%81%AF%E7%9A%84TTL%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BE%83%E5%B0%8F%E7%9A%84%E9%82%A3%E4%B8%AA%E5%80%BC%E5%B0%86%E4%BC%9A%E8%A2%AB%E4%BD%BF%E7%94%A8%E3%80%82"><span class="nav-text">有被消费，则会成为“死信”。如果同时配置了队列的TTL和消息的TTL，那么较小的那个值将会被使用。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E9%9C%80%E8%A6%81%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%80%E7%9B%B4%E6%B6%88%E8%B4%B9%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E9%87%8C%E7%9A%84%E6%B6%88%E6%81%AF"><span class="nav-text">只需要消费者一直消费死信队列里的消息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ%E9%95%9C%E5%83%8F%E9%98%9F%E5%88%97%E6%9C%BA%E5%88%B6"><span class="nav-text">RabbitMQ镜像队列机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0kafka%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-text">简述kafka架构设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kafka%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E3%80%81%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81%E3%80%81%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E3%80%81%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1"><span class="nav-text">kafka怎么处理消息顺序、重复发送、重复消费、消息丢失</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="nav-text">Kafka在什么情况下会出现消息丢失及解决方案？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%EF%BC%89%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81"><span class="nav-text">1 ）消息发送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%EF%BC%89%E6%B6%88%E8%B4%B9"><span class="nav-text">2 ）消费</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka%E6%98%AFpull%EF%BC%9Fpush%EF%BC%9F%E4%BC%98%E5%8A%A3%E5%8A%BF%E5%88%86%E6%9E%90"><span class="nav-text">Kafka是pull？push？优劣势分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E6%89%B9%E9%87%8F%E6%8B%89%E5%8F%96%E3%80%81%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%8D%95%E6%9D%A1%E6%8B%89%E5%8F%96"><span class="nav-text">可以批量拉取、也可以单条拉取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%90%8C%E7%9A%84%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BC%A0%E8%BE%93%E8%AF%AD%E4%B9%89"><span class="nav-text">可以设置不同的提交方式，实现不同的传输语义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka%E4%B8%ADzk%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">Kafka中zk的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0kafka%E7%9A%84rebalance%E6%9C%BA%E5%88%B6"><span class="nav-text">简述kafka的rebalance机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka%E7%9A%84%E6%80%A7%E8%83%BD%E5%A5%BD%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9"><span class="nav-text">Kafka的性能好在什么地方</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%EF%BC%9A"><span class="nav-text">传统：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%88%B0%E5%86%85%E6%A0%B8%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">读取磁盘文件数据到内核缓冲区</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lz"
      src="/images/author.jpg">
  <p class="site-author-name" itemprop="name">lz</p>
  <div class="site-description" itemprop="description">德玛西亚</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
	  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=52 src="//music.163.com/outchain/player?type=0&id=8264726996&auto=1&height=32"></iframe>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>
  
  


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lz</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.7m</span>
</div>


<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
	<span title="post.totalcount">
     624k字 </span>
    <!--<span title="站点总字数">1.7m</span>-->
  
  
  
<div>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("08/10/2020 00:00:00");//在此处修改你的建站时间
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "已运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>
</div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
